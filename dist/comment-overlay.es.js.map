{"version":3,"file":"comment-overlay.es.js","sources":["../src/comment/comment-commands.ts","../src/comment/color.ts","../src/comment/time-source.ts","../src/shared/constants.ts","../src/shared/logger.ts","../src/comment/logger.ts","../src/comment/text-measure.ts","../src/comment/prepare.ts","../src/shared/debug.ts","../src/comment/render.ts","../src/comment/direction.ts","../src/comment/comment.ts","../src/config/default-settings.ts","../src/shared/settings.ts","../src/renderer/comments.ts","../src/renderer/final-phase.ts","../src/renderer/playback.ts","../src/renderer/activation.ts","../src/renderer/lanes-prune.ts","../src/renderer/lanes-static.ts","../src/renderer/lanes-activation.ts","../src/renderer/lanes-reservations.ts","../src/renderer/render.ts","../src/renderer/timing.ts","../src/renderer/auto-hard-reset.ts","../src/renderer/lifecycle-core.ts","../src/renderer/lifecycle-video-events.ts","../src/renderer/visibility.ts","../src/renderer/resize.ts","../src/renderer/fullscreen.ts","../src/renderer/cleanup.ts","../src/renderer/comment-renderer.ts"],"sourcesContent":["import {\n  type CommentColorCommand,\n  type CommentCommandParseContext,\n  type CommentCommandParseResult,\n  type CommentFontCommand,\n  type CommentHexColorCommand,\n  type CommentLayoutCommand,\n  type CommentSizeCommand,\n} from \"@/shared/types\";\n\nconst COMMENT_SIZE_SCALE: Record<CommentSizeCommand, number> = {\n  small: 0.8,\n  medium: 1,\n  big: 1.4,\n};\n\nconst FONT_FAMILY_MAP: Record<CommentFontCommand, string> = {\n  defont:\n    '\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Hiragino Kaku Gothic Pro\",\"Yu Gothic UI\",\"Yu Gothic\",\"Meiryo\",\"Segoe UI\",\"Osaka\",\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"IPAPGothic\",\"TakaoPGothic\",\"Roboto\",\"Helvetica Neue\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  gothic:\n    '\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"Yu Gothic\",\"Yu Gothic Medium\",\"Meiryo\",\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Segoe UI\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  mincho:\n    '\"MS PMincho\",\"MS Mincho\",\"Hiragino Mincho ProN\",\"Hiragino Mincho Pro\",\"Yu Mincho\",\"Noto Serif CJK JP\",\"Noto Serif JP\",\"Source Han Serif JP\",\"Times New Roman\",\"serif\"',\n};\n\nconst COLOR_COMMAND_MAP: Record<CommentColorCommand, string> = {\n  white: \"#FFFFFC\",\n  red: \"#FF8888\",\n  pink: \"#FFA5CC\",\n  orange: \"#FFBA66\",\n  yellow: \"#FFFFAA\",\n  green: \"#88FF88\",\n  cyan: \"#88FFFF\",\n  blue: \"#8899FF\",\n  purple: \"#D9A5FF\",\n  black: \"#444444\",\n  white2: \"#CC9\",\n  red2: \"#C03\",\n  pink2: \"#F3C\",\n  orange2: \"#F60\",\n  yellow2: \"#990\",\n  green2: \"#0C6\",\n  cyan2: \"#0CC\",\n  blue2: \"#39F\",\n  purple2: \"#63C\",\n  black2: \"#666\",\n};\n\nconst HEX_COLOR_REGEX = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;\n\nconst COMMAND_PREFIX_STRIP_REGEX = /^[,.:;]+/;\nconst COMMAND_SUFFIX_STRIP_REGEX = /[,.:;]+$/;\n\nconst normalizeCommandToken = (value: string): string => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return \"\";\n  }\n  if (HEX_COLOR_REGEX.test(trimmed)) {\n    return trimmed;\n  }\n  const withoutPrefix = trimmed.replace(COMMAND_PREFIX_STRIP_REGEX, \"\");\n  const withoutSuffix = withoutPrefix.replace(COMMAND_SUFFIX_STRIP_REGEX, \"\");\n  return withoutSuffix;\n};\n\nconst normalizeHexColor = (command: CommentHexColorCommand): string | null => {\n  if (!HEX_COLOR_REGEX.test(command)) {\n    return null;\n  }\n  return command.toUpperCase();\n};\n\nconst parseNumericCommandValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  const withoutPx = trimmed.toLowerCase().endsWith(\"px\") ? trimmed.slice(0, -2) : trimmed;\n  const parsed = Number.parseFloat(withoutPx);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst parseLineHeightValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  if (trimmed.endsWith(\"%\")) {\n    const numeric = Number.parseFloat(trimmed.slice(0, -1));\n    if (!Number.isFinite(numeric)) {\n      return null;\n    }\n    return numeric / 100;\n  }\n  return parseNumericCommandValue(trimmed);\n};\n\nconst clampLetterSpacing = (value: number): number => {\n  const maxSpacing = 100;\n  const minSpacing = -100;\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  return Math.min(maxSpacing, Math.max(minSpacing, value));\n};\n\nconst clampLineHeight = (value: number): number => {\n  const minHeight = 0.25;\n  const maxHeight = 5;\n  if (!Number.isFinite(value) || value === 0) {\n    return 1;\n  }\n  return Math.min(maxHeight, Math.max(minHeight, value));\n};\n\nconst isLayoutCommand = (command: string): command is CommentLayoutCommand =>\n  command === \"naka\" || command === \"ue\" || command === \"shita\";\n\nconst isSizeCommand = (command: string): command is CommentSizeCommand =>\n  command === \"small\" || command === \"medium\" || command === \"big\";\n\nconst isFontCommand = (command: string): command is CommentFontCommand =>\n  command === \"defont\" || command === \"gothic\" || command === \"mincho\";\n\nconst isColorCommand = (command: string): command is CommentColorCommand =>\n  command in COLOR_COMMAND_MAP;\n\nexport const parseCommentCommands = (\n  commands: readonly string[],\n  context: CommentCommandParseContext,\n): CommentCommandParseResult => {\n  let layout: CommentLayoutCommand = \"naka\";\n  let size: CommentSizeCommand = \"medium\";\n  let font: CommentFontCommand = \"defont\";\n  let colorOverride: string | null = null;\n  let opacityMultiplier = 1;\n  let opacityOverride: number | null = null;\n  let isInvisible = false;\n  let letterSpacing = 0;\n  let lineHeight = 1;\n\n  for (const rawCommand of commands) {\n    const normalizedToken = normalizeCommandToken(typeof rawCommand === \"string\" ? rawCommand : \"\");\n    if (!normalizedToken) {\n      continue;\n    }\n\n    if (HEX_COLOR_REGEX.test(normalizedToken)) {\n      const normalized = normalizeHexColor(normalizedToken as CommentHexColorCommand);\n      if (normalized) {\n        colorOverride = normalized;\n        continue;\n      }\n    }\n\n    const lower = normalizedToken.toLowerCase();\n\n    if (isLayoutCommand(lower)) {\n      layout = lower;\n      continue;\n    }\n\n    if (isSizeCommand(lower)) {\n      size = lower;\n      continue;\n    }\n\n    if (isFontCommand(lower)) {\n      font = lower;\n      continue;\n    }\n\n    if (isColorCommand(lower)) {\n      colorOverride = COLOR_COMMAND_MAP[lower].toUpperCase();\n      continue;\n    }\n\n    if (lower === \"_live\") {\n      opacityOverride = 0.5;\n      continue;\n    }\n\n    if (lower === \"invisible\") {\n      opacityMultiplier = 0;\n      isInvisible = true;\n      continue;\n    }\n\n    if (lower.startsWith(\"ls:\") || lower.startsWith(\"letterspacing:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseNumericCommandValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          letterSpacing = clampLetterSpacing(numericValue);\n        }\n      }\n      continue;\n    }\n\n    if (lower.startsWith(\"lh:\") || lower.startsWith(\"lineheight:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseLineHeightValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          lineHeight = clampLineHeight(numericValue);\n        }\n      }\n      continue;\n    }\n  }\n\n  const clampedOpacityMultiplier = Math.max(0, Math.min(1, opacityMultiplier));\n  const resolvedColor = (colorOverride ?? context.defaultColor).toUpperCase();\n  const resolvedOpacityOverride =\n    typeof opacityOverride === \"number\" ? Math.max(0, Math.min(1, opacityOverride)) : null;\n\n  return {\n    layout,\n    size,\n    sizeScale: COMMENT_SIZE_SCALE[size],\n    font,\n    fontFamily: FONT_FAMILY_MAP[font],\n    resolvedColor,\n    colorOverride,\n    opacityMultiplier: clampedOpacityMultiplier,\n    opacityOverride: resolvedOpacityOverride,\n    isInvisible,\n    letterSpacing,\n    lineHeight,\n  };\n};\n","const HEX_COLOR_PATTERN = /^#([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;\n\nconst expandHex = (fragment: string): string =>\n  fragment.length === 1 ? fragment.repeat(2) : fragment;\n\nconst parseHexComponent = (component: string): number => Number.parseInt(component, 16);\n\nexport const clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nexport const resolveFillStyleWithOpacity = (color: string, opacity: number): string => {\n  const match = HEX_COLOR_PATTERN.exec(color);\n  if (!match) {\n    return color;\n  }\n  const body = match[1];\n  let red: number;\n  let green: number;\n  let blue: number;\n  let alpha = 1;\n\n  if (body.length === 3 || body.length === 4) {\n    red = parseHexComponent(expandHex(body[0]));\n    green = parseHexComponent(expandHex(body[1]));\n    blue = parseHexComponent(expandHex(body[2]));\n    if (body.length === 4) {\n      alpha = parseHexComponent(expandHex(body[3])) / 255;\n    }\n  } else {\n    red = parseHexComponent(body.slice(0, 2));\n    green = parseHexComponent(body.slice(2, 4));\n    blue = parseHexComponent(body.slice(4, 6));\n    if (body.length === 8) {\n      alpha = parseHexComponent(body.slice(6, 8)) / 255;\n    }\n  }\n\n  const combinedAlpha = clampOpacity(alpha * clampOpacity(opacity));\n  return `rgba(${red}, ${green}, ${blue}, ${combinedAlpha})`;\n};\n","import type { TimeSource } from \"@/shared/types\";\n\nconst createPerformanceTimeSource = (): TimeSource => ({\n  now: () => {\n    if (typeof performance !== \"undefined\" && typeof performance.now === \"function\") {\n      return performance.now();\n    }\n    return Date.now();\n  },\n});\n\nexport const createDefaultTimeSource = (): TimeSource => createPerformanceTimeSource();\n","export const toMilliseconds = (seconds: number): number => seconds * 1000;\n\nexport const sanitizeVposMs = (value: number): number | null => {\n  if (!Number.isFinite(value)) {\n    return null;\n  }\n  if (value < 0) {\n    return null;\n  }\n  return Math.round(value);\n};\n\nexport const MAX_VISIBLE_DURATION_MS = 4_000;\nexport const MIN_VISIBLE_DURATION_MS = 1_800;\nexport const MAX_COMMENT_WIDTH_RATIO = 3;\nexport const COLLISION_BUFFER_RATIO = 0.25;\nexport const BASE_COLLISION_BUFFER_PX = 32;\nexport const ENTRY_BUFFER_PX = 48;\nexport const RESERVATION_TIME_MARGIN_MS = 120;\nexport const FINAL_PHASE_THRESHOLD_MS = 4_000;\nexport const FINAL_PHASE_MIN_GAP_MS = 120;\nexport const FINAL_PHASE_MAX_GAP_MS = 800;\nexport const FINAL_PHASE_ORDER_EPSILON_MS = 2;\nexport const FINAL_PHASE_MIN_WINDOW_MS = 4_000;\nexport const STATIC_VISIBLE_DURATION_MS = 4_000;\nexport const ACTIVE_WINDOW_MS = STATIC_VISIBLE_DURATION_MS + MAX_VISIBLE_DURATION_MS;\nexport const VIRTUAL_CANVAS_EXTENSION_PX = 1_000;\nexport const MIN_LANE_COUNT = 1;\nexport const DEFAULT_LANE_COUNT = 12;\nexport const MIN_FONT_SIZE_PX = 24;\nexport const EDGE_EPSILON = 1e-3;\nexport const SEEK_DIRECTION_EPSILON_MS = 50;\nexport const STATIC_COMMENT_VERTICAL_PADDING_RATIO = 0.05;\nexport const STATIC_COMMENT_MIN_VERTICAL_PADDING_PX = 10;\nexport const STATIC_COMMENT_EDGE_PADDING_PX = 5;\nexport const STATIC_COMMENT_STACKING_PADDING_PX = 2;\nexport const STATIC_COMMENT_SIDE_MARGIN_PX = 8;\nexport const MIN_STATIC_FONT_SIZE_PX = 12;\nexport const AUTO_HARD_RESET_DEDUP_WINDOW_MS = 500;\nexport const AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS = 3_000;\n","import type { LogLevel, Logger, LoggerOptions } from \"@/shared/types\";\n\nconst LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nconst fallbackEmitter = (level: LogLevel, namespace: string, args: unknown[]): void => {\n  const prefix = `[${namespace}]`;\n  const consoleArgs: unknown[] = [prefix, ...args];\n  switch (level) {\n    case \"debug\":\n      console.debug(...consoleArgs);\n      break;\n    case \"info\":\n      console.info(...consoleArgs);\n      break;\n    case \"warn\":\n      console.warn(...consoleArgs);\n      break;\n    case \"error\":\n      console.error(...consoleArgs);\n      break;\n    default:\n      console.log(...consoleArgs);\n  }\n};\n\nexport const createLogger = (namespace: string, options: LoggerOptions = {}): Logger => {\n  const { level = \"info\", emitter = fallbackEmitter } = options;\n  const threshold = LEVEL_PRIORITY[level];\n\n  const emit = (logLevel: LogLevel, args: unknown[]): void => {\n    if (LEVEL_PRIORITY[logLevel] < threshold) {\n      return;\n    }\n    emitter(logLevel, namespace, args);\n  };\n\n  return {\n    debug: (...messages: unknown[]) => emit(\"debug\", messages),\n    info: (...messages: unknown[]) => emit(\"info\", messages),\n    warn: (...messages: unknown[]) => emit(\"warn\", messages),\n    error: (...messages: unknown[]) => emit(\"error\", messages),\n  };\n};\n\nexport type { LogLevel, Logger, LoggerOptions } from \"@/shared/types\";\n","import { createLogger } from \"@/shared/logger\";\n\nexport const commentLogger = createLogger(\"CommentEngine:Comment\");\n","import type { TextMeasurementCache } from \"@/shared/types\";\n\nconst textMeasurementCaches = new WeakMap<CanvasRenderingContext2D, TextMeasurementCache>();\n\nconst getTextMeasurementCache = (ctx: CanvasRenderingContext2D): TextMeasurementCache => {\n  let cache = textMeasurementCaches.get(ctx);\n  if (!cache) {\n    cache = new Map();\n    textMeasurementCaches.set(ctx, cache);\n  }\n  return cache;\n};\n\nexport const measureTextWidth = (ctx: CanvasRenderingContext2D, text: string): number => {\n  if (!ctx) {\n    return 0;\n  }\n  const fontKey = ctx.font ?? \"\";\n  const cacheKey = `${fontKey}::${text}`;\n  const cache = getTextMeasurementCache(ctx);\n  const cached = cache.get(cacheKey);\n  if (cached !== undefined) {\n    return cached;\n  }\n  const width = ctx.measureText(text).width;\n  cache.set(cacheKey, width);\n  return width;\n};\n","import type { CommentPrepareOptions } from \"@/shared/types\";\nimport type { Comment } from \"@/comment/comment\";\nimport {\n  STATIC_VISIBLE_DURATION_MS,\n  STATIC_COMMENT_SIDE_MARGIN_PX,\n  MIN_STATIC_FONT_SIZE_PX,\n} from \"@/shared/constants\";\nimport { commentLogger as logger } from \"@/comment/logger\";\nimport { measureTextWidth } from \"@/comment/text-measure\";\n\nconst ensureLines = (text: string): string[] => {\n  if (text.includes(\"\\n\")) {\n    const rawLines = text.split(/\\r?\\n/);\n    return rawLines.length > 0 ? rawLines : [\"\"];\n  }\n  return [text];\n};\n\nconst clampFontSize = (value: number): number => Math.max(24, value);\n\nconst updateTextMetrics = (comment: Comment, ctx: CanvasRenderingContext2D): void => {\n  let maxLineWidth = 0;\n  const effectiveLetterSpacing = comment.letterSpacing;\n  for (const line of comment.lines) {\n    const baseWidth = measureTextWidth(ctx, line);\n    const extraSpacing = line.length > 1 ? effectiveLetterSpacing * (line.length - 1) : 0;\n    const totalWidth = Math.max(0, baseWidth + extraSpacing);\n    if (totalWidth > maxLineWidth) {\n      maxLineWidth = totalWidth;\n    }\n  }\n  comment.width = maxLineWidth;\n  const computedLineHeightPx = Math.max(\n    1,\n    Math.floor(comment.fontSize * comment.lineHeightMultiplier),\n  );\n  comment.lineHeightPx = computedLineHeightPx;\n  const additionalHeight =\n    comment.lines.length > 1 ? (comment.lines.length - 1) * computedLineHeightPx : 0;\n  comment.height = comment.fontSize + additionalHeight;\n};\n\nexport const prepareComment = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  visibleWidth: number,\n  canvasHeight: number,\n  options: CommentPrepareOptions,\n): void => {\n  try {\n    if (!ctx) {\n      throw new Error(\"Canvas context is required\");\n    }\n    if (!Number.isFinite(visibleWidth) || !Number.isFinite(canvasHeight)) {\n      throw new Error(\"Canvas dimensions must be numbers\");\n    }\n    if (!options) {\n      throw new Error(\"Prepare options are required\");\n    }\n\n    const safeVisibleWidth = Math.max(visibleWidth, 1);\n    const baseFontSize = clampFontSize(Math.floor(canvasHeight * 0.05));\n    const scaledFontSize = clampFontSize(Math.floor(baseFontSize * comment.sizeScale));\n    comment.fontSize = scaledFontSize;\n    ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n    comment.lines = ensureLines(comment.text);\n    updateTextMetrics(comment, ctx);\n\n    const isStaticTopOrBottom =\n      !comment.isScrolling && (comment.layout === \"ue\" || comment.layout === \"shita\");\n    if (isStaticTopOrBottom) {\n      const maxStaticWidth = Math.max(1, safeVisibleWidth - STATIC_COMMENT_SIDE_MARGIN_PX * 2);\n      if (comment.width > maxStaticWidth) {\n        const minimumFontSize = Math.max(\n          MIN_STATIC_FONT_SIZE_PX,\n          Math.min(comment.fontSize, Math.floor(baseFontSize * 0.6)),\n        );\n        const shrinkFactor = maxStaticWidth / Math.max(comment.width, 1);\n        const initialShrink = Math.max(\n          minimumFontSize,\n          Math.floor(comment.fontSize * Math.min(shrinkFactor, 1)),\n        );\n        if (initialShrink < comment.fontSize) {\n          comment.fontSize = initialShrink;\n          ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n          updateTextMetrics(comment, ctx);\n        }\n        let iteration = 0;\n        while (\n          comment.width > maxStaticWidth &&\n          comment.fontSize > minimumFontSize &&\n          iteration < 5\n        ) {\n          const currentShrink = maxStaticWidth / Math.max(comment.width, 1);\n          const proposedSize = Math.max(\n            minimumFontSize,\n            Math.floor(comment.fontSize * Math.max(currentShrink, 0.7)),\n          );\n          if (proposedSize >= comment.fontSize) {\n            comment.fontSize = Math.max(minimumFontSize, comment.fontSize - 1);\n          } else {\n            comment.fontSize = proposedSize;\n          }\n          ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n          updateTextMetrics(comment, ctx);\n          iteration += 1;\n        }\n      }\n    }\n\n    if (!comment.isScrolling) {\n      comment.bufferWidth = 0;\n      const margin = isStaticTopOrBottom ? STATIC_COMMENT_SIDE_MARGIN_PX : 0;\n      const centeredX = Math.max((safeVisibleWidth - comment.width) / 2, margin);\n      const maxStart = Math.max(margin, safeVisibleWidth - comment.width - margin);\n      const clampedX = Math.min(centeredX, Math.max(maxStart, margin));\n      comment.virtualStartX = clampedX;\n      comment.x = clampedX;\n      comment.baseSpeed = 0;\n      comment.speed = 0;\n      comment.speedPixelsPerMs = 0;\n      comment.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.preCollisionDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.totalDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.reservationWidth = comment.width;\n      comment.staticExpiryTimeMs = comment.vposMs + STATIC_VISIBLE_DURATION_MS;\n      comment.lastUpdateTime = comment.getTimeSource().now();\n      comment.isPaused = false;\n      return;\n    }\n\n    comment.staticExpiryTimeMs = null;\n    const maxReservationWidth = measureTextWidth(ctx, \"??\".repeat(150));\n\n    const bufferFromWidth = comment.width * Math.max(options.bufferRatio, 0);\n    comment.bufferWidth = Math.max(options.baseBufferPx, bufferFromWidth);\n    const entryBuffer = Math.max(options.entryBufferPx, comment.bufferWidth);\n\n    const direction = comment.scrollDirection;\n\n    const startLeft =\n      direction === \"rtl\"\n        ? safeVisibleWidth + options.virtualExtension\n        : -comment.width - comment.bufferWidth - options.virtualExtension;\n    const exitLeft =\n      direction === \"rtl\"\n        ? -comment.width - comment.bufferWidth - entryBuffer\n        : safeVisibleWidth + entryBuffer;\n    const trailingBoundary = direction === \"rtl\" ? safeVisibleWidth + entryBuffer : -entryBuffer;\n    const trailingEdgeAtStart =\n      direction === \"rtl\"\n        ? startLeft + comment.width + comment.bufferWidth\n        : startLeft - comment.bufferWidth;\n\n    comment.virtualStartX = startLeft;\n    comment.x = startLeft;\n    comment.exitThreshold = exitLeft;\n\n    const widthRatio = safeVisibleWidth > 0 ? comment.width / safeVisibleWidth : 0;\n    const hasFixedDuration = options.maxVisibleDurationMs === options.minVisibleDurationMs;\n    let visibleDurationMs = options.maxVisibleDurationMs;\n    if (!hasFixedDuration && widthRatio > 1) {\n      const clampedRatio = Math.min(widthRatio, options.maxWidthRatio);\n      const adjustedDuration = options.maxVisibleDurationMs / Math.max(clampedRatio, 1);\n      visibleDurationMs = Math.max(options.minVisibleDurationMs, Math.floor(adjustedDuration));\n    }\n\n    const visibleDistance = safeVisibleWidth + comment.width + comment.bufferWidth + entryBuffer;\n    const safeVisibleDuration = Math.max(visibleDurationMs, 1);\n    const pixelsPerMs = visibleDistance / safeVisibleDuration;\n    const pixelsPerFrame = (pixelsPerMs * 1000) / 60;\n    comment.baseSpeed = pixelsPerFrame;\n    comment.speed = comment.baseSpeed;\n    comment.speedPixelsPerMs = pixelsPerMs;\n\n    const travelDistance = Math.abs(exitLeft - startLeft);\n    const preCollisionDistance =\n      direction === \"rtl\"\n        ? Math.max(0, trailingEdgeAtStart - trailingBoundary)\n        : Math.max(0, trailingBoundary - trailingEdgeAtStart);\n    const safePixelsPerMs = Math.max(pixelsPerMs, Number.EPSILON);\n\n    comment.visibleDurationMs = visibleDurationMs;\n    comment.preCollisionDurationMs = Math.max(0, Math.ceil(preCollisionDistance / safePixelsPerMs));\n    comment.totalDurationMs = Math.max(\n      comment.preCollisionDurationMs,\n      Math.ceil(travelDistance / safePixelsPerMs),\n    );\n\n    const reservationBase = comment.width + comment.bufferWidth + entryBuffer;\n    comment.reservationWidth = Math.min(maxReservationWidth, reservationBase);\n    comment.lastUpdateTime = comment.getTimeSource().now();\n    comment.isPaused = false;\n  } catch (error) {\n    logger.error(\"Comment.prepare\", error as Error, {\n      text: comment.text,\n      visibleWidth,\n      canvasHeight,\n      hasContext: Boolean(ctx),\n    });\n    throw error;\n  }\n};\n\nexport { updateTextMetrics };\n","import type { DebugLoggingOptions, DebugState } from \"@/shared/types\";\nexport type { DebugLoggingOptions } from \"@/shared/types\";\n\nconst DEFAULT_MAX_LOGS_PER_CATEGORY = 5;\n\nconst state: DebugState = {\n  enabled: false,\n  maxLogsPerCategory: DEFAULT_MAX_LOGS_PER_CATEGORY,\n};\n\nconst categoryCounters = new Map<string, number>();\n\nconst normalizeLimit = (limit: number | undefined): number => {\n  if (limit === undefined) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  if (!Number.isFinite(limit)) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  const rounded = Math.max(1, Math.floor(limit));\n  return Math.min(10_000, rounded);\n};\n\nexport const configureDebugLogging = (options: DebugLoggingOptions): void => {\n  state.enabled = Boolean(options.enabled);\n  state.maxLogsPerCategory = normalizeLimit(options.maxLogsPerCategory);\n  if (!state.enabled) {\n    categoryCounters.clear();\n  }\n};\n\nexport const resetDebugCounters = (): void => {\n  categoryCounters.clear();\n};\n\nexport const isDebugLoggingEnabled = (): boolean => state.enabled;\n\nconst shouldEmitLog = (category: string): boolean => {\n  const currentCount = categoryCounters.get(category) ?? 0;\n  if (currentCount >= state.maxLogsPerCategory) {\n    if (currentCount === state.maxLogsPerCategory) {\n      console.debug(`[CommentOverlay][${category}]`, \"Further logs suppressed.\");\n      categoryCounters.set(category, currentCount + 1);\n    }\n    return false;\n  }\n  categoryCounters.set(category, currentCount + 1);\n  return true;\n};\n\nexport const debugLog = (category: string, ...payload: unknown[]): void => {\n  if (!state.enabled) {\n    return;\n  }\n  if (!shouldEmitLog(category)) {\n    return;\n  }\n  console.debug(`[CommentOverlay][${category}]`, ...payload);\n};\n\nexport const formatCommentPreview = (text: string, maxLength = 32): string => {\n  if (text.length <= maxLength) {\n    return text;\n  }\n  return `${text.slice(0, maxLength)}…`;\n};\n\n// 内部状態ダンプ\nexport const dumpRendererState = (\n  label: string,\n  snapshot: {\n    currentTime: number;\n    duration: number;\n    isPlaying: boolean;\n    epochId: number;\n    totalComments: number;\n    activeComments: number;\n    reservedLanes: number;\n    finalPhaseActive: boolean;\n    playbackHasBegun: boolean;\n    isStalled: boolean;\n  },\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  console.group(`[CommentOverlay][state-dump] ${label}`);\n  console.table({\n    \"Current Time\": `${snapshot.currentTime.toFixed(2)}ms`,\n    Duration: `${snapshot.duration.toFixed(2)}ms`,\n    \"Is Playing\": snapshot.isPlaying,\n    \"Epoch ID\": snapshot.epochId,\n    \"Total Comments\": snapshot.totalComments,\n    \"Active Comments\": snapshot.activeComments,\n    \"Reserved Lanes\": snapshot.reservedLanes,\n    \"Final Phase\": snapshot.finalPhaseActive,\n    \"Playback Begun\": snapshot.playbackHasBegun,\n    \"Is Stalled\": snapshot.isStalled,\n  });\n  console.groupEnd();\n};\n\n// エポック変更のログ\nexport const logEpochChange = (\n  previousEpochId: number,\n  newEpochId: number,\n  reason: string,\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  debugLog(\"epoch-change\", `Epoch changed: ${previousEpochId} → ${newEpochId} (reason: ${reason})`);\n};\n","import type { Comment } from \"@/comment/comment\";\nimport type { DrawMode } from \"@/shared/types\";\nimport { clampOpacity, resolveFillStyleWithOpacity } from \"@/comment/color\";\nimport { commentLogger as logger } from \"@/comment/logger\";\nimport { isDebugLoggingEnabled } from \"@/shared/debug\";\nimport { measureTextWidth } from \"@/comment/text-measure\";\n\nconst cacheStats = {\n  hits: 0,\n  misses: 0,\n  creates: 0,\n  fallbacks: 0,\n  outlineCallsInCache: 0,\n  fillCallsInCache: 0,\n  outlineCallsInFallback: 0,\n  fillCallsInFallback: 0,\n  letterSpacingComments: 0,\n  normalComments: 0,\n  multiLineComments: 0,\n  totalCharactersDrawn: 0,\n  lastReported: 0,\n};\n\nconst reportCacheStats = (): void => {\n  if (!isDebugLoggingEnabled()) {\n    return;\n  }\n  const now = performance.now();\n  if (now - cacheStats.lastReported <= 5000) {\n    return;\n  }\n  const total = cacheStats.hits + cacheStats.misses;\n  const hitRate = total > 0 ? (cacheStats.hits / total) * 100 : 0;\n  const avgCharsPerComment =\n    cacheStats.creates > 0\n      ? (cacheStats.totalCharactersDrawn / cacheStats.creates).toFixed(1)\n      : \"0\";\n  const totalOutlineCalls = cacheStats.outlineCallsInCache + cacheStats.outlineCallsInFallback;\n  const totalFillCalls = cacheStats.fillCallsInCache + cacheStats.fillCallsInFallback;\n  console.log(\n    `[TextureCache Stats]`,\n    `\\n  Cache: Hits=${cacheStats.hits}, Misses=${cacheStats.misses}, Hit Rate=${hitRate.toFixed(1)}%`,\n    `\\n  Creates: ${cacheStats.creates}, Fallbacks: ${cacheStats.fallbacks}`,\n    `\\n  Comments: Normal=${cacheStats.normalComments}, LetterSpacing=${cacheStats.letterSpacingComments}, MultiLine=${cacheStats.multiLineComments}`,\n    `\\n  Draw Calls: Outline=${totalOutlineCalls}, Fill=${totalFillCalls}`,\n    `\\n  Avg Characters/Comment: ${avgCharsPerComment}`,\n  );\n  cacheStats.lastReported = now;\n};\n\nconst isOffscreenCanvasSupported = (): boolean => typeof OffscreenCanvas !== \"undefined\";\n\ntype ShadowParams = {\n  blur: number;\n  alpha: number;\n};\n\nconst getShadowParams = (\n  intensity: import(\"@/shared/types\").ShadowIntensity,\n  fontSize: number,\n  baseOpacity: number,\n): ShadowParams => {\n  if (intensity === \"none\") {\n    return { blur: 0, alpha: 0 };\n  }\n\n  const blurRatio = {\n    light: 0.06,\n    medium: 0.1,\n    strong: 0.15,\n  }[intensity];\n\n  const alphaMultiplier = {\n    light: 0.6,\n    medium: 0.8,\n    strong: 0.95,\n  }[intensity];\n\n  const blur = Math.max(2, fontSize * blurRatio);\n  const alpha = clampOpacity(baseOpacity * alphaMultiplier);\n\n  return { blur, alpha };\n};\n\nconst createSegmentDrawer = (\n  comment: Comment,\n  targetCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  measurementCtx: CanvasRenderingContext2D,\n  statsTarget: \"cache\" | \"fallback\",\n  baseDrawX: number,\n): ((line: string, baselineY: number, mode: DrawMode, offsetX?: number) => void) => {\n  return (line, baselineY, mode, offsetX = 0) => {\n    if (line.length === 0) {\n      return;\n    }\n\n    const effectiveDrawX = baseDrawX + offsetX;\n\n    const recordDraw = (): void => {\n      if (statsTarget === \"cache\") {\n        if (mode === \"outline\") {\n          cacheStats.outlineCallsInCache++;\n        } else {\n          cacheStats.fillCallsInCache++;\n        }\n      } else if (mode === \"outline\") {\n        cacheStats.outlineCallsInFallback++;\n      } else {\n        cacheStats.fillCallsInFallback++;\n      }\n    };\n\n    if (Math.abs(comment.letterSpacing) < Number.EPSILON) {\n      recordDraw();\n      targetCtx.fillText(line, effectiveDrawX, baselineY);\n      return;\n    }\n\n    let cursorX = effectiveDrawX;\n    for (let index = 0; index < line.length; index += 1) {\n      const char = line[index];\n      recordDraw();\n      targetCtx.fillText(char, cursorX, baselineY);\n      const advance = measureTextWidth(measurementCtx, char);\n      cursorX += advance;\n      if (index < line.length - 1) {\n        cursorX += comment.letterSpacing;\n      }\n    }\n  };\n};\n\nconst generateTextureCacheKey = (comment: Comment): string => {\n  return `v2::${comment.text}::${comment.fontSize}::${comment.fontFamily}::${comment.color}::${comment.opacity}::${comment.renderStyle}::${comment.letterSpacing}::${comment.lines.length}`;\n};\n\nconst createTextureCanvas = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n): OffscreenCanvas | null => {\n  if (!isOffscreenCanvasSupported()) {\n    return null;\n  }\n\n  const hasLetterSpacing = Math.abs(comment.letterSpacing) >= Number.EPSILON;\n  const isMultiLine = comment.lines.length > 1;\n  if (hasLetterSpacing) {\n    cacheStats.letterSpacingComments++;\n  }\n  if (isMultiLine) {\n    cacheStats.multiLineComments++;\n  }\n  if (!hasLetterSpacing && !isMultiLine) {\n    cacheStats.normalComments++;\n  }\n  cacheStats.totalCharactersDrawn += comment.text.length;\n\n  const padding = Math.max(10, comment.fontSize * 0.5);\n  const textureWidth = Math.ceil(comment.width + padding * 2);\n  const textureHeight = Math.ceil(comment.height + padding * 2);\n\n  const offscreen = new OffscreenCanvas(textureWidth, textureHeight);\n  const offscreenCtx = offscreen.getContext(\"2d\");\n  if (!offscreenCtx) {\n    return null;\n  }\n\n  offscreenCtx.save();\n  offscreenCtx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n  const effectiveOpacity = clampOpacity(comment.opacity);\n  const drawX = padding;\n  const linesToRender = comment.lines.length > 0 ? comment.lines : [comment.text];\n  const lineAdvance =\n    comment.lines.length > 1 && comment.lineHeightPx > 0 ? comment.lineHeightPx : comment.fontSize;\n  const baselineStart = padding + comment.fontSize;\n  const drawSegment = createSegmentDrawer(comment, offscreenCtx, ctx, \"cache\", drawX);\n\n  const resolvedFillStyle = resolveFillStyleWithOpacity(comment.color, effectiveOpacity);\n\n  const shadowParams = getShadowParams(comment.shadowIntensity, comment.fontSize, effectiveOpacity);\n\n  if (isDebugLoggingEnabled()) {\n    console.log(\n      `[Shadow Debug - Cache]`,\n      `\\n  Text: \"${comment.text}\"`,\n      `\\n  FontSize: ${comment.fontSize}`,\n      `\\n  Shadow intensity: ${comment.shadowIntensity}`,\n      `\\n  Shadow blur: ${shadowParams.blur}px`,\n      `\\n  Shadow alpha: ${shadowParams.alpha}`,\n      `\\n  Fill style: ${resolvedFillStyle}`,\n    );\n  }\n\n  offscreenCtx.save();\n  offscreenCtx.shadowColor = `rgba(0, 0, 0, ${shadowParams.alpha})`;\n  offscreenCtx.shadowBlur = shadowParams.blur;\n  offscreenCtx.shadowOffsetX = 0;\n  offscreenCtx.shadowOffsetY = 0;\n  offscreenCtx.fillStyle = resolvedFillStyle;\n\n  linesToRender.forEach((line: string, index: number) => {\n    const baseline = baselineStart + index * lineAdvance;\n    drawSegment(line, baseline, \"fill\");\n  });\n\n  offscreenCtx.restore();\n\n  offscreenCtx.restore();\n  return offscreen;\n};\n\nconst drawWithFallback = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  interpolatedX: number | null,\n): void => {\n  cacheStats.fallbacks++;\n  ctx.save();\n  ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n  const effectiveOpacity = clampOpacity(comment.opacity);\n  const drawX = interpolatedX ?? comment.x;\n  const linesToRender = comment.lines.length > 0 ? comment.lines : [comment.text];\n  const lineAdvance =\n    comment.lines.length > 1 && comment.lineHeightPx > 0 ? comment.lineHeightPx : comment.fontSize;\n  const baselineStart = comment.y + comment.fontSize;\n  const drawSegment = createSegmentDrawer(comment, ctx, ctx, \"fallback\", drawX);\n\n  const resolvedFillStyle = resolveFillStyleWithOpacity(comment.color, effectiveOpacity);\n\n  const shadowParams = getShadowParams(comment.shadowIntensity, comment.fontSize, effectiveOpacity);\n\n  if (isDebugLoggingEnabled()) {\n    console.log(\n      `[Shadow Debug - Fallback]`,\n      `\\n  Text: \"${comment.text}\"`,\n      `\\n  FontSize: ${comment.fontSize}`,\n      `\\n  Shadow intensity: ${comment.shadowIntensity}`,\n      `\\n  Shadow blur: ${shadowParams.blur}px`,\n      `\\n  Shadow alpha: ${shadowParams.alpha}`,\n      `\\n  Fill style: ${resolvedFillStyle}`,\n    );\n  }\n\n  ctx.save();\n  ctx.shadowColor = `rgba(0, 0, 0, ${shadowParams.alpha})`;\n  ctx.shadowBlur = shadowParams.blur;\n  ctx.shadowOffsetX = 0;\n  ctx.shadowOffsetY = 0;\n  ctx.fillStyle = resolvedFillStyle;\n\n  linesToRender.forEach((line: string, index: number) => {\n    const baseline = baselineStart + index * lineAdvance;\n    drawSegment(line, baseline, \"fill\");\n  });\n\n  ctx.restore();\n\n  ctx.restore();\n};\n\nexport const drawComment = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  interpolatedX: number | null,\n): void => {\n  try {\n    if (!comment.isActive || !ctx) {\n      return;\n    }\n    const currentCacheKey = generateTextureCacheKey(comment);\n    const cachedTexture = comment.getCachedTexture();\n    if (comment.getTextureCacheKey() !== currentCacheKey || !cachedTexture) {\n      cacheStats.misses++;\n      cacheStats.creates++;\n      const created = createTextureCanvas(comment, ctx);\n      comment.setCachedTexture(created);\n      comment.setTextureCacheKey(currentCacheKey);\n    } else {\n      cacheStats.hits++;\n    }\n\n    const texture = comment.getCachedTexture();\n    if (texture) {\n      const drawX = interpolatedX ?? comment.x;\n      const padding = Math.max(10, comment.fontSize * 0.5);\n      ctx.drawImage(texture, drawX - padding, comment.y - padding);\n      reportCacheStats();\n      return;\n    }\n\n    drawWithFallback(comment, ctx, interpolatedX);\n    reportCacheStats();\n  } catch (error) {\n    logger.error(\"Comment.draw\", error as Error, {\n      text: comment.text,\n      isActive: comment.isActive,\n      hasContext: Boolean(ctx),\n      interpolatedX,\n    });\n  }\n};\n","import type { ScrollDirection } from \"@/shared/types\";\n\nexport const resolveScrollDirection = (input: ScrollDirection | string): ScrollDirection =>\n  input === \"ltr\" ? \"ltr\" : \"rtl\";\n\nexport const getDirectionSign = (direction: ScrollDirection): -1 | 1 =>\n  direction === \"ltr\" ? 1 : -1;\n","import type {\n  CommentLayoutCommand,\n  RenderStyle,\n  RendererSettings,\n  ScrollDirection,\n  CommentDependencies,\n  CommentPrepareOptions,\n  TimeSource,\n} from \"@/shared/types\";\nimport { parseCommentCommands } from \"@/comment/comment-commands\";\nimport { clampOpacity } from \"@/comment/color\";\nimport { createDefaultTimeSource } from \"@/comment/time-source\";\nimport { prepareComment } from \"@/comment/prepare\";\nimport { drawComment } from \"@/comment/render\";\nimport { resolveScrollDirection, getDirectionSign } from \"@/comment/direction\";\nimport { commentLogger as logger } from \"@/comment/logger\";\n\nexport class Comment {\n  readonly text: string;\n  readonly vposMs: number;\n  readonly commands: string[];\n  readonly layout: CommentLayoutCommand;\n  readonly isScrolling: boolean;\n  readonly sizeScale: number;\n  readonly opacityMultiplier: number;\n  readonly opacityOverride: number | null;\n  readonly colorOverride: string | null;\n  readonly isInvisible: boolean;\n\n  x = 0;\n  y = 0;\n  width = 0;\n  height = 0;\n  baseSpeed = 0;\n  speed = 0;\n  lane = -1;\n  color: string;\n  fontSize = 0;\n  fontFamily: string;\n  opacity: number;\n  activationTimeMs: number | null = null;\n  staticExpiryTimeMs: number | null = null;\n  isActive = false;\n  hasShown = false;\n  isPaused = false;\n  lastUpdateTime = 0;\n  reservationWidth = 0;\n  bufferWidth = 0;\n  visibleDurationMs = 0;\n  totalDurationMs = 0;\n  preCollisionDurationMs = 0;\n  speedPixelsPerMs = 0;\n  virtualStartX = 0;\n  exitThreshold = 0;\n  scrollDirection: ScrollDirection = \"rtl\";\n  renderStyle: RenderStyle = \"outline-only\";\n  shadowIntensity: import(\"@/shared/types\").ShadowIntensity = \"medium\";\n  creationIndex = 0;\n  letterSpacing = 0;\n  lineHeightMultiplier = 1;\n  lineHeightPx = 0;\n  lines: string[] = [];\n  epochId = 0;\n  private directionSign: -1 | 1 = -1;\n  private readonly timeSource: TimeSource;\n  private lastSyncedSettingsVersion = -1;\n  private cachedTexture: OffscreenCanvas | null = null;\n  private textureCacheKey = \"\";\n\n  constructor(\n    text: string,\n    vposMs: number,\n    commands: string[] | undefined,\n    settings: RendererSettings,\n    dependencies: CommentDependencies = {},\n  ) {\n    if (typeof text !== \"string\") {\n      throw new Error(\"Comment text must be a string\");\n    }\n    if (!Number.isFinite(vposMs) || vposMs < 0) {\n      throw new Error(\"Comment vposMs must be a non-negative number\");\n    }\n\n    this.text = text;\n    this.vposMs = vposMs;\n    this.commands = Array.isArray(commands) ? [...commands] : [];\n\n    const parsedCommands = parseCommentCommands(this.commands, {\n      defaultColor: settings.commentColor,\n    });\n\n    this.layout = parsedCommands.layout;\n    this.isScrolling = this.layout === \"naka\";\n    this.sizeScale = parsedCommands.sizeScale;\n    this.opacityMultiplier = parsedCommands.opacityMultiplier;\n    this.opacityOverride = parsedCommands.opacityOverride;\n    this.colorOverride = parsedCommands.colorOverride;\n    this.isInvisible = parsedCommands.isInvisible;\n    this.fontFamily = parsedCommands.fontFamily;\n    this.color = parsedCommands.resolvedColor;\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.renderStyle = settings.renderStyle;\n    this.shadowIntensity = settings.shadowIntensity;\n    this.letterSpacing = parsedCommands.letterSpacing;\n    this.lineHeightMultiplier = parsedCommands.lineHeight;\n\n    this.timeSource = dependencies.timeSource ?? createDefaultTimeSource();\n    this.applyScrollDirection(settings.scrollDirection);\n    this.syncWithSettings(settings, dependencies.settingsVersion);\n  }\n\n  prepare(\n    ctx: CanvasRenderingContext2D,\n    visibleWidth: number,\n    canvasHeight: number,\n    options: CommentPrepareOptions,\n  ): void {\n    prepareComment(this, ctx, visibleWidth, canvasHeight, options);\n  }\n\n  draw(ctx: CanvasRenderingContext2D, interpolatedX: number | null = null): void {\n    drawComment(this, ctx, interpolatedX);\n  }\n\n  update(playbackRate = 1.0, isPaused = false): void {\n    try {\n      if (!this.isActive) {\n        this.isPaused = isPaused;\n        return;\n      }\n\n      const currentTime = this.timeSource.now();\n\n      if (!this.isScrolling) {\n        this.isPaused = isPaused;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      if (isPaused) {\n        this.isPaused = true;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      const deltaTime = (currentTime - this.lastUpdateTime) / (1000 / 60);\n      this.speed = this.baseSpeed * playbackRate;\n      this.x += this.speed * deltaTime * this.directionSign;\n      const hasExited =\n        (this.scrollDirection === \"rtl\" && this.x <= this.exitThreshold) ||\n        (this.scrollDirection === \"ltr\" && this.x >= this.exitThreshold);\n      if (hasExited) {\n        this.isActive = false;\n      }\n      this.lastUpdateTime = currentTime;\n      this.isPaused = false;\n    } catch (error) {\n      logger.error(\"Comment.update\", error as Error, {\n        text: this.text,\n        playbackRate,\n        isPaused,\n        isActive: this.isActive,\n      });\n    }\n  }\n\n  syncWithSettings(settings: RendererSettings, settingsVersion?: number): void {\n    const hasSyncedVersion =\n      typeof settingsVersion === \"number\" && settingsVersion === this.lastSyncedSettingsVersion;\n    if (hasSyncedVersion) {\n      return;\n    }\n    this.color = this.getEffectiveColor(settings.commentColor);\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.applyScrollDirection(settings.scrollDirection);\n    this.renderStyle = settings.renderStyle;\n    this.shadowIntensity = settings.shadowIntensity;\n    if (typeof settingsVersion === \"number\") {\n      this.lastSyncedSettingsVersion = settingsVersion;\n    }\n  }\n\n  getEffectiveColor(defaultColor: string): string {\n    const candidate = this.colorOverride ?? defaultColor;\n    if (typeof candidate !== \"string\" || candidate.length === 0) {\n      return defaultColor;\n    }\n    return candidate.toUpperCase();\n  }\n\n  getEffectiveOpacity(defaultOpacity: number): number {\n    if (typeof this.opacityOverride === \"number\") {\n      return clampOpacity(this.opacityOverride);\n    }\n    const scaled = defaultOpacity * this.opacityMultiplier;\n    if (!Number.isFinite(scaled)) {\n      return 0;\n    }\n    return clampOpacity(scaled);\n  }\n\n  markActivated(atTimeMs: number): void {\n    this.activationTimeMs = atTimeMs;\n  }\n\n  clearActivation(): void {\n    this.activationTimeMs = null;\n    if (!this.isScrolling) {\n      this.staticExpiryTimeMs = null;\n    }\n    this.resetTextureCache();\n  }\n\n  hasStaticExpired(currentTimeMs: number): boolean {\n    if (this.isScrolling) {\n      return false;\n    }\n    if (this.staticExpiryTimeMs === null) {\n      return false;\n    }\n    return currentTimeMs >= this.staticExpiryTimeMs;\n  }\n\n  getDirectionSign(): -1 | 1 {\n    return this.directionSign;\n  }\n\n  getTimeSource(): TimeSource {\n    return this.timeSource;\n  }\n\n  getTextureCacheKey(): string {\n    return this.textureCacheKey;\n  }\n\n  setTextureCacheKey(value: string): void {\n    this.textureCacheKey = value;\n  }\n\n  getCachedTexture(): OffscreenCanvas | null {\n    return this.cachedTexture;\n  }\n\n  setCachedTexture(texture: OffscreenCanvas | null): void {\n    this.cachedTexture = texture;\n  }\n\n  resetTextureCache(): void {\n    this.cachedTexture = null;\n    this.textureCacheKey = \"\";\n  }\n\n  private applyScrollDirection(direction: ScrollDirection | string): void {\n    const resolved = resolveScrollDirection(direction);\n    this.scrollDirection = resolved;\n    this.directionSign = getDirectionSign(resolved);\n  }\n}\n","import type { RendererSettings, ReadonlyRendererSettings } from \"@/shared/types\";\n\nexport const NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS = 4_000;\n\nconst BASE_SETTINGS: RendererSettings = {\n  commentColor: \"#FFFFFF\",\n  commentOpacity: 1,\n  isCommentVisible: true,\n  useContainerResizeObserver: true,\n  ngWords: [],\n  ngRegexps: [],\n  scrollDirection: \"rtl\",\n  renderStyle: \"outline-only\",\n  syncMode: \"raf\",\n  scrollVisibleDurationMs: NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS,\n  useFixedLaneCount: false,\n  fixedLaneCount: 12,\n  useDprScaling: true,\n  enableAutoHardReset: true,\n  shadowIntensity: \"medium\",\n};\n\nexport const DEFAULT_RENDERER_SETTINGS: ReadonlyRendererSettings = BASE_SETTINGS;\n\nexport const cloneDefaultSettings = (): RendererSettings => ({\n  ...BASE_SETTINGS,\n  ngWords: [...BASE_SETTINGS.ngWords],\n  ngRegexps: [...BASE_SETTINGS.ngRegexps],\n});\n\nexport const COMMENT_OVERLAY_VERSION = \"v2.8.1\";\n","import type { RendererSettings, AnimationFrameProvider, TimeSource } from \"@/shared/types\";\nimport {\n  STATIC_COMMENT_EDGE_PADDING_PX,\n  STATIC_COMMENT_STACKING_PADDING_PX,\n} from \"@/shared/constants\";\n\nexport const clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 1;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nexport const calculateStaticCommentVerticalPadding = (\n  _fontSize: number,\n  laneIndex: number = 0,\n): number => {\n  if (laneIndex === 0) {\n    return STATIC_COMMENT_EDGE_PADDING_PX;\n  }\n  return STATIC_COMMENT_STACKING_PADDING_PX;\n};\n\nexport const normalizeSettings = (settings: RendererSettings): RendererSettings => {\n  const rawDuration = settings.scrollVisibleDurationMs;\n  const normalizedDuration =\n    rawDuration === null || rawDuration === undefined\n      ? null\n      : Number.isFinite(rawDuration)\n        ? Math.max(1, Math.floor(rawDuration))\n        : null;\n\n  return {\n    ...settings,\n    scrollDirection: settings.scrollDirection === \"ltr\" ? \"ltr\" : \"rtl\",\n    commentOpacity: clampOpacity(settings.commentOpacity),\n    renderStyle: settings.renderStyle === \"classic\" ? \"classic\" : \"outline-only\",\n    scrollVisibleDurationMs: normalizedDuration,\n    syncMode: settings.syncMode === \"video-frame\" ? \"video-frame\" : \"raf\",\n    useDprScaling: Boolean(settings.useDprScaling),\n    enableAutoHardReset: settings.enableAutoHardReset !== false,\n  };\n};\n\nexport const createDefaultAnimationFrameProvider = (\n  timeSource: TimeSource,\n): AnimationFrameProvider => {\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.requestAnimationFrame === \"function\" &&\n    typeof window.cancelAnimationFrame === \"function\"\n  ) {\n    return {\n      request: (callback) => window.requestAnimationFrame(callback),\n      cancel: (handle) => window.cancelAnimationFrame(handle),\n    };\n  }\n  return {\n    request: (callback) => {\n      const timeoutId = globalThis.setTimeout(() => {\n        callback(timeSource.now());\n      }, 16);\n      return timeoutId;\n    },\n    cancel: (handle) => {\n      globalThis.clearTimeout(handle);\n    },\n  };\n};\n\nexport const createBrowserCanvasFactory = (): (() => HTMLCanvasElement) => {\n  if (typeof document === \"undefined\") {\n    return () => {\n      throw new Error(\n        \"Document is not available. Provide a custom createCanvasElement implementation.\",\n      );\n    };\n  }\n  return () => document.createElement(\"canvas\");\n};\n\nexport const isRendererSettings = (input: unknown): input is RendererSettings => {\n  if (!input || typeof input !== \"object\") {\n    return false;\n  }\n  const candidate = input as Record<string, unknown>;\n  return (\n    typeof candidate.commentColor === \"string\" &&\n    typeof candidate.commentOpacity === \"number\" &&\n    typeof candidate.isCommentVisible === \"boolean\"\n  );\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { Comment } from \"@/comment/comment\";\nimport { formatCommentPreview, debugLog } from \"@/shared/debug\";\nimport { EDGE_EPSILON, sanitizeVposMs } from \"@/shared/constants\";\n\nconst addCommentsImpl = function (\n  this: CommentRenderer,\n  entries: ReadonlyArray<{ text: string; vposMs: number; commands?: string[] }>,\n): Comment[] {\n  if (!Array.isArray(entries) || entries.length === 0) {\n    return [];\n  }\n\n  const addedComments: Comment[] = [];\n  this.commentDependencies.settingsVersion = this.settingsVersion;\n\n  for (const entry of entries) {\n    const { text, vposMs, commands = [] } = entry;\n    const preview = formatCommentPreview(text);\n\n    if (this.isNGComment(text)) {\n      debugLog(\"comment-skip-ng\", { preview, vposMs });\n      continue;\n    }\n\n    const normalizedVposMs = sanitizeVposMs(vposMs);\n    if (normalizedVposMs === null) {\n      this.log.warn(\"CommentRenderer.addComment.invalidVpos\", { text, vposMs });\n      debugLog(\"comment-skip-invalid-vpos\", { preview, vposMs });\n      continue;\n    }\n\n    const duplicate =\n      this.comments.some(\n        (comment) => comment.text === text && comment.vposMs === normalizedVposMs,\n      ) ||\n      addedComments.some((comment) => comment.text === text && comment.vposMs === normalizedVposMs);\n    if (duplicate) {\n      debugLog(\"comment-skip-duplicate\", { preview, vposMs: normalizedVposMs });\n      continue;\n    }\n\n    const comment = new Comment(\n      text,\n      normalizedVposMs,\n      commands,\n      this._settings,\n      this.commentDependencies,\n    );\n    comment.creationIndex = this.commentSequence++;\n    comment.epochId = this.epochId;\n    addedComments.push(comment);\n    debugLog(\"comment-added\", {\n      preview,\n      vposMs: normalizedVposMs,\n      commands: comment.commands.length,\n      layout: comment.layout,\n      isScrolling: comment.isScrolling,\n      invisible: comment.isInvisible,\n    });\n  }\n\n  if (addedComments.length === 0) {\n    return [];\n  }\n\n  this.comments.push(...addedComments);\n  if (this.finalPhaseActive) {\n    this.finalPhaseScheduleDirty = true;\n  }\n  this.comments.sort((a, b) => {\n    const vposMsDiff = a.vposMs - b.vposMs;\n    if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n      return vposMsDiff;\n    }\n    return a.creationIndex - b.creationIndex;\n  });\n\n  return addedComments;\n};\n\nconst addCommentImpl = function (\n  this: CommentRenderer,\n  text: string,\n  vposMs: number,\n  commands: string[] = [],\n): Comment | null {\n  const [comment] = this.addComments([{ text, vposMs, commands }]);\n  return comment ?? null;\n};\n\nconst clearCommentsImpl = function (this: CommentRenderer): void {\n  this.comments.length = 0;\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  this.commentSequence = 0;\n  if (this.ctx && this.canvas) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const width = this.displayWidth > 0 ? this.displayWidth : this.canvas.width / effectiveDpr;\n    const height = this.displayHeight > 0 ? this.displayHeight : this.canvas.height / effectiveDpr;\n    this.ctx.clearRect(0, 0, width, height);\n  }\n};\n\nconst resetStateImpl = function (this: CommentRenderer): void {\n  this.clearComments();\n  this.currentTime = 0;\n  this.resetFinalPhaseState();\n  this.playbackHasBegun = false;\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n};\n\nexport const rebuildNgMatchersImpl = function (this: CommentRenderer): void {\n  const settings = this._settings;\n  const ngWords = Array.isArray(settings.ngWords) ? settings.ngWords : [];\n  this.normalizedNgWords = ngWords.filter((word): word is string => typeof word === \"string\");\n  const sourcePatterns = Array.isArray(settings.ngRegexps) ? settings.ngRegexps : [];\n  this.compiledNgRegexps = sourcePatterns\n    .map((entry): RegExp | null => {\n      if (typeof entry !== \"string\") {\n        return null;\n      }\n      try {\n        return new RegExp(entry, \"i\");\n      } catch (error) {\n        this.log.warn(\"CommentRenderer.invalidNgRegexp\", error as Error, { entry });\n        return null;\n      }\n    })\n    .filter((entry): entry is RegExp => Boolean(entry));\n};\n\nconst isNgCommentImpl = function (this: CommentRenderer, text: string): boolean {\n  if (typeof text !== \"string\" || text.length === 0) {\n    return false;\n  }\n  if (this.normalizedNgWords.some((word) => word.length > 0 && text.includes(word))) {\n    return true;\n  }\n  return this.compiledNgRegexps.some((regexp) => regexp.test(text));\n};\n\nexport const registerCommentCollectionMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.addComments = addCommentsImpl;\n  ctor.prototype.addComment = addCommentImpl;\n  ctor.prototype.clearComments = clearCommentsImpl;\n  ctor.prototype.resetState = resetStateImpl;\n  ctor.prototype.rebuildNgMatchers = rebuildNgMatchersImpl;\n  ctor.prototype.isNGComment = isNgCommentImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  EDGE_EPSILON,\n  FINAL_PHASE_MIN_GAP_MS,\n  FINAL_PHASE_MAX_GAP_MS,\n  FINAL_PHASE_ORDER_EPSILON_MS,\n  FINAL_PHASE_MIN_WINDOW_MS,\n  MAX_VISIBLE_DURATION_MS,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"@/shared/constants\";\nimport { dumpRendererState, logEpochChange } from \"@/shared/debug\";\nimport type { EpochChangeInfo, RendererStateSnapshot } from \"@/shared/types\";\n\nconst hardResetImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  const now = this.timeSource.now();\n  this.lastHardResetAt = now;\n\n  this.incrementEpoch(\"manual-reset\");\n\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n\n  this.comments.forEach((comment) => {\n    comment.isActive = false;\n    comment.hasShown = false;\n    comment.lane = -1;\n    comment.clearActivation();\n    comment.epochId = this.epochId;\n  });\n\n  if (canvas && ctx) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n  }\n\n  this.pendingInitialSync = true;\n  this.resetFinalPhaseState();\n  this.emitStateSnapshot(\"hardReset\");\n};\n\nconst resetFinalPhaseStateImpl = function (this: CommentRenderer): void {\n  this.finalPhaseActive = false;\n  this.finalPhaseStartTime = null;\n  this.finalPhaseScheduleDirty = false;\n  this.finalPhaseVposOverrides.clear();\n};\n\nconst incrementEpochImpl = function (\n  this: CommentRenderer,\n  reason: \"source-change\" | \"metadata-loaded\" | \"manual-reset\",\n): void {\n  const previousEpochId = this.epochId;\n  this.epochId += 1;\n\n  logEpochChange(previousEpochId, this.epochId, reason);\n\n  if (this.eventHooks.onEpochChange) {\n    const info: EpochChangeInfo = {\n      previousEpochId,\n      newEpochId: this.epochId,\n      reason,\n      timestamp: this.timeSource.now(),\n    };\n    try {\n      this.eventHooks.onEpochChange(info);\n    } catch (error) {\n      this.log.error(\"CommentRenderer.incrementEpoch.callback\", error as Error, { info });\n    }\n  }\n\n  this.comments.forEach((comment) => {\n    comment.epochId = this.epochId;\n  });\n};\n\nconst emitStateSnapshotImpl = function (this: CommentRenderer, label: string): void {\n  const now = this.timeSource.now();\n  if (now - this.lastSnapshotEmitTime < this.snapshotEmitThrottleMs) {\n    return;\n  }\n\n  const snapshot: RendererStateSnapshot = {\n    currentTime: this.currentTime,\n    duration: this.duration,\n    isPlaying: this.isPlaying,\n    epochId: this.epochId,\n    totalComments: this.comments.length,\n    activeComments: this.activeComments.size,\n    reservedLanes: this.reservedLanes.size,\n    finalPhaseActive: this.finalPhaseActive,\n    playbackHasBegun: this.playbackHasBegun,\n    isStalled: this.isStalled,\n  };\n\n  dumpRendererState(label, snapshot);\n\n  if (this.eventHooks.onStateSnapshot) {\n    try {\n      this.eventHooks.onStateSnapshot(snapshot);\n    } catch (error) {\n      this.log.error(\"CommentRenderer.emitStateSnapshot.callback\", error as Error);\n    }\n  }\n\n  this.lastSnapshotEmitTime = now;\n};\n\nconst getEffectiveCommentVposImpl = function (this: CommentRenderer, comment: Comment): number {\n  if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n  const override = this.finalPhaseVposOverrides.get(comment);\n  return override ?? comment.vposMs;\n};\n\nconst getFinalPhaseDisplayDurationImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n): number {\n  if (!comment.isScrolling) {\n    return STATIC_VISIBLE_DURATION_MS;\n  }\n\n  const durations: number[] = [];\n  if (Number.isFinite(comment.visibleDurationMs) && comment.visibleDurationMs > 0) {\n    durations.push(comment.visibleDurationMs);\n  }\n  if (Number.isFinite(comment.totalDurationMs) && comment.totalDurationMs > 0) {\n    durations.push(comment.totalDurationMs);\n  }\n\n  if (durations.length > 0) {\n    return Math.max(...durations);\n  }\n\n  return MAX_VISIBLE_DURATION_MS;\n};\n\nconst resolveFinalPhaseVposImpl = function (this: CommentRenderer, comment: Comment): number {\n  if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n    this.finalPhaseVposOverrides.delete(comment);\n    return comment.vposMs;\n  }\n  if (this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n  const override = this.finalPhaseVposOverrides.get(comment);\n  if (override !== undefined) {\n    return override;\n  }\n  const fallback = Math.max(comment.vposMs, this.finalPhaseStartTime);\n  this.finalPhaseVposOverrides.set(comment, fallback);\n  return fallback;\n};\n\nconst recomputeFinalPhaseTimelineImpl = function (this: CommentRenderer): void {\n  if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n    this.finalPhaseVposOverrides.clear();\n    this.finalPhaseScheduleDirty = false;\n    return;\n  }\n\n  const windowStart = this.finalPhaseStartTime;\n  const durationMs = this.duration > 0 ? this.duration : windowStart + FINAL_PHASE_MIN_WINDOW_MS;\n  const windowEnd = Math.max(windowStart + FINAL_PHASE_MIN_WINDOW_MS, durationMs);\n\n  const candidates = this.comments\n    .filter((comment) => {\n      if (comment.hasShown) {\n        return false;\n      }\n      if (comment.isInvisible) {\n        return false;\n      }\n      if (this.isNGComment(comment.text)) {\n        return false;\n      }\n      return comment.vposMs >= windowStart - ACTIVE_WINDOW_MS;\n    })\n    .sort((a, b) => {\n      const diff = a.vposMs - b.vposMs;\n      if (Math.abs(diff) > EDGE_EPSILON) {\n        return diff;\n      }\n      return a.creationIndex - b.creationIndex;\n    });\n\n  this.finalPhaseVposOverrides.clear();\n\n  if (candidates.length === 0) {\n    this.finalPhaseScheduleDirty = false;\n    return;\n  }\n\n  const windowSpan = Math.max(windowEnd - windowStart, FINAL_PHASE_MIN_WINDOW_MS);\n  const baseGap = windowSpan / Math.max(candidates.length, 1);\n  const boundedGap = Number.isFinite(baseGap) ? baseGap : FINAL_PHASE_MIN_GAP_MS;\n  const gap = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(boundedGap, FINAL_PHASE_MAX_GAP_MS));\n\n  let nextStart = windowStart;\n  candidates.forEach((comment, index) => {\n    const durationNeeded = Math.max(1, this.getFinalPhaseDisplayDuration(comment));\n    const availableLatestStart = windowEnd - durationNeeded;\n    let assigned = Math.max(windowStart, Math.min(nextStart, availableLatestStart));\n    if (!Number.isFinite(assigned)) {\n      assigned = windowStart;\n    }\n    const epsilon = FINAL_PHASE_ORDER_EPSILON_MS * index;\n    if (assigned + epsilon <= availableLatestStart) {\n      assigned += epsilon;\n    }\n    this.finalPhaseVposOverrides.set(comment, assigned);\n    const spacing = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(durationNeeded / 2, gap));\n    nextStart = assigned + spacing;\n  });\n\n  this.finalPhaseScheduleDirty = false;\n};\n\nexport const registerFinalPhaseMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.hardReset = hardResetImpl;\n  ctor.prototype.resetFinalPhaseState = resetFinalPhaseStateImpl;\n  ctor.prototype.incrementEpoch = incrementEpochImpl;\n  ctor.prototype.emitStateSnapshot = emitStateSnapshotImpl;\n  ctor.prototype.getEffectiveCommentVpos = getEffectiveCommentVposImpl;\n  ctor.prototype.getFinalPhaseDisplayDuration = getFinalPhaseDisplayDurationImpl;\n  ctor.prototype.resolveFinalPhaseVpos = resolveFinalPhaseVposImpl;\n  ctor.prototype.recomputeFinalPhaseTimeline = recomputeFinalPhaseTimelineImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { SEEK_DIRECTION_EPSILON_MS } from \"@/shared/constants\";\n\nconst shouldSuppressRenderingImpl = function (this: CommentRenderer): boolean {\n  return !this.playbackHasBegun && !this.isPlaying && this.currentTime <= SEEK_DIRECTION_EPSILON_MS;\n};\n\nconst updatePlaybackProgressStateImpl = function (this: CommentRenderer): void {\n  if (this.playbackHasBegun) {\n    return;\n  }\n  if (this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS) {\n    this.playbackHasBegun = true;\n  }\n};\n\nexport const registerPlaybackHelpers = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.shouldSuppressRendering = shouldSuppressRenderingImpl;\n  ctor.prototype.updatePlaybackProgressState = updatePlaybackProgressStateImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { CommentPrepareOptions } from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  BASE_COLLISION_BUFFER_PX,\n  COLLISION_BUFFER_RATIO,\n  ENTRY_BUFFER_PX,\n  FINAL_PHASE_THRESHOLD_MS,\n  MAX_COMMENT_WIDTH_RATIO,\n  MAX_VISIBLE_DURATION_MS,\n  MIN_VISIBLE_DURATION_MS,\n  SEEK_DIRECTION_EPSILON_MS,\n  VIRTUAL_CANVAS_EXTENSION_PX,\n  toMilliseconds,\n} from \"@/shared/constants\";\nimport { formatCommentPreview, debugLog, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst updateCommentsImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas || !context) {\n    return;\n  }\n\n  const referenceTime =\n    typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n  this.currentTime = referenceTime;\n  this.playbackRate = video.playbackRate;\n  this.isPlaying = !video.paused;\n  this.updatePlaybackProgressState();\n  this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n  if (this.skipDrawingForCurrentFrame) {\n    return;\n  }\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const isNearEnd =\n    this.duration > 0 && this.duration - this.currentTime <= FINAL_PHASE_THRESHOLD_MS;\n\n  if (isNearEnd && !this.finalPhaseActive) {\n    this.finalPhaseActive = true;\n    this.finalPhaseStartTime = this.currentTime;\n    this.finalPhaseVposOverrides.clear();\n    this.finalPhaseScheduleDirty = true;\n    context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    this.comments.forEach((comment) => {\n      comment.isActive = false;\n      comment.clearActivation();\n    });\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n  }\n\n  if (!isNearEnd && this.finalPhaseActive) {\n    this.resetFinalPhaseState();\n  }\n\n  if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n\n  this.pruneStaticLaneReservations(this.currentTime);\n\n  // ==== activeComments の定期クリーンアップ（古いコメント回収） ====\n  // 時間窓外のコメント、または画面外に完全に流れたコメントを削除\n  for (const comment of Array.from(this.activeComments)) {\n    const effectiveVpos = this.getEffectiveCommentVpos(comment);\n    const isPastWindow = effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS;\n    const isFutureWindow = effectiveVpos > this.currentTime + ACTIVE_WINDOW_MS;\n\n    // 時間窓外のコメントを削除\n    if (isPastWindow || isFutureWindow) {\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.clearActivation();\n      if (comment.lane >= 0) {\n        if (comment.layout === \"ue\") {\n          this.releaseStaticLane(\"ue\", comment.lane);\n        } else if (comment.layout === \"shita\") {\n          this.releaseStaticLane(\"shita\", comment.lane);\n        }\n      }\n      continue;\n    }\n\n    // スクロール完了したコメントを削除（再生中でなくても実行）\n    if (comment.isScrolling && comment.hasShown) {\n      const isOffScreen =\n        (comment.scrollDirection === \"rtl\" && comment.x <= comment.exitThreshold) ||\n        (comment.scrollDirection === \"ltr\" && comment.x >= comment.exitThreshold);\n\n      if (isOffScreen) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n  }\n\n  const activeWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  for (const comment of activeWindowComments) {\n    const debugActive = isDebugLoggingEnabled();\n    const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n    if (debugActive) {\n      debugLog(\"comment-evaluate\", {\n        stage: \"update\",\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: this.getEffectiveCommentVpos(comment),\n        currentTime: this.currentTime,\n        isActive: comment.isActive,\n        hasShown: comment.hasShown,\n      });\n    }\n\n    if (this.isNGComment(comment.text)) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"ng-runtime\",\n        });\n      }\n      continue;\n    }\n    if (comment.isInvisible) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"invisible\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.hasShown = true;\n      comment.clearActivation();\n      continue;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n    }\n\n    if (comment.isActive) {\n      if (comment.layout !== \"naka\" && comment.hasStaticExpired(this.currentTime)) {\n        const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n        this.releaseStaticLane(staticPosition, comment.lane);\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n        continue;\n      }\n\n      if (\n        comment.layout === \"naka\" &&\n        this.getEffectiveCommentVpos(comment) > this.currentTime + SEEK_DIRECTION_EPSILON_MS\n      ) {\n        comment.x = comment.virtualStartX;\n        comment.lastUpdateTime = this.timeSource.now();\n        continue;\n      }\n\n      comment.hasShown = true;\n      comment.update(this.playbackRate, !this.isPlaying);\n      if (!comment.isScrolling && comment.hasStaticExpired(this.currentTime)) {\n        const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n        this.releaseStaticLane(staticPosition, comment.lane);\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n  }\n};\n\nconst buildPrepareOptionsImpl = function (\n  this: CommentRenderer,\n  visibleWidth: number,\n): CommentPrepareOptions {\n  const overrideDuration = this._settings.scrollVisibleDurationMs;\n  let maxVisibleDurationMs = MAX_VISIBLE_DURATION_MS;\n  let minVisibleDurationMs = MIN_VISIBLE_DURATION_MS;\n\n  if (overrideDuration !== null) {\n    maxVisibleDurationMs = overrideDuration;\n    minVisibleDurationMs = Math.max(1, Math.min(overrideDuration, MIN_VISIBLE_DURATION_MS));\n  }\n\n  return {\n    visibleWidth,\n    virtualExtension: VIRTUAL_CANVAS_EXTENSION_PX,\n    maxVisibleDurationMs,\n    minVisibleDurationMs,\n    maxWidthRatio: MAX_COMMENT_WIDTH_RATIO,\n    bufferRatio: COLLISION_BUFFER_RATIO,\n    baseBufferPx: BASE_COLLISION_BUFFER_PX,\n    entryBufferPx: ENTRY_BUFFER_PX,\n  };\n};\n\nconst findAvailableLaneImpl = function (this: CommentRenderer, comment: Comment): number {\n  const currentTime = this.currentTime;\n  this.pruneLaneReservations(currentTime);\n  this.pruneStaticLaneReservations(currentTime);\n  const laneCandidates = this.getLanePriorityOrder(currentTime);\n  const newReservation = this.createLaneReservation(comment, currentTime);\n\n  for (const lane of laneCandidates) {\n    if (this.isLaneAvailable(lane, newReservation, currentTime)) {\n      this.storeLaneReservation(lane, newReservation);\n      return lane;\n    }\n  }\n\n  const fallbackLane = laneCandidates[0] ?? 0;\n  this.storeLaneReservation(fallbackLane, newReservation);\n  return fallbackLane;\n};\n\nexport const registerActivationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.updateComments = updateCommentsImpl;\n  ctor.prototype.buildPrepareOptions = buildPrepareOptionsImpl;\n  ctor.prototype.findAvailableLane = findAvailableLaneImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { LaneReservation, StaticLaneReservation } from \"@/shared/types\";\nimport { RESERVATION_TIME_MARGIN_MS } from \"@/shared/constants\";\n\nconst findFirstValidReservationIndexImpl = function (\n  this: CommentRenderer,\n  reservations: LaneReservation[],\n  cutoffTime: number,\n): number {\n  let left = 0;\n  let right = reservations.length;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const reservation = reservations[mid];\n    if (\n      reservation !== undefined &&\n      reservation.totalEndTime + RESERVATION_TIME_MARGIN_MS <= cutoffTime\n    ) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return left;\n};\n\nconst pruneLaneReservationsImpl = function (this: CommentRenderer, currentTime: number): void {\n  for (const [lane, reservations] of this.reservedLanes.entries()) {\n    const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n    if (firstValidIndex >= reservations.length) {\n      this.reservedLanes.delete(lane);\n    } else if (firstValidIndex > 0) {\n      this.reservedLanes.set(lane, reservations.slice(firstValidIndex));\n    }\n  }\n};\n\nconst pruneStaticLaneReservationsImpl = function (\n  this: CommentRenderer,\n  currentTime: number,\n): void {\n  const filterValid = (reservations: StaticLaneReservation[]): StaticLaneReservation[] =>\n    reservations.filter((reservation) => reservation.releaseTime > currentTime);\n\n  const topFiltered = filterValid(this.topStaticLaneReservations);\n  const bottomFiltered = filterValid(this.bottomStaticLaneReservations);\n\n  this.topStaticLaneReservations.length = 0;\n  this.topStaticLaneReservations.push(...topFiltered);\n\n  this.bottomStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.push(...bottomFiltered);\n};\n\nexport const registerLanePruneMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.findFirstValidReservationIndex = findFirstValidReservationIndexImpl;\n  ctor.prototype.pruneLaneReservations = pruneLaneReservationsImpl;\n  ctor.prototype.pruneStaticLaneReservations = pruneStaticLaneReservationsImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { Comment } from \"@/comment/comment\";\n\nconst findCommentIndexAtOrAfterImpl = function (\n  this: CommentRenderer,\n  targetVposMs: number,\n): number {\n  let left = 0;\n  let right = this.comments.length;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const comment = this.comments[mid];\n    if (comment !== undefined && comment.vposMs < targetVposMs) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return left;\n};\n\nconst getCommentsInTimeWindowImpl = function (\n  this: CommentRenderer,\n  centerTimeMs: number,\n  windowMs: number,\n): Comment[] {\n  if (this.comments.length === 0) {\n    return [];\n  }\n  const startTime = centerTimeMs - windowMs;\n  const endTime = centerTimeMs + windowMs;\n  const startIndex = this.findCommentIndexAtOrAfter(startTime);\n  const result: Comment[] = [];\n  for (let i = startIndex; i < this.comments.length; i++) {\n    const comment = this.comments[i];\n    if (!comment) {\n      continue;\n    }\n    if (comment.vposMs > endTime) {\n      break;\n    }\n    result.push(comment);\n  }\n  return result;\n};\n\nconst getStaticReservationsImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n): CommentRenderer[\"topStaticLaneReservations\"] {\n  return position === \"ue\" ? this.topStaticLaneReservations : this.bottomStaticLaneReservations;\n};\n\nconst getStaticLaneDepthImpl = function (this: CommentRenderer, position: \"ue\" | \"shita\"): number {\n  return position === \"ue\"\n    ? this.topStaticLaneReservations.length\n    : this.bottomStaticLaneReservations.length;\n};\n\nconst getStaticLaneLimitImpl = function (this: CommentRenderer, position: \"ue\" | \"shita\"): number {\n  const otherPosition = position === \"ue\" ? \"shita\" : \"ue\";\n  const otherDepth = this.getStaticLaneDepth(otherPosition);\n  const available = this.laneCount - otherDepth;\n  if (available <= 0) {\n    return -1;\n  }\n  return available - 1;\n};\n\nconst getGlobalLaneIndexForBottomImpl = function (\n  this: CommentRenderer,\n  localIndex: number,\n): number {\n  return Math.max(0, this.laneCount - 1 - localIndex);\n};\n\nconst resolveStaticCommentOffsetImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  lane: number,\n  displayHeight: number,\n  comment: Comment,\n): number {\n  const effectiveHeight = Math.max(1, displayHeight);\n  const commentHeight = Math.max(comment.height, comment.fontSize);\n  const edgePadding = 5;\n  const stackPadding = 2;\n\n  if (position === \"ue\") {\n    let cumulativeY = edgePadding;\n    const reservations = this.getStaticReservations(position);\n    const laneSortedReservations = reservations\n      .filter((r) => r.lane < lane)\n      .sort((a, b) => a.lane - b.lane);\n\n    for (const reservation of laneSortedReservations) {\n      const reservedHeight = reservation.yEnd - reservation.yStart;\n      cumulativeY += reservedHeight + stackPadding;\n    }\n\n    const maxY = Math.max(edgePadding, effectiveHeight - commentHeight - edgePadding);\n    return Math.max(edgePadding, Math.min(cumulativeY, maxY));\n  }\n\n  let cumulativeY = effectiveHeight - edgePadding;\n  const reservations = this.getStaticReservations(position);\n  const laneSortedReservations = reservations\n    .filter((r) => r.lane < lane)\n    .sort((a, b) => a.lane - b.lane);\n\n  for (const reservation of laneSortedReservations) {\n    const reservedHeight = reservation.yEnd - reservation.yStart;\n    cumulativeY -= reservedHeight + stackPadding;\n  }\n\n  const adjustedY = cumulativeY - commentHeight;\n  return Math.max(edgePadding, adjustedY);\n};\n\nconst getStaticReservedLaneSetImpl = function (this: CommentRenderer): Set<number> {\n  const reserved = new Set<number>();\n  for (const reservation of this.topStaticLaneReservations) {\n    reserved.add(reservation.lane);\n  }\n  for (const reservation of this.bottomStaticLaneReservations) {\n    reserved.add(this.getGlobalLaneIndexForBottom(reservation.lane));\n  }\n  return reserved;\n};\n\nexport const registerLaneStaticMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.findCommentIndexAtOrAfter = findCommentIndexAtOrAfterImpl;\n  ctor.prototype.getCommentsInTimeWindow = getCommentsInTimeWindowImpl;\n  ctor.prototype.getStaticReservations = getStaticReservationsImpl;\n  ctor.prototype.getStaticLaneDepth = getStaticLaneDepthImpl;\n  ctor.prototype.getStaticLaneLimit = getStaticLaneLimitImpl;\n  ctor.prototype.getGlobalLaneIndexForBottom = getGlobalLaneIndexForBottomImpl;\n  ctor.prototype.resolveStaticCommentOffset = resolveStaticCommentOffsetImpl;\n  ctor.prototype.getStaticReservedLaneSet = getStaticReservedLaneSetImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { CommentPrepareOptions } from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  EDGE_EPSILON,\n  FINAL_PHASE_MIN_WINDOW_MS,\n  SEEK_DIRECTION_EPSILON_MS,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"@/shared/constants\";\nimport { calculateStaticCommentVerticalPadding } from \"@/shared/settings\";\nimport { debugLog, formatCommentPreview, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst shouldActivateCommentAtTimeImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n  timeMs: number,\n  preview: string = \"\",\n): boolean {\n  const debugActive = preview.length > 0 && isDebugLoggingEnabled();\n  const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n  if (\n    this.finalPhaseActive &&\n    this.finalPhaseStartTime !== null &&\n    comment.vposMs < this.finalPhaseStartTime - EDGE_EPSILON\n  ) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"final-phase-trimmed\",\n        finalPhaseStartTime: this.finalPhaseStartTime,\n      });\n    }\n    this.finalPhaseVposOverrides.delete(comment);\n    return false;\n  }\n\n  if (comment.isInvisible) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"invisible\",\n      });\n    }\n    return false;\n  }\n  if (comment.isActive) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"already-active\",\n      });\n    }\n    return false;\n  }\n  if (comment.hasShown && effectiveVpos <= timeMs) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"already-shown\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n  if (effectiveVpos > timeMs + SEEK_DIRECTION_EPSILON_MS) {\n    if (debugActive) {\n      debugLog(\"comment-eval-pending\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"future\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n  if (effectiveVpos < timeMs - ACTIVE_WINDOW_MS) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"expired-window\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n\n  if (debugActive) {\n    debugLog(\"comment-eval-ready\", {\n      preview,\n      vposMs: comment.vposMs,\n      effectiveVposMs: effectiveVpos,\n      currentTime: timeMs,\n    });\n  }\n  return true;\n};\n\nconst activateCommentImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n  context: CanvasRenderingContext2D,\n  displayWidth: number,\n  displayHeight: number,\n  options: CommentPrepareOptions,\n  referenceTime: number,\n): void {\n  comment.prepare(context, displayWidth, displayHeight, options);\n  const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n  if (isDebugLoggingEnabled()) {\n    debugLog(\"comment-prepared\", {\n      preview: formatCommentPreview(comment.text),\n      layout: comment.layout,\n      isScrolling: comment.isScrolling,\n      width: comment.width,\n      height: comment.height,\n      bufferWidth: comment.bufferWidth,\n      visibleDurationMs: comment.visibleDurationMs,\n      effectiveVposMs: effectiveVpos,\n    });\n  }\n\n  if (comment.layout === \"naka\") {\n    const elapsedMs = Math.max(0, referenceTime - effectiveVpos);\n    const displacement = comment.speedPixelsPerMs * elapsedMs;\n\n    if (this.finalPhaseActive && this.finalPhaseStartTime !== null) {\n      const videoDuration =\n        this.duration > 0 ? this.duration : this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS;\n      const finalPhaseWindowEnd = Math.max(\n        this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS,\n        videoDuration,\n      );\n      const totalTravelDistance = comment.width + displayWidth;\n      const projectedTravelMs =\n        totalTravelDistance > 0 ? totalTravelDistance / Math.max(comment.speedPixelsPerMs, 1) : 0;\n      const projectedEndTime = effectiveVpos + projectedTravelMs;\n      if (projectedEndTime > finalPhaseWindowEnd) {\n        const remainingTime = finalPhaseWindowEnd - referenceTime;\n        const allowedTravel = Math.max(0, remainingTime) * comment.speedPixelsPerMs;\n        const startX =\n          comment.scrollDirection === \"rtl\"\n            ? Math.max(comment.virtualStartX - displacement, displayWidth - allowedTravel)\n            : Math.min(comment.virtualStartX + displacement, allowedTravel - comment.width);\n        comment.x = startX;\n      } else {\n        comment.x =\n          comment.scrollDirection === \"rtl\"\n            ? comment.virtualStartX - displacement\n            : comment.virtualStartX + displacement;\n      }\n    } else {\n      comment.x =\n        comment.scrollDirection === \"rtl\"\n          ? comment.virtualStartX - displacement\n          : comment.virtualStartX + displacement;\n    }\n    const laneIndex = this.findAvailableLane(comment);\n    comment.lane = laneIndex;\n    const laneHeight = Math.max(1, this.laneHeight);\n    const maxY = Math.max(0, displayHeight - comment.height);\n    const laneY = laneIndex * laneHeight;\n    comment.y = Math.max(0, Math.min(laneY, maxY));\n  } else {\n    const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n    const laneIndex = this.assignStaticLane(staticPosition, comment, displayHeight, referenceTime);\n    const verticalOffset = this.resolveStaticCommentOffset(\n      staticPosition,\n      laneIndex,\n      displayHeight,\n      comment,\n    );\n    comment.x = Math.max(0, Math.min(displayWidth - comment.width, comment.virtualStartX));\n    comment.y = verticalOffset;\n    comment.lane =\n      staticPosition === \"ue\" ? laneIndex : this.getGlobalLaneIndexForBottom(laneIndex);\n    comment.speed = 0;\n    comment.baseSpeed = 0;\n    comment.speedPixelsPerMs = 0;\n    comment.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n    const displayEnd = referenceTime + comment.visibleDurationMs;\n    this.activeComments.add(comment);\n    comment.isActive = true;\n    comment.hasShown = true;\n    comment.isPaused = !this.isPlaying;\n    comment.markActivated(referenceTime);\n    comment.lastUpdateTime = this.timeSource.now();\n    comment.staticExpiryTimeMs = displayEnd;\n    this.reserveStaticLane(staticPosition, comment, laneIndex, displayEnd);\n    if (isDebugLoggingEnabled()) {\n      debugLog(\"comment-activate-static\", {\n        preview: formatCommentPreview(comment.text),\n        lane: comment.lane,\n        position: staticPosition,\n        displayEnd,\n        effectiveVposMs: effectiveVpos,\n      });\n    }\n    return;\n  }\n\n  this.activeComments.add(comment);\n  comment.isActive = true;\n  comment.hasShown = true;\n  comment.isPaused = !this.isPlaying;\n  comment.markActivated(referenceTime);\n  comment.lastUpdateTime = this.timeSource.now();\n};\n\nconst assignStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  comment: Comment,\n  displayHeight: number,\n  currentTime: number,\n): number {\n  const reservations = this.getStaticReservations(position);\n  const limit = this.getStaticLaneLimit(position);\n  const laneCount = limit >= 0 ? limit + 1 : 0;\n  const laneIndices = Array.from({ length: laneCount }, (_, index) => index);\n\n  for (const lane of laneIndices) {\n    const yOffset = this.resolveStaticCommentOffset(position, lane, displayHeight, comment);\n    const commentHeight = Math.max(comment.height, comment.fontSize);\n    const padding = calculateStaticCommentVerticalPadding(comment.fontSize, lane);\n    const yStart = yOffset - padding;\n    const yEnd = yOffset + commentHeight + padding;\n\n    const hasConflict = reservations.some((reservation) => {\n      const timeOverlap = reservation.releaseTime > currentTime;\n      if (!timeOverlap) {\n        return false;\n      }\n      const yOverlap = !(yEnd <= reservation.yStart || yStart >= reservation.yEnd);\n      return yOverlap;\n    });\n\n    if (!hasConflict) {\n      return lane;\n    }\n  }\n\n  let fallbackLane = laneIndices[0] ?? 0;\n  let earliestRelease = Number.POSITIVE_INFINITY;\n  for (const reservation of reservations) {\n    if (reservation.releaseTime < earliestRelease) {\n      earliestRelease = reservation.releaseTime;\n      fallbackLane = reservation.lane;\n    }\n  }\n  return fallbackLane;\n};\n\nconst reserveStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  comment: Comment,\n  lane: number,\n  releaseTime: number,\n): void {\n  const reservations = this.getStaticReservations(position);\n  const commentHeight = Math.max(comment.height, comment.fontSize);\n  const padding = calculateStaticCommentVerticalPadding(comment.fontSize, lane);\n  const yStart = comment.y - padding;\n  const yEnd = comment.y + commentHeight + padding;\n\n  reservations.push({\n    comment,\n    releaseTime,\n    yStart,\n    yEnd,\n    lane,\n  });\n};\n\nconst releaseStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  lane: number,\n): void {\n  if (lane < 0) {\n    return;\n  }\n  const reservations = this.getStaticReservations(position);\n  const index = reservations.findIndex((r) => r.lane === lane);\n  if (index >= 0) {\n    reservations.splice(index, 1);\n  }\n};\n\nexport const registerLaneActivationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.shouldActivateCommentAtTime = shouldActivateCommentAtTimeImpl;\n  ctor.prototype.activateComment = activateCommentImpl;\n  ctor.prototype.assignStaticLane = assignStaticLaneImpl;\n  ctor.prototype.reserveStaticLane = reserveStaticLaneImpl;\n  ctor.prototype.releaseStaticLane = releaseStaticLaneImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { LaneReservation } from \"@/shared/types\";\nimport { EDGE_EPSILON, RESERVATION_TIME_MARGIN_MS } from \"@/shared/constants\";\n\nconst getLanePriorityOrderImpl = function (this: CommentRenderer, currentTime: number): number[] {\n  const indices = Array.from({ length: this.laneCount }, (_, index) => index);\n  const sorted = indices.sort((a, b) => {\n    const nextA = this.getLaneNextAvailableTime(a, currentTime);\n    const nextB = this.getLaneNextAvailableTime(b, currentTime);\n    if (Math.abs(nextA - nextB) <= EDGE_EPSILON) {\n      return a - b;\n    }\n    return nextA - nextB;\n  });\n  const staticReserved = this.getStaticReservedLaneSet();\n  if (staticReserved.size === 0) {\n    return sorted;\n  }\n  const preferred = sorted.filter((lane) => !staticReserved.has(lane));\n  if (preferred.length === 0) {\n    return sorted;\n  }\n  const blocked = sorted.filter((lane) => staticReserved.has(lane));\n  return [...preferred, ...blocked];\n};\n\nconst getLaneNextAvailableTimeImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  currentTime: number,\n): number {\n  const reservations = this.reservedLanes.get(lane);\n  if (!reservations || reservations.length === 0) {\n    return currentTime;\n  }\n  const validIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n  const candidate = reservations[validIndex];\n  if (!candidate) {\n    return currentTime;\n  }\n  return Math.max(currentTime, candidate.endTime + RESERVATION_TIME_MARGIN_MS);\n};\n\nconst createLaneReservationImpl = function (\n  this: CommentRenderer,\n  comment: CommentRenderer[\"comments\"][number],\n  referenceTime: number,\n): LaneReservation {\n  const speed = Math.max(comment.speedPixelsPerMs, EDGE_EPSILON);\n  const effectiveStart = this.getEffectiveCommentVpos(comment);\n  const baseStartTime = Number.isFinite(effectiveStart) ? effectiveStart : referenceTime;\n  const startTime = Math.max(0, baseStartTime);\n  const endTime = startTime + comment.preCollisionDurationMs + RESERVATION_TIME_MARGIN_MS;\n  const totalEndTime = startTime + comment.totalDurationMs + RESERVATION_TIME_MARGIN_MS;\n  return {\n    comment,\n    startTime,\n    endTime: Math.max(startTime, endTime),\n    totalEndTime: Math.max(startTime, totalEndTime),\n    startLeft: comment.virtualStartX,\n    width: comment.width,\n    speed,\n    buffer: comment.bufferWidth,\n    directionSign: comment.getDirectionSign(),\n  };\n};\n\nconst isLaneAvailableImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  candidate: LaneReservation,\n  currentTime: number,\n): boolean {\n  const reservations = this.reservedLanes.get(lane);\n  if (!reservations || reservations.length === 0) {\n    return true;\n  }\n  const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n  for (let i = firstValidIndex; i < reservations.length; i += 1) {\n    const reservation = reservations[i];\n    if (!reservation) {\n      continue;\n    }\n    if (this.areReservationsConflicting(reservation, candidate)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst storeLaneReservationImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  reservation: LaneReservation,\n): void {\n  const existing = this.reservedLanes.get(lane) ?? [];\n  const updated = [...existing, reservation].sort((a, b) => a.totalEndTime - b.totalEndTime);\n  this.reservedLanes.set(lane, updated);\n};\n\nconst areReservationsConflictingImpl = function (\n  this: CommentRenderer,\n  a: LaneReservation,\n  b: LaneReservation,\n): boolean {\n  const overlapStart = Math.max(a.startTime, b.startTime);\n  const overlapEnd = Math.min(a.endTime, b.endTime);\n  if (overlapStart >= overlapEnd) {\n    return false;\n  }\n\n  const evaluationTimes = new Set<number>([\n    overlapStart,\n    overlapEnd,\n    overlapStart + (overlapEnd - overlapStart) / 2,\n  ]);\n\n  const forwardIntersection = this.solveLeftRightEqualityTime(a, b);\n  if (\n    forwardIntersection !== null &&\n    forwardIntersection >= overlapStart - EDGE_EPSILON &&\n    forwardIntersection <= overlapEnd + EDGE_EPSILON\n  ) {\n    evaluationTimes.add(forwardIntersection);\n  }\n\n  const backwardIntersection = this.solveLeftRightEqualityTime(b, a);\n  if (\n    backwardIntersection !== null &&\n    backwardIntersection >= overlapStart - EDGE_EPSILON &&\n    backwardIntersection <= overlapEnd + EDGE_EPSILON\n  ) {\n    evaluationTimes.add(backwardIntersection);\n  }\n\n  for (const time of evaluationTimes) {\n    if (time < overlapStart - EDGE_EPSILON || time > overlapEnd + EDGE_EPSILON) {\n      continue;\n    }\n    const forwardGap = this.computeForwardGap(a, b, time);\n    const backwardGap = this.computeForwardGap(b, a, time);\n    if (forwardGap <= EDGE_EPSILON && backwardGap <= EDGE_EPSILON) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst computeForwardGapImpl = function (\n  this: CommentRenderer,\n  from: LaneReservation,\n  to: LaneReservation,\n  time: number,\n): number {\n  const fromEdges = this.getBufferedEdges(from, time);\n  const toEdges = this.getBufferedEdges(to, time);\n  return fromEdges.left - toEdges.right;\n};\n\nconst getBufferedEdgesImpl = function (\n  this: CommentRenderer,\n  reservation: LaneReservation,\n  time: number,\n): { left: number; right: number } {\n  const elapsed = Math.max(0, time - reservation.startTime);\n  const displacement = reservation.speed * elapsed;\n  const rawLeft = reservation.startLeft + reservation.directionSign * displacement;\n  const left = rawLeft - reservation.buffer;\n  const right = rawLeft + reservation.width + reservation.buffer;\n  return { left, right };\n};\n\nconst solveLeftRightEqualityTimeImpl = function (\n  this: CommentRenderer,\n  left: LaneReservation,\n  right: LaneReservation,\n): number | null {\n  const leftSign = left.directionSign;\n  const rightSign = right.directionSign;\n  const denominator = rightSign * right.speed - leftSign * left.speed;\n  if (Math.abs(denominator) < EDGE_EPSILON) {\n    return null;\n  }\n  const numerator =\n    right.startLeft +\n    rightSign * right.speed * right.startTime +\n    right.width +\n    right.buffer -\n    left.startLeft -\n    leftSign * left.speed * left.startTime +\n    left.buffer;\n  const time = numerator / denominator;\n  if (!Number.isFinite(time)) {\n    return null;\n  }\n  return time;\n};\n\nexport const registerLaneReservationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.getLanePriorityOrder = getLanePriorityOrderImpl;\n  ctor.prototype.getLaneNextAvailableTime = getLaneNextAvailableTimeImpl;\n  ctor.prototype.createLaneReservation = createLaneReservationImpl;\n  ctor.prototype.isLaneAvailable = isLaneAvailableImpl;\n  ctor.prototype.storeLaneReservation = storeLaneReservationImpl;\n  ctor.prototype.areReservationsConflicting = areReservationsConflictingImpl;\n  ctor.prototype.computeForwardGap = computeForwardGapImpl;\n  ctor.prototype.getBufferedEdges = getBufferedEdgesImpl;\n  ctor.prototype.solveLeftRightEqualityTime = solveLeftRightEqualityTimeImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { ACTIVE_WINDOW_MS, EDGE_EPSILON, toMilliseconds } from \"@/shared/constants\";\n\nconst drawImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!canvas || !context) {\n    return;\n  }\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n\n  const now = this.timeSource.now();\n\n  if (this.skipDrawingForCurrentFrame || this.shouldSuppressRendering() || this.isStalled) {\n    context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    this.lastDrawTime = now;\n    return;\n  }\n\n  context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n  const activeComments = Array.from(this.activeComments);\n\n  if (this._settings.isCommentVisible) {\n    const deltaTime = (now - this.lastDrawTime) / (1000 / 60);\n    activeComments.sort((a, b) => {\n      const aVpos = this.getEffectiveCommentVpos(a);\n      const bVpos = this.getEffectiveCommentVpos(b);\n      const vposMsDiff = aVpos - bVpos;\n      if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n        return vposMsDiff;\n      }\n      if (a.isScrolling !== b.isScrolling) {\n        return a.isScrolling ? 1 : -1;\n      }\n      return a.creationIndex - b.creationIndex;\n    });\n    activeComments.forEach((comment) => {\n      const shouldInterpolate = this.isPlaying && !comment.isPaused;\n      const interpolatedX = shouldInterpolate\n        ? comment.x + comment.getDirectionSign() * comment.speed * deltaTime\n        : comment.x;\n      comment.draw(context, interpolatedX);\n    });\n  }\n\n  this.lastDrawTime = now;\n};\n\nconst performInitialSyncImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas || !context) {\n    return;\n  }\n\n  const absoluteTime =\n    typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n  this.currentTime = absoluteTime;\n  this.lastDrawTime = this.timeSource.now();\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const windowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  windowComments.forEach((comment) => {\n    if (this.isNGComment(comment.text) || comment.isInvisible) {\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.clearActivation();\n      return;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n    comment.isActive = false;\n    this.activeComments.delete(comment);\n    comment.lane = -1;\n    comment.clearActivation();\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n      return;\n    }\n\n    const effectiveVpos = this.getEffectiveCommentVpos(comment);\n    if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n      comment.hasShown = true;\n    } else {\n      comment.hasShown = false;\n    }\n  });\n};\n\nexport const registerRenderMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.draw = drawImpl;\n  ctor.prototype.performInitialSync = performInitialSyncImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { ACTIVE_WINDOW_MS, SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\nimport type {\n  RequestVideoFrameCallback,\n  CancelVideoFrameCallback,\n  VideoFrameCallbackMetadataLike,\n} from \"@/shared/types\";\nimport { formatCommentPreview, debugLog, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst processFrameImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  if (!this.videoElement) {\n    return;\n  }\n  if (!this._settings.isCommentVisible) {\n    return;\n  }\n\n  if (this.pendingInitialSync) {\n    this.performInitialSync(frameTimeMs);\n    this.pendingInitialSync = false;\n  }\n\n  this.updateComments(frameTimeMs);\n  this.draw();\n};\n\nconst handleAnimationFrameImpl = function (this: CommentRenderer): void {\n  const pendingId = this.frameId;\n  this.frameId = null;\n  if (pendingId !== null) {\n    this.animationFrameProvider.cancel(pendingId);\n  }\n  this.processFrame();\n  this.scheduleNextFrame();\n};\n\nconst handleVideoFrameImpl = function (\n  this: CommentRenderer,\n  _now: DOMHighResTimeStamp,\n  metadata: VideoFrameCallbackMetadataLike,\n): void {\n  this.videoFrameHandle = null;\n  const mediaTime = typeof metadata?.mediaTime === \"number\" ? metadata.mediaTime * 1000 : undefined;\n  this.processFrame(typeof mediaTime === \"number\" ? mediaTime : undefined);\n  this.scheduleNextFrame();\n};\n\nconst shouldUseVideoFrameCallbackImpl = function (this: CommentRenderer): boolean {\n  if (this._settings.syncMode !== \"video-frame\") {\n    return false;\n  }\n  const video = this.videoElement as HTMLVideoElement & {\n    requestVideoFrameCallback?: RequestVideoFrameCallback;\n    cancelVideoFrameCallback?: CancelVideoFrameCallback;\n  };\n  return (\n    Boolean(video) &&\n    typeof video.requestVideoFrameCallback === \"function\" &&\n    typeof video.cancelVideoFrameCallback === \"function\"\n  );\n};\n\nconst scheduleNextFrameImpl = function (this: CommentRenderer): void {\n  const video = this.videoElement;\n  if (!video) {\n    return;\n  }\n  if (this.shouldUseVideoFrameCallback()) {\n    this.cancelAnimationFrameRequest();\n    this.cancelVideoFrameCallback();\n    const request = (\n      video as HTMLVideoElement & {\n        requestVideoFrameCallback?: RequestVideoFrameCallback;\n      }\n    ).requestVideoFrameCallback;\n    if (typeof request === \"function\") {\n      this.videoFrameHandle = request.call(video, this.handleVideoFrame);\n    }\n    return;\n  }\n  this.cancelVideoFrameCallback();\n  this.frameId = this.animationFrameProvider.request(this.handleAnimationFrame);\n};\n\nconst cancelAnimationFrameRequestImpl = function (this: CommentRenderer): void {\n  if (this.frameId !== null) {\n    this.animationFrameProvider.cancel(this.frameId);\n    this.frameId = null;\n  }\n};\n\nconst cancelVideoFrameCallbackImpl = function (this: CommentRenderer): void {\n  if (this.videoFrameHandle === null) {\n    return;\n  }\n  const video = this.videoElement as HTMLVideoElement & {\n    cancelVideoFrameCallback?: CancelVideoFrameCallback;\n  };\n  if (video && typeof video.cancelVideoFrameCallback === \"function\") {\n    video.cancelVideoFrameCallback(this.videoFrameHandle);\n  }\n  this.videoFrameHandle = null;\n};\n\nconst startAnimationImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  this.scheduleNextFrame();\n};\n\nconst stopAnimationImpl = function (this: CommentRenderer): void {\n  this.cancelAnimationFrameRequest();\n  this.cancelVideoFrameCallback();\n};\n\nconst onSeekImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const context = this.ctx;\n  const video = this.videoElement;\n  if (!canvas || !context || !video) {\n    return;\n  }\n\n  const nextTime = toMilliseconds(video.currentTime);\n  const timeDelta = Math.abs(nextTime - this.currentTime);\n  const now = this.timeSource.now();\n\n  const isRecentPlayResume = now - this.lastPlayResumeTime < this.playResumeSeekIgnoreDurationMs;\n  if (isRecentPlayResume) {\n    this.currentTime = nextTime;\n    if (this._settings.isCommentVisible) {\n      this.lastDrawTime = now;\n      this.draw();\n    }\n    return;\n  }\n\n  const isSignificantSeek = timeDelta > SEEK_DIRECTION_EPSILON_MS;\n\n  this.currentTime = nextTime;\n  this.resetFinalPhaseState();\n  this.updatePlaybackProgressState();\n\n  if (!isSignificantSeek) {\n    if (this._settings.isCommentVisible) {\n      this.lastDrawTime = this.timeSource.now();\n      this.draw();\n    }\n    return;\n  }\n\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const seekWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  seekWindowComments.forEach((comment) => {\n    const debugActive = isDebugLoggingEnabled();\n    const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n    if (debugActive) {\n      debugLog(\"comment-evaluate\", {\n        stage: \"seek\",\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: this.getEffectiveCommentVpos(comment),\n        currentTime: this.currentTime,\n        isActive: comment.isActive,\n        hasShown: comment.hasShown,\n      });\n    }\n\n    if (this.isNGComment(comment.text)) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"ng-runtime\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.clearActivation();\n      return;\n    }\n\n    if (comment.isInvisible) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"invisible\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.hasShown = true;\n      comment.clearActivation();\n      return;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n    comment.isActive = false;\n    this.activeComments.delete(comment);\n    comment.lane = -1;\n    comment.clearActivation();\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n      return;\n    }\n\n    const effectiveVpos = this.getEffectiveCommentVpos(comment);\n    if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n      comment.hasShown = true;\n    } else {\n      comment.hasShown = false;\n    }\n  });\n\n  if (this._settings.isCommentVisible) {\n    this.lastDrawTime = this.timeSource.now();\n    this.draw();\n  }\n};\n\nexport const registerTimingMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.processFrame = processFrameImpl;\n  ctor.prototype.handleAnimationFrame = handleAnimationFrameImpl;\n  ctor.prototype.handleVideoFrame = handleVideoFrameImpl;\n  ctor.prototype.shouldUseVideoFrameCallback = shouldUseVideoFrameCallbackImpl;\n  ctor.prototype.scheduleNextFrame = scheduleNextFrameImpl;\n  ctor.prototype.cancelAnimationFrameRequest = cancelAnimationFrameRequestImpl;\n  ctor.prototype.cancelVideoFrameCallback = cancelVideoFrameCallbackImpl;\n  ctor.prototype.startAnimation = startAnimationImpl;\n  ctor.prototype.stopAnimation = stopAnimationImpl;\n  ctor.prototype.onSeek = onSeekImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nexport type AutoHardResetReason =\n  | \"play-resume\"\n  | \"first-play-delay\"\n  | \"resize\"\n  | \"visibility-restore\"\n  | \"seeked\";\n\nconst shouldAutoHardReset = (renderer: CommentRenderer): boolean =>\n  renderer._settings.enableAutoHardReset;\n\nexport const requestAutoHardReset = (\n  renderer: CommentRenderer,\n  reason: AutoHardResetReason,\n): void => {\n  if (!shouldAutoHardReset(renderer)) {\n    return;\n  }\n  void reason;\n  const now = renderer.timeSource.now();\n  if (now - renderer.lastHardResetAt < renderer.autoHardResetDedupWindowMs) {\n    return;\n  }\n  renderer.hardReset();\n};\n\nexport const scheduleInitialPlaybackAutoReset = (renderer: CommentRenderer): void => {\n  if (!shouldAutoHardReset(renderer)) {\n    return;\n  }\n  if (renderer.initialPlaybackAutoResetTriggered) {\n    return;\n  }\n  if (renderer.initialPlaybackAutoResetTimer !== null) {\n    return;\n  }\n  renderer.initialPlaybackAutoResetTimer = globalThis.setTimeout(() => {\n    renderer.initialPlaybackAutoResetTimer = null;\n    if (!shouldAutoHardReset(renderer)) {\n      return;\n    }\n    renderer.initialPlaybackAutoResetTriggered = true;\n    requestAutoHardReset(renderer, \"first-play-delay\");\n  }, renderer.initialPlaybackAutoResetDelayMs);\n};\n\nexport const resetInitialPlaybackAutoResetState = (renderer: CommentRenderer): void => {\n  if (renderer.initialPlaybackAutoResetTimer !== null) {\n    globalThis.clearTimeout(renderer.initialPlaybackAutoResetTimer);\n    renderer.initialPlaybackAutoResetTimer = null;\n  }\n  renderer.initialPlaybackAutoResetTriggered = false;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { resetInitialPlaybackAutoResetState } from \"@/renderer/auto-hard-reset\";\nimport type { CommentRendererInitializeOptions } from \"@/shared/types\";\nimport { SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\n\nconst resolveContainerImpl = function (\n  this: CommentRenderer,\n  explicit: HTMLElement | null | undefined,\n  video: HTMLVideoElement,\n): HTMLElement {\n  if (explicit) {\n    return explicit;\n  }\n  if (video.parentElement) {\n    return video.parentElement;\n  }\n  if (typeof document !== \"undefined\" && document.body) {\n    return document.body;\n  }\n  throw new Error(\n    \"Cannot resolve container element. Provide container explicitly when DOM is unavailable.\",\n  );\n};\n\nconst ensureContainerPositioningImpl = function (\n  this: CommentRenderer,\n  container: HTMLElement,\n): void {\n  if (typeof getComputedStyle === \"function\") {\n    const style = getComputedStyle(container);\n    if (style.position === \"static\") {\n      container.style.position = \"relative\";\n    }\n    return;\n  }\n  if (!container.style.position) {\n    container.style.position = \"relative\";\n  }\n};\n\nconst initializeImpl = function (\n  this: CommentRenderer,\n  options: HTMLVideoElement | CommentRendererInitializeOptions,\n): void {\n  try {\n    this.destroyCanvasOnly();\n\n    const video = options instanceof HTMLVideoElement ? options : options.video;\n    const containerCandidate =\n      options instanceof HTMLVideoElement\n        ? options.parentElement\n        : (options.container ?? options.video.parentElement);\n    const container = this.resolveContainer(containerCandidate ?? null, video);\n\n    this.videoElement = video;\n    this.containerElement = container;\n    this.lastVideoSource = this.getCurrentVideoSource();\n    this.duration = Number.isFinite(video.duration) ? toMilliseconds(video.duration) : 0;\n    this.currentTime = toMilliseconds(video.currentTime);\n    this.playbackRate = video.playbackRate;\n    this.isPlaying = !video.paused;\n    this.isStalled = false;\n    this.lastDrawTime = this.timeSource.now();\n    this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n    this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n\n    const canvas = this.createCanvasElement();\n    const context = canvas.getContext(\"2d\");\n    if (!context) {\n      throw new Error(\"Failed to acquire 2D canvas context\");\n    }\n\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0\";\n    canvas.style.left = \"0\";\n    canvas.style.pointerEvents = \"none\";\n    canvas.style.zIndex = \"1000\";\n\n    const parent = this.containerElement;\n    if (parent instanceof HTMLElement) {\n      this.ensureContainerPositioning(parent);\n      parent.appendChild(canvas);\n    }\n\n    this.canvas = canvas;\n    this.ctx = context;\n\n    this.resize();\n    this.calculateLaneMetrics();\n    this.setupVideoEventListeners(video);\n    this.setupResizeHandling(video);\n    this.setupFullscreenHandling();\n    this.setupVideoChangeDetection(video, container);\n    this.startAnimation();\n    this.setupVisibilityHandling();\n  } catch (error) {\n    this.log.error(\"CommentRenderer.initialize\", error as Error);\n    throw error;\n  }\n};\n\nconst destroyImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  this.cleanupResizeHandling();\n  this.runCleanupTasks();\n  resetInitialPlaybackAutoResetState(this);\n\n  if (this.canvas) {\n    this.canvas.remove();\n  }\n  this.canvas = null;\n  this.ctx = null;\n  this.videoElement = null;\n  this.containerElement = null;\n  this.comments.length = 0;\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.resetFinalPhaseState();\n  this.displayWidth = 0;\n  this.displayHeight = 0;\n  this.canvasDpr = 1;\n  this.commentSequence = 0;\n  this.playbackHasBegun = false;\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n};\n\nconst destroyCanvasOnlyImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  resetInitialPlaybackAutoResetState(this);\n  if (this.canvas) {\n    this.canvas.remove();\n  }\n  this.canvas = null;\n  this.ctx = null;\n  this.displayWidth = 0;\n  this.displayHeight = 0;\n  this.canvasDpr = 1;\n  this.fullscreenActive = false;\n};\n\nexport const registerLifecycleCoreMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.resolveContainer = resolveContainerImpl;\n  ctor.prototype.ensureContainerPositioning = ensureContainerPositioningImpl;\n  ctor.prototype.initialize = initializeImpl;\n  ctor.prototype.destroy = destroyImpl;\n  ctor.prototype.destroyCanvasOnly = destroyCanvasOnlyImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport {\n  requestAutoHardReset,\n  resetInitialPlaybackAutoResetState,\n  scheduleInitialPlaybackAutoReset,\n} from \"@/renderer/auto-hard-reset\";\nimport { SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\n\nconst setupVideoEventListenersImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  try {\n    const onPlay = (): void => {\n      const wasPlaying = this.isPlaying;\n      this.isPlaying = true;\n      this.playbackHasBegun = true;\n      const now = this.timeSource.now();\n      this.lastDrawTime = now;\n      this.lastPlayResumeTime = now;\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n        comment.isPaused = false;\n      });\n      if (!wasPlaying) {\n        requestAutoHardReset(this, \"play-resume\");\n      }\n      scheduleInitialPlaybackAutoReset(this);\n    };\n    const onPause = (): void => {\n      this.isPlaying = false;\n      const now = this.timeSource.now();\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n        comment.isPaused = true;\n      });\n    };\n    const onSeeking = (): void => {\n      this.onSeek();\n    };\n    const onSeeked = (): void => {\n      this.onSeek();\n      requestAutoHardReset(this, \"seeked\");\n    };\n    const onRateChange = (): void => {\n      this.playbackRate = videoElement.playbackRate;\n      const now = this.timeSource.now();\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n      });\n    };\n    const onLoadedMetadata = (): void => {\n      this.handleVideoMetadataLoaded(videoElement);\n    };\n    const onDurationChange = (): void => {\n      this.duration = Number.isFinite(videoElement.duration)\n        ? toMilliseconds(videoElement.duration)\n        : 0;\n    };\n    const onEmptied = (): void => {\n      this.handleVideoSourceChange();\n    };\n    const onWaiting = (): void => {\n      this.handleVideoStalled();\n    };\n    const onCanPlay = (): void => {\n      this.handleVideoCanPlay();\n    };\n    const onPlaying = (): void => {\n      this.handleVideoCanPlay();\n    };\n\n    videoElement.addEventListener(\"play\", onPlay);\n    videoElement.addEventListener(\"pause\", onPause);\n    videoElement.addEventListener(\"seeking\", onSeeking);\n    videoElement.addEventListener(\"seeked\", onSeeked);\n    videoElement.addEventListener(\"ratechange\", onRateChange);\n    videoElement.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n    videoElement.addEventListener(\"durationchange\", onDurationChange);\n    videoElement.addEventListener(\"emptied\", onEmptied);\n    videoElement.addEventListener(\"waiting\", onWaiting);\n    videoElement.addEventListener(\"canplay\", onCanPlay);\n    videoElement.addEventListener(\"playing\", onPlaying);\n\n    this.addCleanup(() => videoElement.removeEventListener(\"play\", onPlay));\n    this.addCleanup(() => videoElement.removeEventListener(\"pause\", onPause));\n    this.addCleanup(() => videoElement.removeEventListener(\"seeking\", onSeeking));\n    this.addCleanup(() => videoElement.removeEventListener(\"seeked\", onSeeked));\n    this.addCleanup(() => videoElement.removeEventListener(\"ratechange\", onRateChange));\n    this.addCleanup(() => videoElement.removeEventListener(\"loadedmetadata\", onLoadedMetadata));\n    this.addCleanup(() => videoElement.removeEventListener(\"durationchange\", onDurationChange));\n    this.addCleanup(() => videoElement.removeEventListener(\"emptied\", onEmptied));\n    this.addCleanup(() => videoElement.removeEventListener(\"waiting\", onWaiting));\n    this.addCleanup(() => videoElement.removeEventListener(\"canplay\", onCanPlay));\n    this.addCleanup(() => videoElement.removeEventListener(\"playing\", onPlaying));\n  } catch (error) {\n    this.log.error(\"CommentRenderer.setupVideoEventListeners\", error as Error);\n    throw error;\n  }\n};\n\nconst handleVideoMetadataLoadedImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  this.lastVideoSource = this.getCurrentVideoSource();\n  this.incrementEpoch(\"metadata-loaded\");\n  this.handleVideoSourceChange(videoElement);\n  this.resize();\n  this.calculateLaneMetrics();\n  this.hardReset();\n  this.onSeek();\n  this.emitStateSnapshot(\"metadata-loaded\");\n  resetInitialPlaybackAutoResetState(this);\n};\n\nconst handleVideoStalledImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  if (!canvas || !ctx) {\n    return;\n  }\n\n  this.isStalled = true;\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n\n  this.comments.forEach((comment) => {\n    if (comment.isActive) {\n      comment.lastUpdateTime = this.timeSource.now();\n    }\n  });\n};\n\nconst handleVideoCanPlayImpl = function (this: CommentRenderer): void {\n  if (!this.isStalled) {\n    return;\n  }\n\n  this.isStalled = false;\n\n  if (this.videoElement) {\n    this.currentTime = toMilliseconds(this.videoElement.currentTime);\n    this.isPlaying = !this.videoElement.paused;\n  }\n\n  this.lastDrawTime = this.timeSource.now();\n};\n\nconst handleVideoSourceChangeImpl = function (\n  this: CommentRenderer,\n  videoElement?: HTMLVideoElement | null,\n): void {\n  const target = videoElement ?? this.videoElement;\n  if (!target) {\n    this.lastVideoSource = null;\n    this.isPlaying = false;\n    this.resetFinalPhaseState();\n    this.resetCommentActivity();\n    resetInitialPlaybackAutoResetState(this);\n    return;\n  }\n\n  const currentSource = this.getCurrentVideoSource();\n  const sourceChanged = currentSource !== this.lastVideoSource;\n  if (!sourceChanged) {\n    return;\n  }\n\n  this.lastVideoSource = currentSource;\n  this.incrementEpoch(\"source-change\");\n  this.syncVideoState(target);\n  this.resetFinalPhaseState();\n  this.resetCommentActivity();\n  this.emitStateSnapshot(\"source-change\");\n  resetInitialPlaybackAutoResetState(this);\n};\n\nconst syncVideoStateImpl = function (this: CommentRenderer, videoElement: HTMLVideoElement): void {\n  this.duration = Number.isFinite(videoElement.duration)\n    ? toMilliseconds(videoElement.duration)\n    : 0;\n  this.currentTime = toMilliseconds(videoElement.currentTime);\n  this.playbackRate = videoElement.playbackRate;\n  this.isPlaying = !videoElement.paused;\n  this.isStalled = false;\n  this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n  this.lastDrawTime = this.timeSource.now();\n};\n\nconst resetCommentActivityImpl = function (this: CommentRenderer): void {\n  const now = this.timeSource.now();\n  const canvas = this.canvas;\n  const context = this.ctx;\n  this.resetFinalPhaseState();\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n  this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n  if (canvas && context) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const width = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const height = this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    context.clearRect(0, 0, width, height);\n  }\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  this.comments.forEach((comment) => {\n    comment.isActive = false;\n    comment.isPaused = !this.isPlaying;\n    comment.hasShown = false;\n    comment.lane = -1;\n    comment.x = comment.virtualStartX;\n    comment.speed = comment.baseSpeed;\n    comment.lastUpdateTime = now;\n    comment.clearActivation();\n  });\n  this.activeComments.clear();\n};\n\nconst setupVideoChangeDetectionImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n  container: HTMLElement,\n): void {\n  if (typeof MutationObserver === \"undefined\") {\n    this.log.debug(\n      \"MutationObserver is not available in this environment. Video change detection is disabled.\",\n    );\n    return;\n  }\n\n  const videoObserver = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      if (mutation.type === \"attributes\" && mutation.attributeName === \"src\") {\n        const targetNode = mutation.target;\n        let previous: string | null = null;\n        let current: string | null = null;\n        if (targetNode instanceof HTMLVideoElement || targetNode instanceof HTMLSourceElement) {\n          previous = typeof mutation.oldValue === \"string\" ? mutation.oldValue : null;\n          current = targetNode.getAttribute(\"src\");\n        }\n        if (previous === current) {\n          continue;\n        }\n        this.handleVideoSourceChange(videoElement);\n        return;\n      }\n      if (mutation.type === \"childList\") {\n        for (const node of mutation.addedNodes) {\n          if (node instanceof HTMLSourceElement) {\n            this.handleVideoSourceChange(videoElement);\n            return;\n          }\n        }\n        for (const node of mutation.removedNodes) {\n          if (node instanceof HTMLSourceElement) {\n            this.handleVideoSourceChange(videoElement);\n            return;\n          }\n        }\n      }\n    }\n  });\n\n  videoObserver.observe(videoElement, {\n    attributes: true,\n    attributeFilter: [\"src\"],\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  this.addCleanup(() => videoObserver.disconnect());\n\n  const containerObserver = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      if (mutation.type !== \"childList\") {\n        continue;\n      }\n      for (const node of mutation.addedNodes) {\n        const nextVideo = this.extractVideoElement(node);\n        if (nextVideo && nextVideo !== this.videoElement) {\n          this.initialize(nextVideo);\n          return;\n        }\n      }\n      for (const node of mutation.removedNodes) {\n        if (node === this.videoElement) {\n          this.videoElement = null;\n          this.handleVideoSourceChange(null);\n          return;\n        }\n        if (node instanceof Element) {\n          const removedVideo = node.querySelector(\"video\");\n          if (removedVideo && removedVideo === this.videoElement) {\n            this.videoElement = null;\n            this.handleVideoSourceChange(null);\n            return;\n          }\n        }\n      }\n    }\n  });\n\n  containerObserver.observe(container, { childList: true, subtree: true });\n  this.addCleanup(() => containerObserver.disconnect());\n};\n\nconst extractVideoElementImpl = function (\n  this: CommentRenderer,\n  node: Node,\n): HTMLVideoElement | null {\n  if (node instanceof HTMLVideoElement) {\n    return node;\n  }\n  if (node instanceof Element) {\n    const candidate = node.querySelector(\"video\");\n    if (candidate instanceof HTMLVideoElement) {\n      return candidate;\n    }\n  }\n  return null;\n};\n\nexport const registerLifecycleVideoMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupVideoEventListeners = setupVideoEventListenersImpl;\n  ctor.prototype.handleVideoMetadataLoaded = handleVideoMetadataLoadedImpl;\n  ctor.prototype.handleVideoStalled = handleVideoStalledImpl;\n  ctor.prototype.handleVideoCanPlay = handleVideoCanPlayImpl;\n  ctor.prototype.handleVideoSourceChange = handleVideoSourceChangeImpl;\n  ctor.prototype.syncVideoState = syncVideoStateImpl;\n  ctor.prototype.resetCommentActivity = resetCommentActivityImpl;\n  ctor.prototype.setupVideoChangeDetection = setupVideoChangeDetectionImpl;\n  ctor.prototype.extractVideoElement = extractVideoElementImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { requestAutoHardReset } from \"@/renderer/auto-hard-reset\";\nimport { toMilliseconds } from \"@/shared/constants\";\n\nconst setupVisibilityHandlingImpl = function (this: CommentRenderer): void {\n  if (\n    typeof document === \"undefined\" ||\n    typeof document.addEventListener !== \"function\" ||\n    typeof document.removeEventListener !== \"function\"\n  ) {\n    return;\n  }\n\n  const enforceVisibilityState = (): void => {\n    const state = document.visibilityState;\n    if (state !== \"visible\") {\n      this.stopAnimation();\n      return;\n    }\n    if (!this._settings.isCommentVisible) {\n      return;\n    }\n    this.handleVisibilityRestore();\n    this.startAnimation();\n  };\n\n  document.addEventListener(\"visibilitychange\", enforceVisibilityState);\n  this.addCleanup(() => document.removeEventListener(\"visibilitychange\", enforceVisibilityState));\n\n  if (document.visibilityState !== \"visible\") {\n    this.stopAnimation();\n  }\n};\n\nconst handleVisibilityRestoreImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  const video = this.videoElement;\n  if (!canvas || !ctx || !video) {\n    return;\n  }\n\n  this.currentTime = toMilliseconds(video.currentTime);\n  this.lastDrawTime = this.timeSource.now();\n  this.isPlaying = !video.paused;\n  this.isStalled = false;\n  this.pendingInitialSync = true;\n  this.resetFinalPhaseState();\n  this.updatePlaybackProgressState();\n  requestAutoHardReset(this, \"visibility-restore\");\n  this.draw();\n};\n\nexport const registerVisibilityMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupVisibilityHandling = setupVisibilityHandlingImpl;\n  ctor.prototype.handleVisibilityRestore = handleVisibilityRestoreImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { requestAutoHardReset } from \"@/renderer/auto-hard-reset\";\nimport { DEFAULT_LANE_COUNT, MIN_FONT_SIZE_PX, MIN_LANE_COUNT } from \"@/shared/constants\";\n\nconst resizeImpl = function (this: CommentRenderer, width?: number, height?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas) {\n    return;\n  }\n\n  const rect = video.getBoundingClientRect();\n  const currentDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const fallbackWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / currentDpr;\n  const fallbackHeight = this.displayHeight > 0 ? this.displayHeight : canvas.height / currentDpr;\n\n  const measuredWidth = width ?? rect.width ?? fallbackWidth;\n  const measuredHeight = height ?? rect.height ?? fallbackHeight;\n\n  if (\n    !Number.isFinite(measuredWidth) ||\n    !Number.isFinite(measuredHeight) ||\n    measuredWidth <= 0 ||\n    measuredHeight <= 0\n  ) {\n    return;\n  }\n\n  const cssWidth = Math.max(1, Math.floor(measuredWidth));\n  const cssHeight = Math.max(1, Math.floor(measuredHeight));\n  const previousDisplayWidth = this.displayWidth > 0 ? this.displayWidth : cssWidth;\n  const previousDisplayHeight = this.displayHeight > 0 ? this.displayHeight : cssHeight;\n  const nextDpr = this._settings.useDprScaling ? this.resolveDevicePixelRatio() : 1;\n  const pixelWidth = Math.max(1, Math.round(cssWidth * nextDpr));\n  const pixelHeight = Math.max(1, Math.round(cssHeight * nextDpr));\n\n  const needsResize =\n    this.displayWidth !== cssWidth ||\n    this.displayHeight !== cssHeight ||\n    Math.abs(this.canvasDpr - nextDpr) > Number.EPSILON ||\n    canvas.width !== pixelWidth ||\n    canvas.height !== pixelHeight;\n\n  if (!needsResize) {\n    return;\n  }\n\n  this.displayWidth = cssWidth;\n  this.displayHeight = cssHeight;\n  this.canvasDpr = nextDpr;\n\n  canvas.width = pixelWidth;\n  canvas.height = pixelHeight;\n  canvas.style.width = `${cssWidth}px`;\n  canvas.style.height = `${cssHeight}px`;\n\n  if (context) {\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    if (this._settings.useDprScaling) {\n      context.scale(nextDpr, nextDpr);\n    }\n  }\n\n  const scaleX = previousDisplayWidth > 0 ? cssWidth / previousDisplayWidth : 1;\n  const scaleY = previousDisplayHeight > 0 ? cssHeight / previousDisplayHeight : 1;\n\n  if (scaleX !== 1 || scaleY !== 1) {\n    this.comments.forEach((comment) => {\n      if (comment.isActive) {\n        comment.x *= scaleX;\n        comment.y *= scaleY;\n        comment.width *= scaleX;\n        comment.fontSize = Math.max(\n          MIN_FONT_SIZE_PX,\n          Math.floor(Math.max(1, comment.fontSize) * scaleY),\n        );\n        comment.height = comment.fontSize;\n        comment.virtualStartX *= scaleX;\n        comment.exitThreshold *= scaleX;\n        comment.baseSpeed *= scaleX;\n        comment.speed *= scaleX;\n        comment.speedPixelsPerMs *= scaleX;\n        comment.bufferWidth *= scaleX;\n        comment.reservationWidth *= scaleX;\n      }\n    });\n  }\n\n  this.calculateLaneMetrics();\n  requestAutoHardReset(this, \"resize\");\n};\n\nconst resolveDevicePixelRatioImpl = function (this: CommentRenderer): number {\n  if (typeof window === \"undefined\") {\n    return 1;\n  }\n  const ratio = Number(window.devicePixelRatio);\n  if (!Number.isFinite(ratio) || ratio <= 0) {\n    return 1;\n  }\n  return ratio;\n};\n\nconst calculateLaneMetricsImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  if (!canvas) {\n    return;\n  }\n\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / Math.max(this.canvasDpr, 1);\n  const baseHeight = Math.max(MIN_FONT_SIZE_PX, Math.floor(effectiveHeight * 0.05));\n  this.laneHeight = baseHeight * 1.2;\n  const availableLanes = Math.floor(effectiveHeight / Math.max(this.laneHeight, 1));\n  if (this._settings.useFixedLaneCount) {\n    const desired = Number.isFinite(this._settings.fixedLaneCount)\n      ? Math.floor(this._settings.fixedLaneCount)\n      : DEFAULT_LANE_COUNT;\n    const clamped = Math.max(MIN_LANE_COUNT, Math.min(availableLanes, desired));\n    this.laneCount = clamped;\n  } else {\n    this.laneCount = Math.max(MIN_LANE_COUNT, availableLanes);\n  }\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n};\n\nconst setupResizeHandlingImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  this.cleanupResizeHandling();\n\n  if (this._settings.useContainerResizeObserver && this.isResizeObserverAvailable) {\n    const target = this.resolveResizeObserverTarget(videoElement);\n    const observer = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { width, height } = entry.contentRect;\n        if (width > 0 && height > 0) {\n          this.resize(width, height);\n        } else {\n          this.resize();\n        }\n      }\n    });\n    observer.observe(target);\n    this.resizeObserver = observer;\n    this.resizeObserverTarget = target;\n  } else if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\") {\n    const onResize = (): void => {\n      this.resize();\n    };\n    window.addEventListener(\"resize\", onResize);\n    this.addCleanup(() => window.removeEventListener(\"resize\", onResize));\n  } else {\n    this.log.debug(\n      \"Resize handling is disabled because neither ResizeObserver nor window APIs are available.\",\n    );\n  }\n};\n\nconst cleanupResizeHandlingImpl = function (this: CommentRenderer): void {\n  if (this.resizeObserver && this.resizeObserverTarget) {\n    this.resizeObserver.unobserve(this.resizeObserverTarget);\n  }\n  this.resizeObserver?.disconnect();\n  this.resizeObserver = null;\n  this.resizeObserverTarget = null;\n};\n\nexport const registerResizeMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.resize = resizeImpl;\n  ctor.prototype.resolveDevicePixelRatio = resolveDevicePixelRatioImpl;\n  ctor.prototype.calculateLaneMetrics = calculateLaneMetricsImpl;\n  ctor.prototype.setupResizeHandling = setupResizeHandlingImpl;\n  ctor.prototype.cleanupResizeHandling = cleanupResizeHandlingImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nconst setupFullscreenHandlingImpl = function (this: CommentRenderer): void {\n  if (\n    typeof document === \"undefined\" ||\n    typeof document.addEventListener !== \"function\" ||\n    typeof document.removeEventListener !== \"function\"\n  ) {\n    return;\n  }\n\n  const onFullscreenChange = (): void => {\n    void this.handleFullscreenChange();\n  };\n\n  const events = [\n    \"fullscreenchange\",\n    \"webkitfullscreenchange\",\n    \"mozfullscreenchange\",\n    \"MSFullscreenChange\",\n  ];\n\n  events.forEach((eventName) => {\n    document.addEventListener(eventName, onFullscreenChange);\n    this.addCleanup(() => document.removeEventListener(eventName, onFullscreenChange));\n  });\n\n  void this.handleFullscreenChange();\n};\n\nconst resolveResizeObserverTargetImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): Element {\n  const fullscreenContainer = this.resolveFullscreenContainer(videoElement);\n  if (fullscreenContainer) {\n    return fullscreenContainer;\n  }\n  return videoElement.parentElement ?? videoElement;\n};\n\nconst handleFullscreenChangeImpl = async function (this: CommentRenderer): Promise<void> {\n  const canvas = this.canvas;\n  const video = this.videoElement;\n  if (!canvas || !video) {\n    return;\n  }\n\n  const baseContainer = this.containerElement ?? video.parentElement ?? null;\n  const fullscreenElement = this.getFullscreenElement();\n  const nextContainer = this.resolveActiveOverlayContainer(video, baseContainer, fullscreenElement);\n\n  if (!(nextContainer instanceof HTMLElement)) {\n    return;\n  }\n\n  if (canvas.parentElement !== nextContainer) {\n    this.ensureContainerPositioning(nextContainer);\n    nextContainer.appendChild(canvas);\n  } else {\n    this.ensureContainerPositioning(nextContainer);\n  }\n\n  const fullscreenContainer =\n    fullscreenElement instanceof HTMLElement && fullscreenElement.contains(video)\n      ? fullscreenElement\n      : null;\n  const isFullscreenNow = fullscreenContainer !== null;\n  if (this.fullscreenActive !== isFullscreenNow) {\n    this.fullscreenActive = isFullscreenNow;\n    this.setupResizeHandling(video);\n  }\n\n  canvas.style.position = \"absolute\";\n  canvas.style.top = \"0\";\n  canvas.style.left = \"0\";\n\n  this.resize();\n};\n\nconst resolveFullscreenContainerImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): HTMLElement | null {\n  const fullscreenElement = this.getFullscreenElement();\n  if (!(fullscreenElement instanceof HTMLElement)) {\n    return null;\n  }\n  if (fullscreenElement === videoElement) {\n    return fullscreenElement;\n  }\n  if (fullscreenElement.contains(videoElement)) {\n    return fullscreenElement;\n  }\n  return null;\n};\n\nconst resolveActiveOverlayContainerImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n  baseContainer: HTMLElement | null,\n  fullscreenElement: Element | null,\n): HTMLElement | null {\n  if (fullscreenElement instanceof HTMLElement && fullscreenElement.contains(videoElement)) {\n    if (fullscreenElement instanceof HTMLVideoElement) {\n      if (baseContainer instanceof HTMLElement) {\n        return baseContainer;\n      }\n      return fullscreenElement;\n    }\n    return fullscreenElement;\n  }\n  return baseContainer ?? null;\n};\n\nconst getFullscreenElementImpl = function (this: CommentRenderer): Element | null {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const doc = document as Document & {\n    webkitFullscreenElement?: Element | null;\n    msFullscreenElement?: Element | null;\n    mozFullScreenElement?: Element | null;\n  };\n  return (\n    document.fullscreenElement ??\n    doc.webkitFullscreenElement ??\n    doc.mozFullScreenElement ??\n    doc.msFullscreenElement ??\n    null\n  );\n};\n\nexport const registerFullscreenMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupFullscreenHandling = setupFullscreenHandlingImpl;\n  ctor.prototype.resolveResizeObserverTarget = resolveResizeObserverTargetImpl;\n  ctor.prototype.handleFullscreenChange = handleFullscreenChangeImpl;\n  ctor.prototype.resolveFullscreenContainer = resolveFullscreenContainerImpl;\n  ctor.prototype.resolveActiveOverlayContainer = resolveActiveOverlayContainerImpl;\n  ctor.prototype.getFullscreenElement = getFullscreenElementImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nconst addCleanupImpl = function (this: CommentRenderer, task: () => void): void {\n  this.cleanupTasks.push(task);\n};\n\nconst runCleanupTasksImpl = function (this: CommentRenderer): void {\n  while (this.cleanupTasks.length > 0) {\n    const task = this.cleanupTasks.pop();\n    try {\n      task?.();\n    } catch (error) {\n      this.log.error(\"CommentRenderer.cleanupTask\", error as Error);\n    }\n  }\n};\n\nexport const registerCleanupMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.addCleanup = addCleanupImpl;\n  ctor.prototype.runCleanupTasks = runCleanupTasksImpl;\n};\n","import { cloneDefaultSettings } from \"@/config/default-settings\";\nimport type {\n  RendererSettings,\n  CommentRendererEventHooks,\n  CommentDependencies,\n  CommentPrepareOptions,\n  TimeSource,\n} from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport { createDefaultTimeSource } from \"@/comment/time-source\";\nimport { createLogger } from \"@/shared/logger\";\nimport type { Logger } from \"@/shared/types\";\nimport { configureDebugLogging } from \"@/shared/debug\";\nimport {\n  createBrowserCanvasFactory,\n  createDefaultAnimationFrameProvider,\n  isRendererSettings,\n  normalizeSettings,\n} from \"@/shared/settings\";\nexport { createDefaultAnimationFrameProvider } from \"@/shared/settings\";\nimport type {\n  AnimationFrameProvider,\n  CommentRendererConfig,\n  CommentRendererInitializeOptions,\n  LaneReservation,\n  StaticLaneReservation,\n  VideoFrameCallbackMetadataLike,\n} from \"@/shared/types\";\nimport {\n  AUTO_HARD_RESET_DEDUP_WINDOW_MS,\n  AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS,\n  DEFAULT_LANE_COUNT,\n} from \"@/shared/constants\";\nimport { rebuildNgMatchersImpl, registerCommentCollectionMethods } from \"@/renderer/comments\";\nimport { registerFinalPhaseMethods } from \"@/renderer/final-phase\";\nimport { registerPlaybackHelpers } from \"@/renderer/playback\";\nimport { registerActivationMethods } from \"@/renderer/activation\";\nimport { registerLanePruneMethods } from \"@/renderer/lanes-prune\";\nimport { registerLaneStaticMethods } from \"@/renderer/lanes-static\";\nimport { registerLaneActivationMethods } from \"@/renderer/lanes-activation\";\nimport { registerLaneReservationMethods } from \"@/renderer/lanes-reservations\";\nimport { registerRenderMethods } from \"@/renderer/render\";\nimport { registerTimingMethods } from \"@/renderer/timing\";\nimport { registerLifecycleCoreMethods } from \"@/renderer/lifecycle-core\";\nimport { registerLifecycleVideoMethods } from \"@/renderer/lifecycle-video-events\";\nimport { registerVisibilityMethods } from \"@/renderer/visibility\";\nimport { registerResizeMethods } from \"@/renderer/resize\";\nimport { registerFullscreenMethods } from \"@/renderer/fullscreen\";\nimport { registerCleanupMethods } from \"@/renderer/cleanup\";\n\nexport type { CommentRendererConfig, CommentRendererInitializeOptions, AnimationFrameProvider };\n\nexport class CommentRenderer {\n  public _settings: RendererSettings;\n  public readonly comments: Comment[] = [];\n  public readonly activeComments = new Set<Comment>();\n  public readonly reservedLanes = new Map<number, LaneReservation[]>();\n  public readonly topStaticLaneReservations: StaticLaneReservation[] = [];\n  public readonly bottomStaticLaneReservations: StaticLaneReservation[] = [];\n  public readonly log: Logger;\n  public readonly timeSource: TimeSource;\n  public readonly animationFrameProvider: AnimationFrameProvider;\n  public readonly createCanvasElement: () => HTMLCanvasElement;\n  public readonly commentDependencies: CommentDependencies;\n  public settingsVersion = 0;\n  public normalizedNgWords: string[] = [];\n  public compiledNgRegexps: RegExp[] = [];\n  public canvas: HTMLCanvasElement | null = null;\n  public ctx: CanvasRenderingContext2D | null = null;\n  public videoElement: HTMLVideoElement | null = null;\n  public containerElement: HTMLElement | null = null;\n  public fullscreenActive = false;\n  public laneCount = DEFAULT_LANE_COUNT;\n  public laneHeight = 0;\n  public displayWidth = 0;\n  public displayHeight = 0;\n  public canvasDpr = 1;\n  public currentTime = 0;\n  public duration = 0;\n  public playbackRate = 1;\n  public isPlaying = true;\n  public isStalled = false;\n  public lastDrawTime = 0;\n  public finalPhaseActive = false;\n  public finalPhaseStartTime: number | null = null;\n  public finalPhaseScheduleDirty = false;\n  public playbackHasBegun = false;\n  public skipDrawingForCurrentFrame = false;\n  public pendingInitialSync = false;\n  public readonly finalPhaseVposOverrides = new Map<Comment, number>();\n  public frameId: ReturnType<typeof setTimeout> | null = null;\n  public videoFrameHandle: number | null = null;\n  public resizeObserver: ResizeObserver | null = null;\n  public resizeObserverTarget: Element | null = null;\n  public readonly isResizeObserverAvailable = typeof ResizeObserver !== \"undefined\";\n  public readonly cleanupTasks: Array<() => void> = [];\n  public commentSequence = 0;\n  public epochId = 0;\n  public readonly eventHooks: CommentRendererEventHooks;\n  public lastSnapshotEmitTime = 0;\n  public readonly snapshotEmitThrottleMs = 1000;\n  public lastPlayResumeTime = 0;\n  public readonly playResumeSeekIgnoreDurationMs = 500;\n  public lastVideoSource: string | null = null;\n  public lastHardResetAt = 0;\n  public readonly autoHardResetDedupWindowMs = AUTO_HARD_RESET_DEDUP_WINDOW_MS;\n  public readonly initialPlaybackAutoResetDelayMs = AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS;\n  public initialPlaybackAutoResetTimer: ReturnType<typeof setTimeout> | null = null;\n  public initialPlaybackAutoResetTriggered = false;\n\n  declare public initialize: (options: HTMLVideoElement | CommentRendererInitializeOptions) => void;\n  declare public destroy: () => void;\n  declare public destroyCanvasOnly: () => void;\n  declare public resolveContainer: (\n    explicit: HTMLElement | null | undefined,\n    video: HTMLVideoElement,\n  ) => HTMLElement;\n  declare public ensureContainerPositioning: (container: HTMLElement) => void;\n  declare public resize: (width?: number, height?: number) => void;\n  declare public resolveDevicePixelRatio: () => number;\n  declare public calculateLaneMetrics: () => void;\n  declare public setupResizeHandling: (videoElement: HTMLVideoElement) => void;\n  declare public cleanupResizeHandling: () => void;\n  declare public setupVideoEventListeners: (videoElement: HTMLVideoElement) => void;\n  declare public handleVideoMetadataLoaded: (videoElement: HTMLVideoElement) => void;\n  declare public handleVideoStalled: () => void;\n  declare public handleVideoCanPlay: () => void;\n  declare public handleVideoSourceChange: (videoElement?: HTMLVideoElement | null) => void;\n  declare public syncVideoState: (videoElement: HTMLVideoElement) => void;\n  declare public resetCommentActivity: () => void;\n  declare public setupVideoChangeDetection: (\n    video: HTMLVideoElement,\n    container: HTMLElement,\n  ) => void;\n  declare public extractVideoElement: (node: Node) => HTMLVideoElement | null;\n  declare public setupVisibilityHandling: () => void;\n  declare public handleVisibilityRestore: () => void;\n  declare public setupFullscreenHandling: () => void;\n  declare public resolveResizeObserverTarget: (videoElement: HTMLVideoElement) => Element;\n  declare public handleFullscreenChange: () => Promise<void>;\n  declare public resolveFullscreenContainer: (videoElement: HTMLVideoElement) => HTMLElement | null;\n  declare public resolveActiveOverlayContainer: (\n    videoElement: HTMLVideoElement,\n    baseContainer: HTMLElement | null,\n    fullscreenElement: Element | null,\n  ) => HTMLElement | null;\n  declare public getFullscreenElement: () => Element | null;\n  declare public addCleanup: (task: () => void) => void;\n  declare public runCleanupTasks: () => void;\n  public rebuildNgMatchers(): void {\n    rebuildNgMatchersImpl.call(this);\n  }\n  declare public isNGComment: (text: string) => boolean;\n  declare public addComments: (\n    entries: ReadonlyArray<{ text: string; vposMs: number; commands?: string[] }>,\n  ) => Comment[];\n  declare public addComment: (text: string, vposMs: number, commands?: string[]) => Comment | null;\n  declare public clearComments: () => void;\n  declare public resetState: () => void;\n  declare public hardReset: () => void;\n  declare public resetFinalPhaseState: () => void;\n  declare public incrementEpoch: (\n    reason: \"source-change\" | \"metadata-loaded\" | \"manual-reset\",\n  ) => void;\n  declare public emitStateSnapshot: (label: string) => void;\n  declare public getEffectiveCommentVpos: (comment: Comment) => number;\n  declare public getFinalPhaseDisplayDuration: (comment: Comment) => number;\n  declare public resolveFinalPhaseVpos: (comment: Comment) => number;\n  declare public recomputeFinalPhaseTimeline: () => void;\n  declare public shouldSuppressRendering: () => boolean;\n  declare public updatePlaybackProgressState: () => void;\n  declare public updateComments: (frameTimeMs?: number) => void;\n  declare public buildPrepareOptions: (visibleWidth: number) => CommentPrepareOptions;\n  declare public findAvailableLane: (comment: Comment) => number;\n  declare public findFirstValidReservationIndex: (\n    reservations: LaneReservation[],\n    cutoffTime: number,\n  ) => number;\n  declare public pruneLaneReservations: (currentTime: number) => void;\n  declare public pruneStaticLaneReservations: (currentTime: number) => void;\n  declare public findCommentIndexAtOrAfter: (targetVposMs: number) => number;\n  declare public getCommentsInTimeWindow: (centerTimeMs: number, windowMs: number) => Comment[];\n  declare public getStaticReservations: (position: \"ue\" | \"shita\") => StaticLaneReservation[];\n  declare public getStaticLaneDepth: (position: \"ue\" | \"shita\") => number;\n  declare public getStaticLaneLimit: (position: \"ue\" | \"shita\") => number;\n  declare public getGlobalLaneIndexForBottom: (localIndex: number) => number;\n  declare public resolveStaticCommentOffset: (\n    position: \"ue\" | \"shita\",\n    lane: number,\n    displayHeight: number,\n    comment: Comment,\n  ) => number;\n  declare public getStaticReservedLaneSet: () => Set<number>;\n  declare public shouldActivateCommentAtTime: (\n    comment: Comment,\n    timeMs: number,\n    preview?: string,\n  ) => boolean;\n  declare public activateComment: (\n    comment: Comment,\n    context: CanvasRenderingContext2D,\n    displayWidth: number,\n    displayHeight: number,\n    options: CommentPrepareOptions,\n    referenceTime: number,\n  ) => void;\n  declare public assignStaticLane: (\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    displayHeight: number,\n    currentTime: number,\n  ) => number;\n  declare public reserveStaticLane: (\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    lane: number,\n    releaseTime: number,\n  ) => void;\n  declare public releaseStaticLane: (position: \"ue\" | \"shita\", lane: number) => void;\n  declare public getLanePriorityOrder: (currentTime: number) => number[];\n  declare public getLaneNextAvailableTime: (lane: number, currentTime: number) => number;\n  declare public createLaneReservation: (\n    comment: Comment,\n    referenceTime: number,\n  ) => LaneReservation;\n  declare public isLaneAvailable: (\n    lane: number,\n    candidate: LaneReservation,\n    currentTime: number,\n  ) => boolean;\n  declare public storeLaneReservation: (lane: number, reservation: LaneReservation) => void;\n  declare public areReservationsConflicting: (a: LaneReservation, b: LaneReservation) => boolean;\n  declare public computeForwardGap: (\n    from: LaneReservation,\n    to: LaneReservation,\n    time: number,\n  ) => number;\n  declare public getBufferedEdges: (\n    reservation: LaneReservation,\n    time: number,\n  ) => { left: number; right: number };\n  declare public solveLeftRightEqualityTime: (\n    left: LaneReservation,\n    right: LaneReservation,\n  ) => number | null;\n  declare public draw: () => void;\n  declare public performInitialSync: (frameTimeMs?: number) => void;\n  declare public processFrame: (frameTimeMs?: number) => void;\n  declare public handleAnimationFrame: () => void;\n  declare public handleVideoFrame: (\n    now: DOMHighResTimeStamp,\n    metadata: VideoFrameCallbackMetadataLike,\n  ) => void;\n  declare public shouldUseVideoFrameCallback: () => boolean;\n  declare public scheduleNextFrame: () => void;\n  declare public cancelAnimationFrameRequest: () => void;\n  declare public cancelVideoFrameCallback: () => void;\n  declare public startAnimation: () => void;\n  declare public stopAnimation: () => void;\n  declare public onSeek: () => void;\n\n  constructor(settings: RendererSettings | null, config?: CommentRendererConfig);\n  constructor(config?: CommentRendererConfig);\n  constructor(\n    settingsOrConfig: RendererSettings | CommentRendererConfig | null = null,\n    maybeConfig: CommentRendererConfig | undefined = undefined,\n  ) {\n    let baseSettings: RendererSettings;\n    let config: CommentRendererConfig;\n\n    if (isRendererSettings(settingsOrConfig)) {\n      baseSettings = normalizeSettings({ ...(settingsOrConfig as RendererSettings) });\n      config = maybeConfig ?? {};\n    } else {\n      const configCandidate = settingsOrConfig ?? maybeConfig ?? {};\n      config =\n        typeof configCandidate === \"object\" ? (configCandidate as CommentRendererConfig) : {};\n      baseSettings = normalizeSettings(cloneDefaultSettings());\n    }\n\n    this._settings = normalizeSettings(baseSettings);\n    this.timeSource = config.timeSource ?? createDefaultTimeSource();\n    this.animationFrameProvider =\n      config.animationFrameProvider ?? createDefaultAnimationFrameProvider(this.timeSource);\n    this.createCanvasElement = config.createCanvasElement ?? createBrowserCanvasFactory();\n    this.commentDependencies = {\n      timeSource: this.timeSource,\n      settingsVersion: this.settingsVersion,\n    };\n    this.log = createLogger(config.loggerNamespace ?? \"CommentRenderer\");\n    this.eventHooks = config.eventHooks ?? {};\n\n    this.handleAnimationFrame = this.handleAnimationFrame.bind(this);\n    this.handleVideoFrame = this.handleVideoFrame.bind(this);\n\n    this.rebuildNgMatchers();\n\n    if (config.debug) {\n      configureDebugLogging(config.debug);\n    }\n  }\n\n  get settings(): RendererSettings {\n    return this._settings;\n  }\n\n  set settings(value: RendererSettings) {\n    this._settings = normalizeSettings(value);\n    this.settingsVersion += 1;\n    this.commentDependencies.settingsVersion = this.settingsVersion;\n    this.rebuildNgMatchers();\n  }\n\n  getVideoElement(): HTMLVideoElement | null {\n    return this.videoElement;\n  }\n\n  getCurrentVideoSource(): string | null {\n    const video = this.videoElement;\n    if (!video) {\n      return null;\n    }\n    if (typeof video.currentSrc === \"string\" && video.currentSrc.length > 0) {\n      return video.currentSrc;\n    }\n    const attribute = video.getAttribute(\"src\");\n    if (attribute && attribute.length > 0) {\n      return attribute;\n    }\n    const sourceElement = video.querySelector(\"source[src]\") as HTMLSourceElement | null;\n    if (sourceElement && typeof sourceElement.src === \"string\") {\n      return sourceElement.src;\n    }\n    return null;\n  }\n\n  getCommentsSnapshot(): Comment[] {\n    return [...this.comments];\n  }\n}\n\nregisterCommentCollectionMethods(CommentRenderer);\nregisterFinalPhaseMethods(CommentRenderer);\nregisterPlaybackHelpers(CommentRenderer);\nregisterActivationMethods(CommentRenderer);\nregisterLanePruneMethods(CommentRenderer);\nregisterLaneStaticMethods(CommentRenderer);\nregisterLaneActivationMethods(CommentRenderer);\nregisterLaneReservationMethods(CommentRenderer);\nregisterRenderMethods(CommentRenderer);\nregisterTimingMethods(CommentRenderer);\nregisterLifecycleCoreMethods(CommentRenderer);\nregisterLifecycleVideoMethods(CommentRenderer);\nregisterVisibilityMethods(CommentRenderer);\nregisterResizeMethods(CommentRenderer);\nregisterFullscreenMethods(CommentRenderer);\nregisterCleanupMethods(CommentRenderer);\n"],"names":["COMMENT_SIZE_SCALE","FONT_FAMILY_MAP","COLOR_COMMAND_MAP","HEX_COLOR_REGEX","COMMAND_PREFIX_STRIP_REGEX","COMMAND_SUFFIX_STRIP_REGEX","normalizeCommandToken","value","trimmed","normalizeHexColor","command","parseNumericCommandValue","withoutPx","parsed","parseLineHeightValue","numeric","clampLetterSpacing","clampLineHeight","isLayoutCommand","isSizeCommand","isFontCommand","isColorCommand","parseCommentCommands","commands","context","layout","size","font","colorOverride","opacityMultiplier","opacityOverride","isInvisible","letterSpacing","lineHeight","rawCommand","normalizedToken","normalized","lower","separatorIndex","numericValue","clampedOpacityMultiplier","resolvedColor","resolvedOpacityOverride","HEX_COLOR_PATTERN","expandHex","fragment","parseHexComponent","component","clampOpacity","resolveFillStyleWithOpacity","color","opacity","match","body","red","green","blue","alpha","combinedAlpha","createPerformanceTimeSource","createDefaultTimeSource","toMilliseconds","seconds","sanitizeVposMs","MAX_VISIBLE_DURATION_MS","MIN_VISIBLE_DURATION_MS","MAX_COMMENT_WIDTH_RATIO","COLLISION_BUFFER_RATIO","BASE_COLLISION_BUFFER_PX","ENTRY_BUFFER_PX","RESERVATION_TIME_MARGIN_MS","FINAL_PHASE_THRESHOLD_MS","FINAL_PHASE_MIN_GAP_MS","FINAL_PHASE_MAX_GAP_MS","FINAL_PHASE_ORDER_EPSILON_MS","FINAL_PHASE_MIN_WINDOW_MS","STATIC_VISIBLE_DURATION_MS","ACTIVE_WINDOW_MS","VIRTUAL_CANVAS_EXTENSION_PX","MIN_LANE_COUNT","DEFAULT_LANE_COUNT","MIN_FONT_SIZE_PX","EDGE_EPSILON","SEEK_DIRECTION_EPSILON_MS","STATIC_COMMENT_EDGE_PADDING_PX","STATIC_COMMENT_STACKING_PADDING_PX","STATIC_COMMENT_SIDE_MARGIN_PX","MIN_STATIC_FONT_SIZE_PX","AUTO_HARD_RESET_DEDUP_WINDOW_MS","AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS","LEVEL_PRIORITY","fallbackEmitter","level","namespace","args","consoleArgs","createLogger","options","emitter","threshold","emit","logLevel","messages","commentLogger","textMeasurementCaches","getTextMeasurementCache","ctx","cache","measureTextWidth","text","cacheKey","cached","width","ensureLines","rawLines","clampFontSize","updateTextMetrics","comment","maxLineWidth","effectiveLetterSpacing","line","baseWidth","extraSpacing","totalWidth","computedLineHeightPx","additionalHeight","prepareComment","visibleWidth","canvasHeight","safeVisibleWidth","baseFontSize","scaledFontSize","isStaticTopOrBottom","maxStaticWidth","minimumFontSize","shrinkFactor","initialShrink","iteration","currentShrink","proposedSize","margin","centeredX","maxStart","clampedX","maxReservationWidth","bufferFromWidth","entryBuffer","direction","startLeft","exitLeft","trailingBoundary","trailingEdgeAtStart","widthRatio","hasFixedDuration","visibleDurationMs","clampedRatio","adjustedDuration","visibleDistance","safeVisibleDuration","pixelsPerMs","pixelsPerFrame","travelDistance","preCollisionDistance","safePixelsPerMs","reservationBase","error","logger","DEFAULT_MAX_LOGS_PER_CATEGORY","state","categoryCounters","normalizeLimit","limit","rounded","configureDebugLogging","resetDebugCounters","isDebugLoggingEnabled","shouldEmitLog","category","currentCount","debugLog","payload","formatCommentPreview","maxLength","dumpRendererState","label","snapshot","logEpochChange","previousEpochId","newEpochId","reason","cacheStats","reportCacheStats","now","total","hitRate","avgCharsPerComment","totalOutlineCalls","totalFillCalls","isOffscreenCanvasSupported","getShadowParams","intensity","fontSize","baseOpacity","blurRatio","alphaMultiplier","blur","createSegmentDrawer","targetCtx","measurementCtx","statsTarget","baseDrawX","baselineY","mode","offsetX","effectiveDrawX","recordDraw","cursorX","index","char","advance","generateTextureCacheKey","createTextureCanvas","hasLetterSpacing","isMultiLine","padding","textureWidth","textureHeight","offscreen","offscreenCtx","effectiveOpacity","drawX","linesToRender","lineAdvance","baselineStart","drawSegment","resolvedFillStyle","shadowParams","baseline","drawWithFallback","interpolatedX","drawComment","currentCacheKey","cachedTexture","created","texture","resolveScrollDirection","input","getDirectionSign","Comment","vposMs","settings","dependencies","parsedCommands","playbackRate","isPaused","currentTime","deltaTime","settingsVersion","defaultColor","candidate","defaultOpacity","scaled","atTimeMs","currentTimeMs","resolved","NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS","BASE_SETTINGS","DEFAULT_RENDERER_SETTINGS","cloneDefaultSettings","COMMENT_OVERLAY_VERSION","calculateStaticCommentVerticalPadding","_fontSize","laneIndex","normalizeSettings","rawDuration","normalizedDuration","createDefaultAnimationFrameProvider","timeSource","callback","handle","createBrowserCanvasFactory","isRendererSettings","addCommentsImpl","entries","addedComments","entry","preview","normalizedVposMs","a","b","vposMsDiff","addCommentImpl","clearCommentsImpl","effectiveDpr","height","resetStateImpl","rebuildNgMatchersImpl","ngWords","word","sourcePatterns","isNgCommentImpl","regexp","registerCommentCollectionMethods","ctor","hardResetImpl","canvas","effectiveWidth","effectiveHeight","resetFinalPhaseStateImpl","incrementEpochImpl","info","emitStateSnapshotImpl","getEffectiveCommentVposImpl","getFinalPhaseDisplayDurationImpl","durations","resolveFinalPhaseVposImpl","override","fallback","recomputeFinalPhaseTimelineImpl","windowStart","durationMs","windowEnd","candidates","diff","baseGap","boundedGap","gap","nextStart","durationNeeded","availableLatestStart","assigned","epsilon","spacing","registerFinalPhaseMethods","shouldSuppressRenderingImpl","updatePlaybackProgressStateImpl","registerPlaybackHelpers","updateCommentsImpl","frameTimeMs","video","referenceTime","prepareOptions","isNearEnd","effectiveVpos","isPastWindow","isFutureWindow","activeWindowComments","debugActive","staticPosition","buildPrepareOptionsImpl","overrideDuration","maxVisibleDurationMs","minVisibleDurationMs","findAvailableLaneImpl","laneCandidates","newReservation","lane","fallbackLane","registerActivationMethods","findFirstValidReservationIndexImpl","reservations","cutoffTime","left","right","mid","reservation","pruneLaneReservationsImpl","firstValidIndex","pruneStaticLaneReservationsImpl","filterValid","topFiltered","bottomFiltered","registerLanePruneMethods","findCommentIndexAtOrAfterImpl","targetVposMs","getCommentsInTimeWindowImpl","centerTimeMs","windowMs","startTime","endTime","startIndex","result","i","getStaticReservationsImpl","position","getStaticLaneDepthImpl","getStaticLaneLimitImpl","otherPosition","otherDepth","available","getGlobalLaneIndexForBottomImpl","localIndex","resolveStaticCommentOffsetImpl","displayHeight","commentHeight","edgePadding","stackPadding","cumulativeY","laneSortedReservations","r","reservedHeight","maxY","adjustedY","getStaticReservedLaneSetImpl","reserved","registerLaneStaticMethods","shouldActivateCommentAtTimeImpl","timeMs","activateCommentImpl","displayWidth","elapsedMs","displacement","videoDuration","finalPhaseWindowEnd","totalTravelDistance","projectedTravelMs","remainingTime","allowedTravel","startX","laneHeight","laneY","verticalOffset","displayEnd","assignStaticLaneImpl","laneCount","laneIndices","_","yOffset","yStart","yEnd","earliestRelease","reserveStaticLaneImpl","releaseTime","releaseStaticLaneImpl","registerLaneActivationMethods","getLanePriorityOrderImpl","sorted","nextA","nextB","staticReserved","preferred","blocked","getLaneNextAvailableTimeImpl","validIndex","createLaneReservationImpl","speed","effectiveStart","baseStartTime","totalEndTime","isLaneAvailableImpl","storeLaneReservationImpl","updated","areReservationsConflictingImpl","overlapStart","overlapEnd","evaluationTimes","forwardIntersection","backwardIntersection","time","forwardGap","backwardGap","computeForwardGapImpl","from","to","fromEdges","toEdges","getBufferedEdgesImpl","elapsed","rawLeft","solveLeftRightEqualityTimeImpl","leftSign","rightSign","denominator","registerLaneReservationMethods","drawImpl","activeComments","aVpos","bVpos","performInitialSyncImpl","absoluteTime","registerRenderMethods","processFrameImpl","handleAnimationFrameImpl","pendingId","handleVideoFrameImpl","_now","metadata","mediaTime","shouldUseVideoFrameCallbackImpl","scheduleNextFrameImpl","request","cancelAnimationFrameRequestImpl","cancelVideoFrameCallbackImpl","startAnimationImpl","stopAnimationImpl","onSeekImpl","nextTime","timeDelta","isSignificantSeek","registerTimingMethods","shouldAutoHardReset","renderer","requestAutoHardReset","scheduleInitialPlaybackAutoReset","resetInitialPlaybackAutoResetState","resolveContainerImpl","explicit","ensureContainerPositioningImpl","container","initializeImpl","containerCandidate","parent","destroyImpl","destroyCanvasOnlyImpl","registerLifecycleCoreMethods","setupVideoEventListenersImpl","videoElement","onPlay","wasPlaying","onPause","onSeeking","onSeeked","onRateChange","onLoadedMetadata","onDurationChange","onEmptied","onWaiting","onCanPlay","onPlaying","handleVideoMetadataLoadedImpl","handleVideoStalledImpl","handleVideoCanPlayImpl","handleVideoSourceChangeImpl","target","currentSource","syncVideoStateImpl","resetCommentActivityImpl","setupVideoChangeDetectionImpl","videoObserver","mutations","mutation","targetNode","previous","current","node","containerObserver","nextVideo","removedVideo","extractVideoElementImpl","registerLifecycleVideoMethods","setupVisibilityHandlingImpl","enforceVisibilityState","handleVisibilityRestoreImpl","registerVisibilityMethods","resizeImpl","rect","currentDpr","fallbackWidth","fallbackHeight","measuredWidth","measuredHeight","cssWidth","cssHeight","previousDisplayWidth","previousDisplayHeight","nextDpr","pixelWidth","pixelHeight","scaleX","scaleY","resolveDevicePixelRatioImpl","ratio","calculateLaneMetricsImpl","baseHeight","availableLanes","desired","clamped","setupResizeHandlingImpl","observer","onResize","cleanupResizeHandlingImpl","registerResizeMethods","setupFullscreenHandlingImpl","onFullscreenChange","eventName","resolveResizeObserverTargetImpl","fullscreenContainer","handleFullscreenChangeImpl","baseContainer","fullscreenElement","nextContainer","isFullscreenNow","resolveFullscreenContainerImpl","resolveActiveOverlayContainerImpl","getFullscreenElementImpl","doc","registerFullscreenMethods","addCleanupImpl","task","runCleanupTasksImpl","registerCleanupMethods","CommentRenderer","settingsOrConfig","maybeConfig","baseSettings","config","configCandidate","attribute","sourceElement"],"mappings":"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"}