{"version":3,"file":"comment-overlay.es.js","sources":["../src/shared/logger.ts","../src/core/comment-commands.ts","../src/shared/debug.ts","../src/core/comment.ts","../src/config/default-settings.ts","../src/core/comment-renderer.ts"],"sourcesContent":["export type LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nexport interface Logger {\n  debug: (...messages: unknown[]) => void;\n  info: (...messages: unknown[]) => void;\n  warn: (...messages: unknown[]) => void;\n  error: (...messages: unknown[]) => void;\n}\n\nexport interface LoggerOptions {\n  level?: LogLevel;\n  emitter?: (level: LogLevel, namespace: string, args: unknown[]) => void;\n}\n\nconst LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nconst fallbackEmitter = (level: LogLevel, namespace: string, args: unknown[]): void => {\n  const prefix = `[${namespace}]`;\n  const consoleArgs: unknown[] = [prefix, ...args];\n  switch (level) {\n    case \"debug\":\n      console.debug(...consoleArgs);\n      break;\n    case \"info\":\n      console.info(...consoleArgs);\n      break;\n    case \"warn\":\n      console.warn(...consoleArgs);\n      break;\n    case \"error\":\n      console.error(...consoleArgs);\n      break;\n    default:\n      console.log(...consoleArgs);\n  }\n};\n\nexport const createLogger = (namespace: string, options: LoggerOptions = {}): Logger => {\n  const { level = \"info\", emitter = fallbackEmitter } = options;\n  const threshold = LEVEL_PRIORITY[level];\n\n  const emit = (logLevel: LogLevel, args: unknown[]): void => {\n    if (LEVEL_PRIORITY[logLevel] < threshold) {\n      return;\n    }\n    emitter(logLevel, namespace, args);\n  };\n\n  return {\n    debug: (...messages: unknown[]) => emit(\"debug\", messages),\n    info: (...messages: unknown[]) => emit(\"info\", messages),\n    warn: (...messages: unknown[]) => emit(\"warn\", messages),\n    error: (...messages: unknown[]) => emit(\"error\", messages),\n  };\n};\n","import {\n  type CommentColorCommand,\n  type CommentCommandParseContext,\n  type CommentCommandParseResult,\n  type CommentFontCommand,\n  type CommentHexColorCommand,\n  type CommentLayoutCommand,\n  type CommentSizeCommand,\n} from \"../shared/types\";\n\nconst COMMENT_SIZE_SCALE: Record<CommentSizeCommand, number> = {\n  small: 0.8,\n  medium: 1,\n  big: 1.4,\n};\n\nconst FONT_FAMILY_MAP: Record<CommentFontCommand, string> = {\n  defont:\n    '\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Hiragino Kaku Gothic Pro\",\"Yu Gothic UI\",\"Yu Gothic\",\"Meiryo\",\"Segoe UI\",\"Osaka\",\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"IPAPGothic\",\"TakaoPGothic\",\"Roboto\",\"Helvetica Neue\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  gothic:\n    '\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"Yu Gothic\",\"Yu Gothic Medium\",\"Meiryo\",\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Segoe UI\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  mincho:\n    '\"MS PMincho\",\"MS Mincho\",\"Hiragino Mincho ProN\",\"Hiragino Mincho Pro\",\"Yu Mincho\",\"Noto Serif CJK JP\",\"Noto Serif JP\",\"Source Han Serif JP\",\"Times New Roman\",\"serif\"',\n};\n\nconst COLOR_COMMAND_MAP: Record<CommentColorCommand, string> = {\n  white: \"#FFFFFF\",\n  red: \"#FF0000\",\n  pink: \"#FF8080\",\n  orange: \"#FF9900\",\n  yellow: \"#FFFF00\",\n  green: \"#00FF00\",\n  cyan: \"#00FFFF\",\n  blue: \"#0000FF\",\n  purple: \"#C000FF\",\n  black: \"#000000\",\n  white2: \"#CC9\",\n  red2: \"#C03\",\n  pink2: \"#F3C\",\n  orange2: \"#F60\",\n  yellow2: \"#990\",\n  green2: \"#0C6\",\n  cyan2: \"#0CC\",\n  blue2: \"#39F\",\n  purple2: \"#63C\",\n  black2: \"#666\",\n};\n\nconst HEX_COLOR_REGEX = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;\n\nconst COMMAND_PREFIX_STRIP_REGEX = /^[,.:;]+/;\nconst COMMAND_SUFFIX_STRIP_REGEX = /[,.:;]+$/;\n\nconst normalizeCommandToken = (value: string): string => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return \"\";\n  }\n  if (HEX_COLOR_REGEX.test(trimmed)) {\n    return trimmed;\n  }\n  const withoutPrefix = trimmed.replace(COMMAND_PREFIX_STRIP_REGEX, \"\");\n  const withoutSuffix = withoutPrefix.replace(COMMAND_SUFFIX_STRIP_REGEX, \"\");\n  return withoutSuffix;\n};\n\nconst normalizeHexColor = (command: CommentHexColorCommand): string | null => {\n  if (!HEX_COLOR_REGEX.test(command)) {\n    return null;\n  }\n  return command.toUpperCase();\n};\n\nconst parseNumericCommandValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  const withoutPx = trimmed.toLowerCase().endsWith(\"px\") ? trimmed.slice(0, -2) : trimmed;\n  const parsed = Number.parseFloat(withoutPx);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst parseLineHeightValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  if (trimmed.endsWith(\"%\")) {\n    const numeric = Number.parseFloat(trimmed.slice(0, -1));\n    if (!Number.isFinite(numeric)) {\n      return null;\n    }\n    return numeric / 100;\n  }\n  return parseNumericCommandValue(trimmed);\n};\n\nconst clampLetterSpacing = (value: number): number => {\n  const maxSpacing = 100;\n  const minSpacing = -100;\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  return Math.min(maxSpacing, Math.max(minSpacing, value));\n};\n\nconst clampLineHeight = (value: number): number => {\n  const minHeight = 0.25;\n  const maxHeight = 5;\n  if (!Number.isFinite(value) || value === 0) {\n    return 1;\n  }\n  return Math.min(maxHeight, Math.max(minHeight, value));\n};\n\nconst isLayoutCommand = (command: string): command is CommentLayoutCommand =>\n  command === \"naka\" || command === \"ue\" || command === \"shita\";\n\nconst isSizeCommand = (command: string): command is CommentSizeCommand =>\n  command === \"small\" || command === \"medium\" || command === \"big\";\n\nconst isFontCommand = (command: string): command is CommentFontCommand =>\n  command === \"defont\" || command === \"gothic\" || command === \"mincho\";\n\nconst isColorCommand = (command: string): command is CommentColorCommand =>\n  command in COLOR_COMMAND_MAP;\n\nexport const parseCommentCommands = (\n  commands: readonly string[],\n  context: CommentCommandParseContext,\n): CommentCommandParseResult => {\n  let layout: CommentLayoutCommand = \"naka\";\n  let size: CommentSizeCommand = \"medium\";\n  let font: CommentFontCommand = \"defont\";\n  let colorOverride: string | null = null;\n  let opacityMultiplier = 1;\n  let opacityOverride: number | null = null;\n  let isInvisible = false;\n  let letterSpacing = 0;\n  let lineHeight = 1;\n\n  for (const rawCommand of commands) {\n    const normalizedToken = normalizeCommandToken(typeof rawCommand === \"string\" ? rawCommand : \"\");\n    if (!normalizedToken) {\n      continue;\n    }\n\n    if (HEX_COLOR_REGEX.test(normalizedToken)) {\n      const normalized = normalizeHexColor(normalizedToken as CommentHexColorCommand);\n      if (normalized) {\n        colorOverride = normalized;\n        continue;\n      }\n    }\n\n    const lower = normalizedToken.toLowerCase();\n\n    if (isLayoutCommand(lower)) {\n      layout = lower;\n      continue;\n    }\n\n    if (isSizeCommand(lower)) {\n      size = lower;\n      continue;\n    }\n\n    if (isFontCommand(lower)) {\n      font = lower;\n      continue;\n    }\n\n    if (isColorCommand(lower)) {\n      colorOverride = COLOR_COMMAND_MAP[lower].toUpperCase();\n      continue;\n    }\n\n    if (lower === \"_live\") {\n      opacityOverride = 0.5;\n      continue;\n    }\n\n    if (lower === \"invisible\") {\n      opacityMultiplier = 0;\n      isInvisible = true;\n      continue;\n    }\n\n    if (lower.startsWith(\"ls:\") || lower.startsWith(\"letterspacing:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseNumericCommandValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          letterSpacing = clampLetterSpacing(numericValue);\n        }\n      }\n      continue;\n    }\n\n    if (lower.startsWith(\"lh:\") || lower.startsWith(\"lineheight:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseLineHeightValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          lineHeight = clampLineHeight(numericValue);\n        }\n      }\n      continue;\n    }\n  }\n\n  const clampedOpacityMultiplier = Math.max(0, Math.min(1, opacityMultiplier));\n  const resolvedColor = (colorOverride ?? context.defaultColor).toUpperCase();\n  const resolvedOpacityOverride =\n    typeof opacityOverride === \"number\" ? Math.max(0, Math.min(1, opacityOverride)) : null;\n\n  return {\n    layout,\n    size,\n    sizeScale: COMMENT_SIZE_SCALE[size],\n    font,\n    fontFamily: FONT_FAMILY_MAP[font],\n    resolvedColor,\n    colorOverride,\n    opacityMultiplier: clampedOpacityMultiplier,\n    opacityOverride: resolvedOpacityOverride,\n    isInvisible,\n    letterSpacing,\n    lineHeight,\n  };\n};\n","const DEFAULT_MAX_LOGS_PER_CATEGORY = 5;\n\nexport interface DebugLoggingOptions {\n  readonly enabled: boolean;\n  readonly maxLogsPerCategory?: number;\n}\n\ntype DebugState = {\n  enabled: boolean;\n  maxLogsPerCategory: number;\n};\n\nconst state: DebugState = {\n  enabled: false,\n  maxLogsPerCategory: DEFAULT_MAX_LOGS_PER_CATEGORY,\n};\n\nconst categoryCounters = new Map<string, number>();\n\nconst normalizeLimit = (limit: number | undefined): number => {\n  if (limit === undefined) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  if (!Number.isFinite(limit)) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  const rounded = Math.max(1, Math.floor(limit));\n  return Math.min(10_000, rounded);\n};\n\nexport const configureDebugLogging = (options: DebugLoggingOptions): void => {\n  state.enabled = Boolean(options.enabled);\n  state.maxLogsPerCategory = normalizeLimit(options.maxLogsPerCategory);\n  if (!state.enabled) {\n    categoryCounters.clear();\n  }\n};\n\nexport const resetDebugCounters = (): void => {\n  categoryCounters.clear();\n};\n\nexport const isDebugLoggingEnabled = (): boolean => state.enabled;\n\nconst shouldEmitLog = (category: string): boolean => {\n  const currentCount = categoryCounters.get(category) ?? 0;\n  if (currentCount >= state.maxLogsPerCategory) {\n    if (currentCount === state.maxLogsPerCategory) {\n      console.debug(`[CommentOverlay][${category}]`, \"Further logs suppressed.\");\n      categoryCounters.set(category, currentCount + 1);\n    }\n    return false;\n  }\n  categoryCounters.set(category, currentCount + 1);\n  return true;\n};\n\nexport const debugLog = (category: string, ...payload: unknown[]): void => {\n  if (!state.enabled) {\n    return;\n  }\n  if (!shouldEmitLog(category)) {\n    return;\n  }\n  console.debug(`[CommentOverlay][${category}]`, ...payload);\n};\n\nexport const formatCommentPreview = (text: string, maxLength = 32): string => {\n  if (text.length <= maxLength) {\n    return text;\n  }\n  return `${text.slice(0, maxLength)}…`;\n};\n\n// ゴーストコメント可視化\nexport const visualizeGhostComments = (\n  ghosts: Array<{\n    text: string;\n    vposMs: number;\n    epochId: number;\n    reason: string;\n  }>,\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  if (ghosts.length === 0) {\n    return;\n  }\n  console.group(`[CommentOverlay][ghost-detection] Detected ${ghosts.length} ghost comment(s)`);\n  ghosts.forEach((ghost, index) => {\n    console.log(\n      `#${index + 1}:`,\n      `\"${formatCommentPreview(ghost.text)}\"`,\n      `vpos=${ghost.vposMs}ms`,\n      `epoch=${ghost.epochId}`,\n      `reason=${ghost.reason}`,\n    );\n  });\n  console.groupEnd();\n};\n\n// 内部状態ダンプ\nexport const dumpRendererState = (\n  label: string,\n  snapshot: {\n    currentTime: number;\n    duration: number;\n    isPlaying: boolean;\n    epochId: number;\n    totalComments: number;\n    activeComments: number;\n    reservedLanes: number;\n    finalPhaseActive: boolean;\n    playbackHasBegun: boolean;\n    isStalled: boolean;\n  },\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  console.group(`[CommentOverlay][state-dump] ${label}`);\n  console.table({\n    \"Current Time\": `${snapshot.currentTime.toFixed(2)}ms`,\n    Duration: `${snapshot.duration.toFixed(2)}ms`,\n    \"Is Playing\": snapshot.isPlaying,\n    \"Epoch ID\": snapshot.epochId,\n    \"Total Comments\": snapshot.totalComments,\n    \"Active Comments\": snapshot.activeComments,\n    \"Reserved Lanes\": snapshot.reservedLanes,\n    \"Final Phase\": snapshot.finalPhaseActive,\n    \"Playback Begun\": snapshot.playbackHasBegun,\n    \"Is Stalled\": snapshot.isStalled,\n  });\n  console.groupEnd();\n};\n\n// エポック変更のログ\nexport const logEpochChange = (\n  previousEpochId: number,\n  newEpochId: number,\n  reason: string,\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  debugLog(\"epoch-change\", `Epoch changed: ${previousEpochId} → ${newEpochId} (reason: ${reason})`);\n};\n","import type {\n  CommentLayoutCommand,\n  RenderStyle,\n  RendererSettings,\n  ScrollDirection,\n} from \"../shared/types\";\nimport { createLogger } from \"../shared/logger\";\nimport { parseCommentCommands } from \"./comment-commands\";\nimport { isDebugLoggingEnabled } from \"../shared/debug\";\n\nconst logger = createLogger(\"CommentEngine:Comment\");\n\ntype TextMeasurementCache = Map<string, number>;\ntype DrawMode = \"fill\" | \"outline\";\n\nconst textMeasurementCaches = new WeakMap<CanvasRenderingContext2D, TextMeasurementCache>();\n\nconst getTextMeasurementCache = (ctx: CanvasRenderingContext2D): TextMeasurementCache => {\n  let cache = textMeasurementCaches.get(ctx);\n  if (!cache) {\n    cache = new Map();\n    textMeasurementCaches.set(ctx, cache);\n  }\n  return cache;\n};\n\nconst measureTextWidth = (ctx: CanvasRenderingContext2D, text: string): number => {\n  if (!ctx) {\n    return 0;\n  }\n  const fontKey = ctx.font ?? \"\";\n  const cacheKey = `${fontKey}::${text}`;\n  const cache = getTextMeasurementCache(ctx);\n  const cached = cache.get(cacheKey);\n  if (cached !== undefined) {\n    return cached;\n  }\n  const width = ctx.measureText(text).width;\n  cache.set(cacheKey, width);\n  return width;\n};\n\nexport const STATIC_VISIBLE_DURATION_MS = 4_000;\n\nconst HEX_COLOR_PATTERN = /^#([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;\n\nconst STATIC_COMMENT_SIDE_MARGIN_PX = 8;\nconst MIN_STATIC_FONT_SIZE_PX = 12;\n\nconst clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nconst expandHex = (fragment: string): string =>\n  fragment.length === 1 ? fragment.repeat(2) : fragment;\n\nconst parseHexComponent = (component: string): number => Number.parseInt(component, 16);\n\nconst resolveFillStyleWithOpacity = (color: string, opacity: number): string => {\n  const match = HEX_COLOR_PATTERN.exec(color);\n  if (!match) {\n    return color;\n  }\n  const body = match[1];\n  let red: number;\n  let green: number;\n  let blue: number;\n  let alpha = 1;\n\n  if (body.length === 3 || body.length === 4) {\n    red = parseHexComponent(expandHex(body[0]));\n    green = parseHexComponent(expandHex(body[1]));\n    blue = parseHexComponent(expandHex(body[2]));\n    if (body.length === 4) {\n      alpha = parseHexComponent(expandHex(body[3])) / 255;\n    }\n  } else {\n    red = parseHexComponent(body.slice(0, 2));\n    green = parseHexComponent(body.slice(2, 4));\n    blue = parseHexComponent(body.slice(4, 6));\n    if (body.length === 8) {\n      alpha = parseHexComponent(body.slice(6, 8)) / 255;\n    }\n  }\n\n  const combinedAlpha = clampOpacity(alpha * clampOpacity(opacity));\n  return `rgba(${red}, ${green}, ${blue}, ${combinedAlpha})`;\n};\n\nexport interface TimeSource {\n  now(): number;\n}\n\nconst createPerformanceTimeSource = (): TimeSource => ({\n  now: () => {\n    if (typeof performance !== \"undefined\" && typeof performance.now === \"function\") {\n      return performance.now();\n    }\n    return Date.now();\n  },\n});\n\nexport const createDefaultTimeSource = (): TimeSource => createPerformanceTimeSource();\n\nexport interface CommentDependencies {\n  timeSource?: TimeSource;\n  settingsVersion?: number;\n}\n\nconst resolveScrollDirection = (input: ScrollDirection | string): ScrollDirection =>\n  input === \"ltr\" ? \"ltr\" : \"rtl\";\n\nconst getDirectionSign = (direction: ScrollDirection): -1 | 1 => (direction === \"ltr\" ? 1 : -1);\n\nexport interface CommentPrepareOptions {\n  visibleWidth: number;\n  virtualExtension: number;\n  maxVisibleDurationMs: number;\n  minVisibleDurationMs: number;\n  maxWidthRatio: number;\n  bufferRatio: number;\n  baseBufferPx: number;\n  entryBufferPx: number;\n}\n\nexport class Comment {\n  readonly text: string;\n  readonly vposMs: number;\n  readonly commands: string[];\n  readonly layout: CommentLayoutCommand;\n  readonly isScrolling: boolean;\n  readonly sizeScale: number;\n  readonly opacityMultiplier: number;\n  readonly opacityOverride: number | null;\n  readonly colorOverride: string | null;\n  readonly isInvisible: boolean;\n\n  x = 0;\n  y = 0;\n  width = 0;\n  height = 0;\n  baseSpeed = 0;\n  speed = 0;\n  lane = -1;\n  color: string;\n  fontSize = 0;\n  fontFamily: string;\n  opacity: number;\n  activationTimeMs: number | null = null;\n  staticExpiryTimeMs: number | null = null;\n  isActive = false;\n  hasShown = false;\n  isPaused = false;\n  lastUpdateTime = 0;\n  reservationWidth = 0;\n  bufferWidth = 0;\n  visibleDurationMs = 0;\n  totalDurationMs = 0;\n  preCollisionDurationMs = 0;\n  speedPixelsPerMs = 0;\n  virtualStartX = 0;\n  exitThreshold = 0;\n  scrollDirection: ScrollDirection = \"rtl\";\n  renderStyle: RenderStyle = \"outline-only\";\n  creationIndex = 0;\n  letterSpacing = 0;\n  lineHeightMultiplier = 1;\n  lineHeightPx = 0;\n  lines: string[] = [];\n  epochId = 0;\n  private directionSign: -1 | 1 = -1;\n  private readonly timeSource: TimeSource;\n  private lastSyncedSettingsVersion = -1;\n  private cachedTexture: OffscreenCanvas | null = null;\n  private textureCacheKey = \"\";\n\n  constructor(\n    text: string,\n    vposMs: number,\n    commands: string[] | undefined,\n    settings: RendererSettings,\n    dependencies: CommentDependencies = {},\n  ) {\n    if (typeof text !== \"string\") {\n      throw new Error(\"Comment text must be a string\");\n    }\n    if (!Number.isFinite(vposMs) || vposMs < 0) {\n      throw new Error(\"Comment vposMs must be a non-negative number\");\n    }\n\n    this.text = text;\n    this.vposMs = vposMs;\n    this.commands = Array.isArray(commands) ? [...commands] : [];\n\n    const parsedCommands = parseCommentCommands(this.commands, {\n      defaultColor: settings.commentColor,\n    });\n\n    this.layout = parsedCommands.layout;\n    this.isScrolling = this.layout === \"naka\";\n    this.sizeScale = parsedCommands.sizeScale;\n    this.opacityMultiplier = parsedCommands.opacityMultiplier;\n    this.opacityOverride = parsedCommands.opacityOverride;\n    this.colorOverride = parsedCommands.colorOverride;\n    this.isInvisible = parsedCommands.isInvisible;\n    this.fontFamily = parsedCommands.fontFamily;\n    this.color = parsedCommands.resolvedColor;\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.renderStyle = settings.renderStyle;\n    this.letterSpacing = parsedCommands.letterSpacing;\n    this.lineHeightMultiplier = parsedCommands.lineHeight;\n\n    this.timeSource = dependencies.timeSource ?? createDefaultTimeSource();\n    this.applyScrollDirection(settings.scrollDirection);\n    this.syncWithSettings(settings, dependencies.settingsVersion);\n  }\n\n  prepare(\n    ctx: CanvasRenderingContext2D,\n    visibleWidth: number,\n    canvasHeight: number,\n    options: CommentPrepareOptions,\n  ): void {\n    try {\n      if (!ctx) {\n        throw new Error(\"Canvas context is required\");\n      }\n      if (!Number.isFinite(visibleWidth) || !Number.isFinite(canvasHeight)) {\n        throw new Error(\"Canvas dimensions must be numbers\");\n      }\n      if (!options) {\n        throw new Error(\"Prepare options are required\");\n      }\n\n      const safeVisibleWidth = Math.max(visibleWidth, 1);\n      const baseFontSize = Math.max(24, Math.floor(canvasHeight * 0.05));\n      const scaledFontSize = Math.max(24, Math.floor(baseFontSize * this.sizeScale));\n      this.fontSize = scaledFontSize;\n      ctx.font = `${this.fontSize}px ${this.fontFamily}`;\n      const rawLines = this.text.includes(\"\\n\") ? this.text.split(/\\r?\\n/) : [this.text];\n      this.lines = rawLines.length > 0 ? rawLines : [\"\"];\n      this.updateTextMetrics(ctx);\n\n      const isStaticTopOrBottom =\n        !this.isScrolling && (this.layout === \"ue\" || this.layout === \"shita\");\n      if (isStaticTopOrBottom) {\n        const maxStaticWidth = Math.max(1, safeVisibleWidth - STATIC_COMMENT_SIDE_MARGIN_PX * 2);\n        if (this.width > maxStaticWidth) {\n          const minimumFontSize = Math.max(\n            MIN_STATIC_FONT_SIZE_PX,\n            Math.min(this.fontSize, Math.floor(baseFontSize * 0.6)),\n          );\n          const shrinkFactor = maxStaticWidth / Math.max(this.width, 1);\n          const initialShrink = Math.max(\n            minimumFontSize,\n            Math.floor(this.fontSize * Math.min(shrinkFactor, 1)),\n          );\n          if (initialShrink < this.fontSize) {\n            this.fontSize = initialShrink;\n            ctx.font = `${this.fontSize}px ${this.fontFamily}`;\n            this.updateTextMetrics(ctx);\n          }\n          let iteration = 0;\n          while (this.width > maxStaticWidth && this.fontSize > minimumFontSize && iteration < 5) {\n            const currentShrink = maxStaticWidth / Math.max(this.width, 1);\n            const proposedSize = Math.max(\n              minimumFontSize,\n              Math.floor(this.fontSize * Math.max(currentShrink, 0.7)),\n            );\n            if (proposedSize >= this.fontSize) {\n              this.fontSize = Math.max(minimumFontSize, this.fontSize - 1);\n            } else {\n              this.fontSize = proposedSize;\n            }\n            ctx.font = `${this.fontSize}px ${this.fontFamily}`;\n            this.updateTextMetrics(ctx);\n            iteration += 1;\n          }\n        }\n      }\n\n      if (!this.isScrolling) {\n        this.bufferWidth = 0;\n        const margin = isStaticTopOrBottom ? STATIC_COMMENT_SIDE_MARGIN_PX : 0;\n        const centeredX = Math.max((safeVisibleWidth - this.width) / 2, margin);\n        const maxStart = Math.max(margin, safeVisibleWidth - this.width - margin);\n        const clampedX = Math.min(centeredX, Math.max(maxStart, margin));\n        this.virtualStartX = clampedX;\n        this.x = clampedX;\n        this.baseSpeed = 0;\n        this.speed = 0;\n        this.speedPixelsPerMs = 0;\n        this.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n        this.preCollisionDurationMs = STATIC_VISIBLE_DURATION_MS;\n        this.totalDurationMs = STATIC_VISIBLE_DURATION_MS;\n        this.reservationWidth = this.width;\n        this.staticExpiryTimeMs = this.vposMs + STATIC_VISIBLE_DURATION_MS;\n        this.lastUpdateTime = this.timeSource.now();\n        this.isPaused = false;\n        return;\n      }\n\n      this.staticExpiryTimeMs = null;\n      const maxReservationWidth = measureTextWidth(ctx, \"??\".repeat(150));\n\n      const bufferFromWidth = this.width * Math.max(options.bufferRatio, 0);\n      this.bufferWidth = Math.max(options.baseBufferPx, bufferFromWidth);\n      const entryBuffer = Math.max(options.entryBufferPx, this.bufferWidth);\n\n      const direction = this.scrollDirection;\n\n      const startLeft =\n        direction === \"rtl\"\n          ? safeVisibleWidth + options.virtualExtension\n          : -this.width - this.bufferWidth - options.virtualExtension;\n      const exitLeft =\n        direction === \"rtl\"\n          ? -this.width - this.bufferWidth - entryBuffer\n          : safeVisibleWidth + entryBuffer;\n      const trailingBoundary = direction === \"rtl\" ? safeVisibleWidth + entryBuffer : -entryBuffer;\n      const trailingEdgeAtStart =\n        direction === \"rtl\"\n          ? startLeft + this.width + this.bufferWidth\n          : startLeft - this.bufferWidth;\n\n      this.virtualStartX = startLeft;\n      this.x = startLeft;\n      this.exitThreshold = exitLeft;\n\n      const widthRatio = safeVisibleWidth > 0 ? this.width / safeVisibleWidth : 0;\n      const hasFixedDuration = options.maxVisibleDurationMs === options.minVisibleDurationMs;\n      let visibleDurationMs = options.maxVisibleDurationMs;\n      if (!hasFixedDuration && widthRatio > 1) {\n        const clampedRatio = Math.min(widthRatio, options.maxWidthRatio);\n        const adjustedDuration = options.maxVisibleDurationMs / Math.max(clampedRatio, 1);\n        visibleDurationMs = Math.max(options.minVisibleDurationMs, Math.floor(adjustedDuration));\n      }\n\n      const visibleDistance = safeVisibleWidth + this.width + this.bufferWidth + entryBuffer;\n      const safeVisibleDuration = Math.max(visibleDurationMs, 1);\n      const pixelsPerMs = visibleDistance / safeVisibleDuration;\n      const pixelsPerFrame = (pixelsPerMs * 1000) / 60;\n      this.baseSpeed = pixelsPerFrame;\n      this.speed = this.baseSpeed;\n      this.speedPixelsPerMs = pixelsPerMs;\n\n      const travelDistance = Math.abs(exitLeft - startLeft);\n      const preCollisionDistance =\n        direction === \"rtl\"\n          ? Math.max(0, trailingEdgeAtStart - trailingBoundary)\n          : Math.max(0, trailingBoundary - trailingEdgeAtStart);\n      const safePixelsPerMs = Math.max(pixelsPerMs, Number.EPSILON);\n\n      this.visibleDurationMs = visibleDurationMs;\n      this.preCollisionDurationMs = Math.max(0, Math.ceil(preCollisionDistance / safePixelsPerMs));\n      this.totalDurationMs = Math.max(\n        this.preCollisionDurationMs,\n        Math.ceil(travelDistance / safePixelsPerMs),\n      );\n\n      const reservationBase = this.width + this.bufferWidth + entryBuffer;\n      this.reservationWidth = Math.min(maxReservationWidth, reservationBase);\n      this.lastUpdateTime = this.timeSource.now();\n      this.isPaused = false;\n    } catch (error) {\n      logger.error(\"Comment.prepare\", error as Error, {\n        text: this.text,\n        visibleWidth,\n        canvasHeight,\n        hasContext: Boolean(ctx),\n      });\n      throw error;\n    }\n  }\n\n  update(playbackRate = 1.0, isPaused = false): void {\n    try {\n      if (!this.isActive) {\n        this.isPaused = isPaused;\n        return;\n      }\n\n      const currentTime = this.timeSource.now();\n\n      if (!this.isScrolling) {\n        this.isPaused = isPaused;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      if (isPaused) {\n        this.isPaused = true;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      const deltaTime = (currentTime - this.lastUpdateTime) / (1000 / 60);\n      this.speed = this.baseSpeed * playbackRate;\n      this.x += this.speed * deltaTime * this.directionSign;\n      const hasExited =\n        (this.scrollDirection === \"rtl\" && this.x <= this.exitThreshold) ||\n        (this.scrollDirection === \"ltr\" && this.x >= this.exitThreshold);\n      if (hasExited) {\n        this.isActive = false;\n      }\n      this.lastUpdateTime = currentTime;\n      this.isPaused = false;\n    } catch (error) {\n      logger.error(\"Comment.update\", error as Error, {\n        text: this.text,\n        playbackRate,\n        isPaused,\n        isActive: this.isActive,\n      });\n    }\n  }\n\n  private generateTextureCacheKey(): string {\n    // v2: 行頭スペース処理を追加したためキャッシュを無効化\n    return `v2::${this.text}::${this.fontSize}::${this.fontFamily}::${this.color}::${this.opacity}::${this.renderStyle}::${this.letterSpacing}::${this.lines.length}`;\n  }\n\n  // デバッグ用：キャッシュ統計\n  private static cacheStats = {\n    hits: 0,\n    misses: 0,\n    creates: 0,\n    fallbacks: 0,\n    outlineCallsInCache: 0,\n    fillCallsInCache: 0,\n    outlineCallsInFallback: 0,\n    fillCallsInFallback: 0,\n    letterSpacingComments: 0,\n    normalComments: 0,\n    multiLineComments: 0,\n    totalCharactersDrawn: 0,\n    lastReported: 0,\n  };\n\n  private static reportCacheStats(): void {\n    if (!isDebugLoggingEnabled()) {\n      return;\n    }\n    const now = performance.now();\n    if (now - Comment.cacheStats.lastReported > 5000) {\n      const total = Comment.cacheStats.hits + Comment.cacheStats.misses;\n      const hitRate = total > 0 ? (Comment.cacheStats.hits / total) * 100 : 0;\n      const avgCharsPerComment =\n        Comment.cacheStats.creates > 0\n          ? (Comment.cacheStats.totalCharactersDrawn / Comment.cacheStats.creates).toFixed(1)\n          : \"0\";\n      const totalOutlineCalls =\n        Comment.cacheStats.outlineCallsInCache + Comment.cacheStats.outlineCallsInFallback;\n      const totalFillCalls =\n        Comment.cacheStats.fillCallsInCache + Comment.cacheStats.fillCallsInFallback;\n      console.log(\n        `[TextureCache Stats]`,\n        `\\n  Cache: Hits=${Comment.cacheStats.hits}, Misses=${Comment.cacheStats.misses}, Hit Rate=${hitRate.toFixed(1)}%`,\n        `\\n  Creates: ${Comment.cacheStats.creates}, Fallbacks: ${Comment.cacheStats.fallbacks}`,\n        `\\n  Comments: Normal=${Comment.cacheStats.normalComments}, LetterSpacing=${Comment.cacheStats.letterSpacingComments}, MultiLine=${Comment.cacheStats.multiLineComments}`,\n        `\\n  Draw Calls: Outline=${totalOutlineCalls}, Fill=${totalFillCalls}`,\n        `\\n  Avg Characters/Comment: ${avgCharsPerComment}`,\n      );\n      Comment.cacheStats.lastReported = now;\n    }\n  }\n\n  private isOffscreenCanvasSupported(): boolean {\n    return typeof OffscreenCanvas !== \"undefined\";\n  }\n\n  private createTextureCanvas(ctx: CanvasRenderingContext2D): OffscreenCanvas | null {\n    if (!this.isOffscreenCanvasSupported()) {\n      return null;\n    }\n\n    // 統計収集\n    const hasLetterSpacing = Math.abs(this.letterSpacing) >= Number.EPSILON;\n    const isMultiLine = this.lines.length > 1;\n    if (hasLetterSpacing) {\n      Comment.cacheStats.letterSpacingComments++;\n    }\n    if (isMultiLine) {\n      Comment.cacheStats.multiLineComments++;\n    }\n    if (!hasLetterSpacing && !isMultiLine) {\n      Comment.cacheStats.normalComments++;\n    }\n    Comment.cacheStats.totalCharactersDrawn += this.text.length;\n\n    // テクスチャサイズは実際のコメントサイズより少し大きめに取る（影やエフェクトのため）\n    const padding = Math.max(10, this.fontSize * 0.5);\n    const textureWidth = Math.ceil(this.width + padding * 2);\n    const textureHeight = Math.ceil(this.height + padding * 2);\n\n    const offscreen = new OffscreenCanvas(textureWidth, textureHeight);\n    const offscreenCtx = offscreen.getContext(\"2d\");\n    if (!offscreenCtx) {\n      return null;\n    }\n\n    // オフスクリーンキャンバスに描画\n    offscreenCtx.save();\n    offscreenCtx.font = `${this.fontSize}px ${this.fontFamily}`;\n    const effectiveOpacity = clampOpacity(this.opacity);\n    const drawX = padding; // パディング分オフセット\n    const linesToRender = this.lines.length > 0 ? this.lines : [this.text];\n    const lineAdvance =\n      this.lines.length > 1 && this.lineHeightPx > 0 ? this.lineHeightPx : this.fontSize;\n    const baselineStart = padding + this.fontSize;\n    const drawSegment = this.createSegmentDrawer(offscreenCtx, ctx, \"cache\", drawX);\n\n    const outlineOffsets = this.getOutlineOffsets();\n\n    const drawOutline = (): void => {\n      const outlineAlpha = clampOpacity(effectiveOpacity * 0.6);\n      offscreenCtx.save();\n      offscreenCtx.fillStyle = `rgba(0, 0, 0, ${outlineAlpha})`;\n      for (const [offsetX, offsetY] of outlineOffsets) {\n        linesToRender.forEach((line, index) => {\n          const baseline = baselineStart + index * lineAdvance + offsetY;\n          drawSegment(line, baseline, \"outline\", offsetX);\n        });\n      }\n      offscreenCtx.restore();\n    };\n\n    const drawFill = (fillStyle: string): void => {\n      offscreenCtx.save();\n      offscreenCtx.fillStyle = fillStyle;\n      linesToRender.forEach((line, index) => {\n        const baseline = baselineStart + index * lineAdvance;\n        drawSegment(line, baseline, \"fill\");\n      });\n      offscreenCtx.restore();\n    };\n\n    drawOutline();\n\n    if (this.renderStyle === \"classic\") {\n      const baseShadowOffset = Math.max(1, this.fontSize * 0.04);\n      const baseShadowBlur = this.fontSize * 0.18;\n      type ShadowLayer = Readonly<{\n        offsetXMultiplier: number;\n        offsetYMultiplier: number;\n        blurMultiplier: number;\n        alpha: number;\n        rgb: string;\n      }>;\n      const shadowLayers: ReadonlyArray<ShadowLayer> = [\n        {\n          offsetXMultiplier: 0.9,\n          offsetYMultiplier: 1.1,\n          blurMultiplier: 0.55,\n          alpha: 0.52,\n          rgb: \"20, 28, 40\",\n        },\n        {\n          offsetXMultiplier: 2.4,\n          offsetYMultiplier: 2.7,\n          blurMultiplier: 1.45,\n          alpha: 0.32,\n          rgb: \"0, 0, 0\",\n        },\n        {\n          offsetXMultiplier: -0.7,\n          offsetYMultiplier: -0.6,\n          blurMultiplier: 0.4,\n          alpha: 0.42,\n          rgb: \"255, 255, 255\",\n        },\n      ];\n\n      shadowLayers.forEach((layer) => {\n        const effectiveShadowAlpha = clampOpacity(layer.alpha * effectiveOpacity);\n        offscreenCtx.save();\n        offscreenCtx.shadowColor = `rgba(${layer.rgb}, ${effectiveShadowAlpha})`;\n        offscreenCtx.shadowBlur = baseShadowBlur * layer.blurMultiplier;\n        offscreenCtx.shadowOffsetX = baseShadowOffset * layer.offsetXMultiplier;\n        offscreenCtx.shadowOffsetY = baseShadowOffset * layer.offsetYMultiplier;\n        offscreenCtx.fillStyle = \"rgba(0, 0, 0, 0)\";\n        linesToRender.forEach((line, index) => {\n          const baseline = baselineStart + index * lineAdvance;\n          drawSegment(line, baseline, \"fill\");\n        });\n        offscreenCtx.restore();\n      });\n    }\n\n    const resolvedFillStyle = resolveFillStyleWithOpacity(this.color, effectiveOpacity);\n    drawFill(resolvedFillStyle);\n\n    offscreenCtx.restore();\n    return offscreen;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, interpolatedX: number | null = null): void {\n    try {\n      if (!this.isActive || !ctx) {\n        return;\n      }\n\n      // テクスチャキャッシュを使用\n      const currentCacheKey = this.generateTextureCacheKey();\n      if (this.textureCacheKey !== currentCacheKey || !this.cachedTexture) {\n        // キャッシュが無効または古い場合は再生成\n        Comment.cacheStats.misses++;\n        Comment.cacheStats.creates++;\n        this.cachedTexture = this.createTextureCanvas(ctx);\n        this.textureCacheKey = currentCacheKey;\n      } else {\n        Comment.cacheStats.hits++;\n      }\n\n      // テクスチャが利用可能な場合はdrawImageで描画\n      if (this.cachedTexture) {\n        const drawX = interpolatedX ?? this.x;\n        const padding = Math.max(10, this.fontSize * 0.5);\n        ctx.drawImage(this.cachedTexture, drawX - padding, this.y - padding);\n        Comment.reportCacheStats();\n        return;\n      }\n\n      // フォールバック使用\n      Comment.cacheStats.fallbacks++;\n\n      // フォールバック: 通常の描画処理\n\n      ctx.save();\n      ctx.font = `${this.fontSize}px ${this.fontFamily}`;\n      const effectiveOpacity = clampOpacity(this.opacity);\n      const drawX = interpolatedX ?? this.x;\n      const linesToRender = this.lines.length > 0 ? this.lines : [this.text];\n      const lineAdvance =\n        this.lines.length > 1 && this.lineHeightPx > 0 ? this.lineHeightPx : this.fontSize;\n      const baselineStart = this.y + this.fontSize;\n\n      const drawSegment = this.createSegmentDrawer(ctx, ctx, \"fallback\", drawX);\n      const outlineOffsets = this.getOutlineOffsets();\n\n      const drawOutline = (): void => {\n        const outlineAlpha = clampOpacity(effectiveOpacity * 0.6);\n        ctx.save();\n        ctx.fillStyle = `rgba(0, 0, 0, ${outlineAlpha})`;\n        for (const [offsetX, offsetY] of outlineOffsets) {\n          linesToRender.forEach((line, index) => {\n            const baseline = baselineStart + index * lineAdvance + offsetY;\n            drawSegment(line, baseline, \"outline\", offsetX);\n          });\n        }\n        ctx.restore();\n      };\n\n      const drawFill = (fillStyle: string): void => {\n        ctx.save();\n        ctx.fillStyle = fillStyle;\n        linesToRender.forEach((line, index) => {\n          const baseline = baselineStart + index * lineAdvance;\n          drawSegment(line, baseline, \"fill\");\n        });\n        ctx.restore();\n      };\n\n      drawOutline();\n\n      if (this.renderStyle === \"classic\") {\n        const baseShadowOffset = Math.max(1, this.fontSize * 0.04);\n        const baseShadowBlur = this.fontSize * 0.18;\n        type ShadowLayer = Readonly<{\n          offsetXMultiplier: number;\n          offsetYMultiplier: number;\n          blurMultiplier: number;\n          alpha: number;\n          rgb: string;\n        }>;\n        const shadowLayers: ReadonlyArray<ShadowLayer> = [\n          {\n            offsetXMultiplier: 0.9,\n            offsetYMultiplier: 1.1,\n            blurMultiplier: 0.55,\n            alpha: 0.52,\n            rgb: \"20, 28, 40\",\n          },\n          {\n            offsetXMultiplier: 2.4,\n            offsetYMultiplier: 2.7,\n            blurMultiplier: 1.45,\n            alpha: 0.32,\n            rgb: \"0, 0, 0\",\n          },\n          {\n            offsetXMultiplier: -0.7,\n            offsetYMultiplier: -0.6,\n            blurMultiplier: 0.4,\n            alpha: 0.42,\n            rgb: \"255, 255, 255\",\n          },\n        ];\n\n        shadowLayers.forEach((layer) => {\n          const effectiveShadowAlpha = clampOpacity(layer.alpha * effectiveOpacity);\n          ctx.save();\n          ctx.shadowColor = `rgba(${layer.rgb}, ${effectiveShadowAlpha})`;\n          ctx.shadowBlur = baseShadowBlur * layer.blurMultiplier;\n          ctx.shadowOffsetX = baseShadowOffset * layer.offsetXMultiplier;\n          ctx.shadowOffsetY = baseShadowOffset * layer.offsetYMultiplier;\n          ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n          linesToRender.forEach((line, index) => {\n            const baseline = baselineStart + index * lineAdvance;\n            drawSegment(line, baseline, \"fill\");\n          });\n          ctx.restore();\n        });\n      }\n\n      const resolvedFillStyle = resolveFillStyleWithOpacity(this.color, effectiveOpacity);\n      drawFill(resolvedFillStyle);\n\n      ctx.restore();\n      Comment.reportCacheStats();\n    } catch (error) {\n      logger.error(\"Comment.draw\", error as Error, {\n        text: this.text,\n        isActive: this.isActive,\n        hasContext: Boolean(ctx),\n        interpolatedX,\n      });\n    }\n  }\n\n  syncWithSettings(settings: RendererSettings, settingsVersion?: number): void {\n    const hasSyncedVersion =\n      typeof settingsVersion === \"number\" && settingsVersion === this.lastSyncedSettingsVersion;\n    if (hasSyncedVersion) {\n      return;\n    }\n    this.color = this.getEffectiveColor(settings.commentColor);\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.applyScrollDirection(settings.scrollDirection);\n    this.renderStyle = settings.renderStyle;\n    if (typeof settingsVersion === \"number\") {\n      this.lastSyncedSettingsVersion = settingsVersion;\n    }\n  }\n\n  getEffectiveColor(defaultColor: string): string {\n    const candidate = this.colorOverride ?? defaultColor;\n    if (typeof candidate !== \"string\" || candidate.length === 0) {\n      return defaultColor;\n    }\n    return candidate.toUpperCase();\n  }\n\n  getEffectiveOpacity(defaultOpacity: number): number {\n    if (typeof this.opacityOverride === \"number\") {\n      return clampOpacity(this.opacityOverride);\n    }\n    const scaled = defaultOpacity * this.opacityMultiplier;\n    if (!Number.isFinite(scaled)) {\n      return 0;\n    }\n    return clampOpacity(scaled);\n  }\n\n  markActivated(atTimeMs: number): void {\n    this.activationTimeMs = atTimeMs;\n  }\n\n  clearActivation(): void {\n    this.activationTimeMs = null;\n    if (!this.isScrolling) {\n      this.staticExpiryTimeMs = null;\n    }\n    // テクスチャキャッシュをクリア\n    this.cachedTexture = null;\n    this.textureCacheKey = \"\";\n  }\n\n  hasStaticExpired(currentTimeMs: number): boolean {\n    if (this.isScrolling) {\n      return false;\n    }\n    if (this.staticExpiryTimeMs === null) {\n      return false;\n    }\n    return currentTimeMs >= this.staticExpiryTimeMs;\n  }\n\n  getDirectionSign(): -1 | 1 {\n    return this.directionSign;\n  }\n\n  private applyScrollDirection(direction: ScrollDirection | string): void {\n    const resolved = resolveScrollDirection(direction);\n    this.scrollDirection = resolved;\n    this.directionSign = getDirectionSign(resolved);\n  }\n\n  private createSegmentDrawer(\n    targetCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n    measurementCtx: CanvasRenderingContext2D,\n    statsTarget: \"cache\" | \"fallback\",\n    baseDrawX: number,\n  ): (line: string, baselineY: number, mode: DrawMode, offsetX?: number) => void {\n    return (line, baselineY, mode, offsetX = 0) => {\n      if (line.length === 0) {\n        return;\n      }\n      const leadingSpaces = line.match(/^[\\u3000\\u00A0]+/);\n      const leadingSpaceCount = leadingSpaces ? leadingSpaces[0].length : 0;\n      const leadingSpaceOffset =\n        leadingSpaceCount > 0 ? measureTextWidth(measurementCtx, leadingSpaces![0]) : 0;\n      const effectiveDrawX = baseDrawX + leadingSpaceOffset + offsetX;\n      const trimmedLine = leadingSpaceCount > 0 ? line.substring(leadingSpaceCount) : line;\n\n      const recordDraw = (): void => {\n        if (statsTarget === \"cache\") {\n          if (mode === \"outline\") {\n            Comment.cacheStats.outlineCallsInCache++;\n          } else {\n            Comment.cacheStats.fillCallsInCache++;\n          }\n        } else if (mode === \"outline\") {\n          Comment.cacheStats.outlineCallsInFallback++;\n        } else {\n          Comment.cacheStats.fillCallsInFallback++;\n        }\n      };\n\n      if (Math.abs(this.letterSpacing) < Number.EPSILON) {\n        recordDraw();\n        targetCtx.fillText(trimmedLine, effectiveDrawX, baselineY);\n        return;\n      }\n\n      let cursorX = effectiveDrawX;\n      for (let index = 0; index < trimmedLine.length; index += 1) {\n        const char = trimmedLine[index];\n        recordDraw();\n        targetCtx.fillText(char, cursorX, baselineY);\n        const advance = measureTextWidth(measurementCtx, char);\n        cursorX += advance;\n        if (index < trimmedLine.length - 1) {\n          cursorX += this.letterSpacing;\n        }\n      }\n    };\n  }\n\n  private getOutlineOffsets(): Array<[number, number]> {\n    const outlineThickness = Math.max(1, Math.round(this.fontSize * 0.08));\n    const offsets: Array<[number, number]> = [\n      [-outlineThickness, 0],\n      [outlineThickness, 0],\n      [0, -outlineThickness],\n      [0, outlineThickness],\n    ];\n    if (outlineThickness > 1) {\n      const diagonal = Math.max(1, Math.round(outlineThickness * 0.7));\n      offsets.push(\n        [-diagonal, -diagonal],\n        [-diagonal, diagonal],\n        [diagonal, -diagonal],\n        [diagonal, diagonal],\n      );\n    }\n    return offsets;\n  }\n\n  private updateTextMetrics(ctx: CanvasRenderingContext2D): void {\n    let maxLineWidth = 0;\n    const effectiveLetterSpacing = this.letterSpacing;\n    for (const line of this.lines) {\n      const baseWidth = measureTextWidth(ctx, line);\n      const extraSpacing = line.length > 1 ? effectiveLetterSpacing * (line.length - 1) : 0;\n      const totalWidth = Math.max(0, baseWidth + extraSpacing);\n      if (totalWidth > maxLineWidth) {\n        maxLineWidth = totalWidth;\n      }\n    }\n    this.width = maxLineWidth;\n    const computedLineHeightPx = Math.max(1, Math.floor(this.fontSize * this.lineHeightMultiplier));\n    this.lineHeightPx = computedLineHeightPx;\n    const additionalHeight =\n      this.lines.length > 1 ? (this.lines.length - 1) * computedLineHeightPx : 0;\n    this.height = this.fontSize + additionalHeight;\n  }\n}\n","import type { RendererSettings } from \"../shared/types\";\n\ntype ReadonlySettings = {\n  readonly [K in keyof RendererSettings]: RendererSettings[K] extends\n    | string\n    | number\n    | boolean\n    | null\n    | undefined\n    ? RendererSettings[K]\n    : ReadonlyArray<string>;\n};\n\nexport const NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS = 4_000;\n\nconst BASE_SETTINGS: RendererSettings = {\n  commentColor: \"#FFFFFF\",\n  commentOpacity: 1,\n  isCommentVisible: true,\n  useContainerResizeObserver: true,\n  ngWords: [],\n  ngRegexps: [],\n  scrollDirection: \"rtl\",\n  renderStyle: \"outline-only\",\n  syncMode: \"raf\",\n  scrollVisibleDurationMs: NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS,\n  useFixedLaneCount: false,\n  fixedLaneCount: 12,\n  useDprScaling: true,\n};\n\nexport const DEFAULT_RENDERER_SETTINGS: ReadonlySettings = BASE_SETTINGS;\n\nexport const cloneDefaultSettings = (): RendererSettings => ({\n  ...BASE_SETTINGS,\n  ngWords: [...BASE_SETTINGS.ngWords],\n  ngRegexps: [...BASE_SETTINGS.ngRegexps],\n});\n\nexport const COMMENT_OVERLAY_VERSION = \"v2.4.1\";\n","import { cloneDefaultSettings } from \"../config/default-settings\";\nimport type {\n  RendererSettings,\n  CommentRendererEventHooks,\n  GhostCommentInfo,\n  EpochChangeInfo,\n  RendererStateSnapshot,\n} from \"../shared/types\";\nimport {\n  Comment,\n  type CommentDependencies,\n  type CommentPrepareOptions,\n  type TimeSource,\n  createDefaultTimeSource,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"./comment\";\nimport { createLogger, type Logger } from \"../shared/logger\";\nimport {\n  configureDebugLogging,\n  debugLog,\n  formatCommentPreview,\n  isDebugLoggingEnabled,\n  visualizeGhostComments,\n  dumpRendererState,\n  logEpochChange,\n} from \"../shared/debug\";\nimport type { DebugLoggingOptions } from \"../shared/debug\";\n\nexport interface CommentRendererConfig {\n  loggerNamespace?: string;\n  timeSource?: TimeSource;\n  animationFrameProvider?: AnimationFrameProvider;\n  createCanvasElement?: () => HTMLCanvasElement;\n  debug?: DebugLoggingOptions;\n  eventHooks?: CommentRendererEventHooks;\n  enableAutoGhostDetection?: boolean;\n}\n\nexport interface CommentRendererInitializeOptions {\n  video: HTMLVideoElement;\n  container?: HTMLElement | null;\n}\n\nexport interface AnimationFrameProvider {\n  request(callback: FrameRequestCallback): ReturnType<typeof setTimeout>;\n  cancel(handle: ReturnType<typeof setTimeout>): void;\n}\n\ntype VideoFrameCallbackMetadataLike = {\n  readonly mediaTime?: number;\n};\n\ntype RequestVideoFrameCallback = (\n  callback: (now: DOMHighResTimeStamp, metadata: VideoFrameCallbackMetadataLike) => void,\n) => number;\n\ntype CancelVideoFrameCallback = (handle: number) => void;\n\ninterface LaneReservation {\n  comment: Comment;\n  startTime: number;\n  endTime: number;\n  totalEndTime: number;\n  startLeft: number;\n  width: number;\n  speed: number;\n  buffer: number;\n  directionSign: -1 | 1;\n}\n\ninterface StaticLaneReservation {\n  comment: Comment;\n  releaseTime: number;\n  yStart: number;\n  yEnd: number;\n  lane: number;\n}\n\nconst toMilliseconds = (seconds: number): number => seconds * 1000;\nconst sanitizeVposMs = (value: number): number | null => {\n  if (!Number.isFinite(value)) {\n    return null;\n  }\n  if (value < 0) {\n    return null;\n  }\n  return Math.round(value);\n};\nconst MAX_VISIBLE_DURATION_MS = 4_000;\nconst MIN_VISIBLE_DURATION_MS = 1_800;\nconst MAX_COMMENT_WIDTH_RATIO = 3;\nconst COLLISION_BUFFER_RATIO = 0.25;\nconst BASE_COLLISION_BUFFER_PX = 32;\nconst ENTRY_BUFFER_PX = 48;\nconst RESERVATION_TIME_MARGIN_MS = 120;\nconst FINAL_PHASE_THRESHOLD_MS = 4_000;\nconst FINAL_PHASE_MIN_GAP_MS = 120;\nconst FINAL_PHASE_MAX_GAP_MS = 800;\nconst FINAL_PHASE_ORDER_EPSILON_MS = 2;\nconst FINAL_PHASE_MIN_WINDOW_MS = 4_000;\n// シーク後も画面上に残る可能性があるコメントを拾えるよう、可視時間と静止時間の合計を参照する\nconst ACTIVE_WINDOW_MS = STATIC_VISIBLE_DURATION_MS + MAX_VISIBLE_DURATION_MS;\nconst VIRTUAL_CANVAS_EXTENSION_PX = 1_000;\nconst MIN_LANE_COUNT = 1;\nconst DEFAULT_LANE_COUNT = 12;\nconst MIN_FONT_SIZE_PX = 24;\nconst EDGE_EPSILON = 1e-3;\nconst SEEK_DIRECTION_EPSILON_MS = 50;\nconst STATIC_COMMENT_VERTICAL_PADDING_RATIO = 0.05;\nconst STATIC_COMMENT_MIN_VERTICAL_PADDING_PX = 10;\n\nconst clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 1;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nconst calculateStaticCommentVerticalPadding = (fontSize: number): number => {\n  return Math.max(\n    STATIC_COMMENT_MIN_VERTICAL_PADDING_PX,\n    Math.floor(fontSize * STATIC_COMMENT_VERTICAL_PADDING_RATIO),\n  );\n};\n\nconst normalizeSettings = (settings: RendererSettings): RendererSettings => {\n  const rawDuration = settings.scrollVisibleDurationMs;\n  const normalizedDuration =\n    rawDuration === null || rawDuration === undefined\n      ? null\n      : Number.isFinite(rawDuration)\n        ? Math.max(1, Math.floor(rawDuration))\n        : null;\n\n  const base: RendererSettings = {\n    ...settings,\n    scrollDirection: settings.scrollDirection === \"ltr\" ? \"ltr\" : \"rtl\",\n    commentOpacity: clampOpacity(settings.commentOpacity),\n    renderStyle: settings.renderStyle === \"classic\" ? \"classic\" : \"outline-only\",\n    scrollVisibleDurationMs: normalizedDuration,\n    syncMode: settings.syncMode === \"video-frame\" ? \"video-frame\" : \"raf\",\n    useDprScaling: Boolean(settings.useDprScaling),\n  };\n  return base;\n};\n\nexport const createDefaultAnimationFrameProvider = (\n  timeSource: TimeSource,\n): AnimationFrameProvider => {\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.requestAnimationFrame === \"function\" &&\n    typeof window.cancelAnimationFrame === \"function\"\n  ) {\n    return {\n      request: (callback) => window.requestAnimationFrame(callback),\n      cancel: (handle) => window.cancelAnimationFrame(handle),\n    };\n  }\n  return {\n    request: (callback) => {\n      const timeoutId = globalThis.setTimeout(() => {\n        callback(timeSource.now());\n      }, 16);\n      return timeoutId;\n    },\n    cancel: (handle) => {\n      globalThis.clearTimeout(handle);\n    },\n  };\n};\n\nconst createBrowserCanvasFactory = (): (() => HTMLCanvasElement) => {\n  if (typeof document === \"undefined\") {\n    return () => {\n      throw new Error(\n        \"Document is not available. Provide a custom createCanvasElement implementation.\",\n      );\n    };\n  }\n  return () => document.createElement(\"canvas\");\n};\n\nconst isRendererSettings = (input: unknown): input is RendererSettings => {\n  if (!input || typeof input !== \"object\") {\n    return false;\n  }\n  const candidate = input as Record<string, unknown>;\n  return (\n    typeof candidate.commentColor === \"string\" &&\n    typeof candidate.commentOpacity === \"number\" &&\n    typeof candidate.isCommentVisible === \"boolean\"\n  );\n};\n\nexport class CommentRenderer {\n  private _settings: RendererSettings;\n  private readonly comments: Comment[] = [];\n  private readonly activeComments = new Set<Comment>();\n  private readonly reservedLanes = new Map<number, LaneReservation[]>();\n  private readonly topStaticLaneReservations: StaticLaneReservation[] = [];\n  private readonly bottomStaticLaneReservations: StaticLaneReservation[] = [];\n  private readonly log: Logger;\n  private readonly timeSource: TimeSource;\n  private readonly animationFrameProvider: AnimationFrameProvider;\n  private readonly createCanvasElement: () => HTMLCanvasElement;\n  private readonly commentDependencies: CommentDependencies;\n  private settingsVersion = 0;\n  private normalizedNgWords: string[] = [];\n  private compiledNgRegexps: RegExp[] = [];\n  private canvas: HTMLCanvasElement | null = null;\n  private ctx: CanvasRenderingContext2D | null = null;\n  private videoElement: HTMLVideoElement | null = null;\n  private containerElement: HTMLElement | null = null;\n  private fullscreenActive = false;\n  private laneCount = DEFAULT_LANE_COUNT;\n  private laneHeight = 0;\n  private displayWidth = 0;\n  private displayHeight = 0;\n  private canvasDpr = 1;\n  private currentTime = 0;\n  private duration = 0;\n  private playbackRate = 1;\n  private isPlaying = true;\n  private isStalled = false;\n  private lastDrawTime = 0;\n  private finalPhaseActive = false;\n  private finalPhaseStartTime: number | null = null;\n  private finalPhaseScheduleDirty = false;\n  private playbackHasBegun = false;\n  private skipDrawingForCurrentFrame = false;\n  private pendingInitialSync = false;\n  private readonly finalPhaseVposOverrides = new Map<Comment, number>();\n  private frameId: ReturnType<typeof setTimeout> | null = null;\n  private videoFrameHandle: number | null = null;\n  private resizeObserver: ResizeObserver | null = null;\n  private resizeObserverTarget: Element | null = null;\n  private readonly isResizeObserverAvailable = typeof ResizeObserver !== \"undefined\";\n  private readonly cleanupTasks: Array<() => void> = [];\n  private commentSequence = 0;\n  private epochId = 0;\n  private readonly eventHooks: CommentRendererEventHooks;\n  private readonly enableAutoGhostDetection: boolean;\n  private lastSnapshotEmitTime = 0;\n  private readonly snapshotEmitThrottleMs = 1000;\n\n  constructor(settings: RendererSettings | null, config?: CommentRendererConfig);\n  constructor(config?: CommentRendererConfig);\n  constructor(\n    settingsOrConfig: RendererSettings | CommentRendererConfig | null = null,\n    maybeConfig: CommentRendererConfig | undefined = undefined,\n  ) {\n    let baseSettings: RendererSettings;\n    let config: CommentRendererConfig;\n\n    if (isRendererSettings(settingsOrConfig)) {\n      baseSettings = normalizeSettings({ ...(settingsOrConfig as RendererSettings) });\n      config = maybeConfig ?? {};\n    } else {\n      const configCandidate = settingsOrConfig ?? maybeConfig ?? {};\n      config =\n        typeof configCandidate === \"object\" ? (configCandidate as CommentRendererConfig) : {};\n      baseSettings = normalizeSettings(cloneDefaultSettings());\n    }\n\n    this._settings = normalizeSettings(baseSettings);\n    this.timeSource = config.timeSource ?? createDefaultTimeSource();\n    this.animationFrameProvider =\n      config.animationFrameProvider ?? createDefaultAnimationFrameProvider(this.timeSource);\n    this.createCanvasElement = config.createCanvasElement ?? createBrowserCanvasFactory();\n    this.commentDependencies = {\n      timeSource: this.timeSource,\n      settingsVersion: this.settingsVersion,\n    };\n    this.log = createLogger(config.loggerNamespace ?? \"CommentRenderer\");\n    this.eventHooks = config.eventHooks ?? {};\n    this.enableAutoGhostDetection = config.enableAutoGhostDetection ?? true;\n\n    this.rebuildNgMatchers();\n\n    if (config.debug) {\n      configureDebugLogging(config.debug);\n    }\n  }\n\n  get settings(): RendererSettings {\n    return this._settings;\n  }\n\n  set settings(value: RendererSettings) {\n    this._settings = normalizeSettings(value);\n    this.settingsVersion += 1;\n    this.commentDependencies.settingsVersion = this.settingsVersion;\n    this.rebuildNgMatchers();\n  }\n\n  private resolveContainer(\n    explicit: HTMLElement | null | undefined,\n    video: HTMLVideoElement,\n  ): HTMLElement {\n    if (explicit) {\n      return explicit;\n    }\n    if (video.parentElement) {\n      return video.parentElement;\n    }\n    if (typeof document !== \"undefined\" && document.body) {\n      return document.body;\n    }\n    throw new Error(\n      \"Cannot resolve container element. Provide container explicitly when DOM is unavailable.\",\n    );\n  }\n\n  private ensureContainerPositioning(container: HTMLElement): void {\n    if (typeof getComputedStyle === \"function\") {\n      const style = getComputedStyle(container);\n      if (style.position === \"static\") {\n        container.style.position = \"relative\";\n      }\n      return;\n    }\n    if (!container.style.position) {\n      container.style.position = \"relative\";\n    }\n  }\n\n  initialize(options: HTMLVideoElement | CommentRendererInitializeOptions): void {\n    try {\n      this.destroyCanvasOnly();\n\n      const video = options instanceof HTMLVideoElement ? options : options.video;\n      const containerCandidate =\n        options instanceof HTMLVideoElement\n          ? options.parentElement\n          : (options.container ?? options.video.parentElement);\n      const container = this.resolveContainer(containerCandidate ?? null, video);\n\n      this.videoElement = video;\n      this.containerElement = container;\n      this.duration = Number.isFinite(video.duration) ? toMilliseconds(video.duration) : 0;\n      this.currentTime = toMilliseconds(video.currentTime);\n      this.playbackRate = video.playbackRate;\n      this.isPlaying = !video.paused;\n      this.isStalled = false;\n      this.lastDrawTime = this.timeSource.now();\n      this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n      this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n\n      const canvas = this.createCanvasElement();\n      const context = canvas.getContext(\"2d\");\n      if (!context) {\n        throw new Error(\"Failed to acquire 2D canvas context\");\n      }\n\n      canvas.style.position = \"absolute\";\n      canvas.style.top = \"0\";\n      canvas.style.left = \"0\";\n      canvas.style.pointerEvents = \"none\";\n      canvas.style.zIndex = \"1000\";\n\n      const parent = this.containerElement;\n      if (parent instanceof HTMLElement) {\n        this.ensureContainerPositioning(parent);\n        parent.appendChild(canvas);\n      }\n\n      this.canvas = canvas;\n      this.ctx = context;\n\n      this.resize();\n      this.calculateLaneMetrics();\n      this.setupVideoEventListeners(video);\n      this.setupResizeHandling(video);\n      this.setupFullscreenHandling();\n      this.setupVideoChangeDetection(video, container);\n      this.startAnimation();\n      this.setupVisibilityHandling();\n    } catch (error) {\n      this.log.error(\"CommentRenderer.initialize\", error as Error);\n      throw error;\n    }\n  }\n\n  addComments(\n    entries: ReadonlyArray<{ text: string; vposMs: number; commands?: string[] }>,\n  ): Comment[] {\n    if (!Array.isArray(entries) || entries.length === 0) {\n      return [];\n    }\n\n    const addedComments: Comment[] = [];\n    this.commentDependencies.settingsVersion = this.settingsVersion;\n\n    for (const entry of entries) {\n      const { text, vposMs, commands = [] } = entry;\n      const preview = formatCommentPreview(text);\n\n      if (this.isNGComment(text)) {\n        debugLog(\"comment-skip-ng\", { preview, vposMs });\n        continue;\n      }\n\n      const normalizedVposMs = sanitizeVposMs(vposMs);\n      if (normalizedVposMs === null) {\n        this.log.warn(\"CommentRenderer.addComment.invalidVpos\", { text, vposMs });\n        debugLog(\"comment-skip-invalid-vpos\", { preview, vposMs });\n        continue;\n      }\n\n      const duplicate =\n        this.comments.some(\n          (comment) => comment.text === text && comment.vposMs === normalizedVposMs,\n        ) ||\n        addedComments.some(\n          (comment) => comment.text === text && comment.vposMs === normalizedVposMs,\n        );\n      if (duplicate) {\n        debugLog(\"comment-skip-duplicate\", { preview, vposMs: normalizedVposMs });\n        continue;\n      }\n\n      const comment = new Comment(\n        text,\n        normalizedVposMs,\n        commands,\n        this._settings,\n        this.commentDependencies,\n      );\n      comment.creationIndex = this.commentSequence++;\n      comment.epochId = this.epochId;\n      addedComments.push(comment);\n      debugLog(\"comment-added\", {\n        preview,\n        vposMs: normalizedVposMs,\n        commands: comment.commands.length,\n        layout: comment.layout,\n        isScrolling: comment.isScrolling,\n        invisible: comment.isInvisible,\n      });\n    }\n\n    if (addedComments.length === 0) {\n      return [];\n    }\n\n    this.comments.push(...addedComments);\n    if (this.finalPhaseActive) {\n      this.finalPhaseScheduleDirty = true;\n    }\n    this.comments.sort((a, b) => {\n      const vposMsDiff = a.vposMs - b.vposMs;\n      if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n        return vposMsDiff;\n      }\n      return a.creationIndex - b.creationIndex;\n    });\n\n    return addedComments;\n  }\n\n  addComment(text: string, vposMs: number, commands: string[] = []): Comment | null {\n    const [comment] = this.addComments([{ text, vposMs, commands }]);\n    return comment ?? null;\n  }\n\n  clearComments(): void {\n    this.comments.length = 0;\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n    this.commentSequence = 0;\n    if (this.ctx && this.canvas) {\n      const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n      const width = this.displayWidth > 0 ? this.displayWidth : this.canvas.width / effectiveDpr;\n      const height =\n        this.displayHeight > 0 ? this.displayHeight : this.canvas.height / effectiveDpr;\n      this.ctx.clearRect(0, 0, width, height);\n    }\n  }\n\n  resetState(): void {\n    this.clearComments();\n    this.currentTime = 0;\n    this.resetFinalPhaseState();\n    this.playbackHasBegun = false;\n    this.skipDrawingForCurrentFrame = false;\n    this.isStalled = false;\n    this.pendingInitialSync = false;\n  }\n\n  destroy(): void {\n    this.stopAnimation();\n    this.cleanupResizeHandling();\n    this.runCleanupTasks();\n\n    if (this.canvas) {\n      this.canvas.remove();\n    }\n    this.canvas = null;\n    this.ctx = null;\n    this.videoElement = null;\n    this.containerElement = null;\n    this.comments.length = 0;\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.resetFinalPhaseState();\n    this.displayWidth = 0;\n    this.displayHeight = 0;\n    this.canvasDpr = 1;\n    this.commentSequence = 0;\n    this.playbackHasBegun = false;\n    this.skipDrawingForCurrentFrame = false;\n    this.isStalled = false;\n    this.pendingInitialSync = false;\n  }\n\n  /**\n   * 前エポックのゴーストコメントを強制掃除し、次のフレームで絶対時間同期を行う\n   * 動画ロード直後の初期化やソース変更時に使用\n   */\n  hardReset(): void {\n    const canvas = this.canvas;\n    const ctx = this.ctx;\n\n    // ゴースト検出を実行\n    const ghosts = this.detectGhostComments();\n    if (ghosts.length > 0) {\n      this.removeGhostComments(ghosts);\n    }\n\n    // エポックをインクリメント\n    this.incrementEpoch(\"manual-reset\");\n\n    // アクティブコメントを全てクリア\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n\n    // 全コメントを非アクティブ化\n    this.comments.forEach((comment) => {\n      comment.isActive = false;\n      comment.hasShown = false;\n      comment.lane = -1;\n      comment.clearActivation();\n      comment.epochId = this.epochId;\n    });\n\n    // キャンバスを全消去\n    if (canvas && ctx) {\n      const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n      const effectiveWidth =\n        this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n      const effectiveHeight =\n        this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n      ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    }\n\n    // 次のフレームで絶対時間同期を実行するフラグを立てる\n    this.pendingInitialSync = true;\n    this.resetFinalPhaseState();\n\n    // 状態スナップショットを発行\n    this.emitStateSnapshot(\"hardReset\");\n  }\n\n  private resetFinalPhaseState(): void {\n    this.finalPhaseActive = false;\n    this.finalPhaseStartTime = null;\n    this.finalPhaseScheduleDirty = false;\n    this.finalPhaseVposOverrides.clear();\n  }\n\n  /**\n   * エポックIDを更新し、イベントを発火する\n   */\n  private incrementEpoch(reason: \"source-change\" | \"metadata-loaded\" | \"manual-reset\"): void {\n    const previousEpochId = this.epochId;\n    this.epochId += 1;\n\n    logEpochChange(previousEpochId, this.epochId, reason);\n\n    if (this.eventHooks.onEpochChange) {\n      const info: EpochChangeInfo = {\n        previousEpochId,\n        newEpochId: this.epochId,\n        reason,\n        timestamp: this.timeSource.now(),\n      };\n      try {\n        this.eventHooks.onEpochChange(info);\n      } catch (error) {\n        this.log.error(\"CommentRenderer.incrementEpoch.callback\", error as Error, { info });\n      }\n    }\n\n    // 全コメントに新しいepochIdを設定\n    this.comments.forEach((comment) => {\n      comment.epochId = this.epochId;\n    });\n  }\n\n  /**\n   * ゴーストコメントを検出する\n   * - epochIdが現在と異なるアクティブコメント\n   * - activationTimeMsが非常に古い（ACTIVE_WINDOW_MSの2倍以上前）コメント\n   * - isActiveだがactiveCommentsに含まれていないコメント\n   */\n  private detectGhostComments(): GhostCommentInfo[] {\n    if (!this.enableAutoGhostDetection) {\n      return [];\n    }\n\n    const ghosts: GhostCommentInfo[] = [];\n    const now = this.timeSource.now();\n    const staleThreshold = ACTIVE_WINDOW_MS * 2;\n\n    for (const comment of this.comments) {\n      if (!comment.isActive) {\n        continue;\n      }\n\n      let reason: \"epoch-mismatch\" | \"stale-activation\" | \"orphaned\" | null = null;\n\n      // エポックミスマッチ\n      if (comment.epochId !== this.epochId) {\n        reason = \"epoch-mismatch\";\n      }\n      // 古すぎるアクティベーション\n      else if (\n        comment.activationTimeMs !== null &&\n        now - comment.activationTimeMs > staleThreshold\n      ) {\n        reason = \"stale-activation\";\n      }\n      // activeCommentsに含まれていない孤立コメント\n      else if (!this.activeComments.has(comment)) {\n        reason = \"orphaned\";\n      }\n\n      if (reason !== null) {\n        ghosts.push({\n          comment: {\n            text: comment.text,\n            vposMs: comment.vposMs,\n            epochId: comment.epochId,\n          },\n          reason,\n          detectedAt: now,\n        });\n      }\n    }\n\n    return ghosts;\n  }\n\n  /**\n   * ゴーストコメントを削除する\n   */\n  private removeGhostComments(ghosts: GhostCommentInfo[]): void {\n    if (ghosts.length === 0) {\n      return;\n    }\n\n    const ghostSet = new Set(ghosts.map((g) => g.comment.text));\n\n    for (const comment of this.comments) {\n      if (ghostSet.has(comment.text) && comment.vposMs === ghosts[0]?.comment.vposMs) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n\n    visualizeGhostComments(\n      ghosts.map((g) => ({\n        text: g.comment.text,\n        vposMs: g.comment.vposMs,\n        epochId: g.comment.epochId,\n        reason: g.reason,\n      })),\n    );\n\n    if (this.eventHooks.onGhostCommentDetected) {\n      try {\n        this.eventHooks.onGhostCommentDetected(ghosts);\n      } catch (error) {\n        this.log.error(\"CommentRenderer.removeGhostComments.callback\", error as Error);\n      }\n    }\n  }\n\n  /**\n   * 状態スナップショットを生成してイベントを発火する\n   */\n  private emitStateSnapshot(label: string): void {\n    const now = this.timeSource.now();\n    if (now - this.lastSnapshotEmitTime < this.snapshotEmitThrottleMs) {\n      return;\n    }\n\n    const snapshot: RendererStateSnapshot = {\n      currentTime: this.currentTime,\n      duration: this.duration,\n      isPlaying: this.isPlaying,\n      epochId: this.epochId,\n      totalComments: this.comments.length,\n      activeComments: this.activeComments.size,\n      reservedLanes: this.reservedLanes.size,\n      finalPhaseActive: this.finalPhaseActive,\n      playbackHasBegun: this.playbackHasBegun,\n      isStalled: this.isStalled,\n    };\n\n    dumpRendererState(label, snapshot);\n\n    if (this.eventHooks.onStateSnapshot) {\n      try {\n        this.eventHooks.onStateSnapshot(snapshot);\n      } catch (error) {\n        this.log.error(\"CommentRenderer.emitStateSnapshot.callback\", error as Error);\n      }\n    }\n\n    this.lastSnapshotEmitTime = now;\n  }\n\n  private getEffectiveCommentVpos(comment: Comment): number {\n    if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n      this.recomputeFinalPhaseTimeline();\n    }\n    const override = this.finalPhaseVposOverrides.get(comment);\n    return override ?? comment.vposMs;\n  }\n\n  private getFinalPhaseDisplayDuration(comment: Comment): number {\n    if (!comment.isScrolling) {\n      return STATIC_VISIBLE_DURATION_MS;\n    }\n\n    const durations: number[] = [];\n    if (Number.isFinite(comment.visibleDurationMs) && comment.visibleDurationMs > 0) {\n      durations.push(comment.visibleDurationMs);\n    }\n    if (Number.isFinite(comment.totalDurationMs) && comment.totalDurationMs > 0) {\n      durations.push(comment.totalDurationMs);\n    }\n\n    if (durations.length > 0) {\n      return Math.max(...durations);\n    }\n\n    return MAX_VISIBLE_DURATION_MS;\n  }\n\n  private resolveFinalPhaseVpos(comment: Comment): number {\n    if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n      this.finalPhaseVposOverrides.delete(comment);\n      return comment.vposMs;\n    }\n    if (this.finalPhaseScheduleDirty) {\n      this.recomputeFinalPhaseTimeline();\n    }\n    const override = this.finalPhaseVposOverrides.get(comment);\n    if (override !== undefined) {\n      return override;\n    }\n    const fallback = Math.max(comment.vposMs, this.finalPhaseStartTime);\n    this.finalPhaseVposOverrides.set(comment, fallback);\n    return fallback;\n  }\n\n  private recomputeFinalPhaseTimeline(): void {\n    if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n      this.finalPhaseVposOverrides.clear();\n      this.finalPhaseScheduleDirty = false;\n      return;\n    }\n\n    const windowStart = this.finalPhaseStartTime;\n    const durationMs = this.duration > 0 ? this.duration : windowStart + FINAL_PHASE_MIN_WINDOW_MS;\n    const windowEnd = Math.max(windowStart + FINAL_PHASE_MIN_WINDOW_MS, durationMs);\n\n    const candidates = this.comments\n      .filter((comment) => {\n        if (comment.hasShown) {\n          return false;\n        }\n        if (comment.isInvisible) {\n          return false;\n        }\n        if (this.isNGComment(comment.text)) {\n          return false;\n        }\n        return comment.vposMs >= windowStart - ACTIVE_WINDOW_MS;\n      })\n      .sort((a, b) => {\n        const diff = a.vposMs - b.vposMs;\n        if (Math.abs(diff) > EDGE_EPSILON) {\n          return diff;\n        }\n        return a.creationIndex - b.creationIndex;\n      });\n\n    this.finalPhaseVposOverrides.clear();\n\n    if (candidates.length === 0) {\n      this.finalPhaseScheduleDirty = false;\n      return;\n    }\n\n    const windowSpan = Math.max(windowEnd - windowStart, FINAL_PHASE_MIN_WINDOW_MS);\n    const baseGap = windowSpan / Math.max(candidates.length, 1);\n    const boundedGap = Number.isFinite(baseGap) ? baseGap : FINAL_PHASE_MIN_GAP_MS;\n    const gap = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(boundedGap, FINAL_PHASE_MAX_GAP_MS));\n\n    let nextStart = windowStart;\n    candidates.forEach((comment, index) => {\n      const durationNeeded = Math.max(1, this.getFinalPhaseDisplayDuration(comment));\n      const availableLatestStart = windowEnd - durationNeeded;\n      let assigned = Math.max(windowStart, Math.min(nextStart, availableLatestStart));\n      if (!Number.isFinite(assigned)) {\n        assigned = windowStart;\n      }\n      const epsilon = FINAL_PHASE_ORDER_EPSILON_MS * index;\n      if (assigned + epsilon <= availableLatestStart) {\n        assigned += epsilon;\n      }\n      this.finalPhaseVposOverrides.set(comment, assigned);\n      const spacing = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(durationNeeded / 2, gap));\n      nextStart = assigned + spacing;\n    });\n\n    this.finalPhaseScheduleDirty = false;\n  }\n\n  private shouldSuppressRendering(): boolean {\n    return (\n      !this.playbackHasBegun && !this.isPlaying && this.currentTime <= SEEK_DIRECTION_EPSILON_MS\n    );\n  }\n\n  private updatePlaybackProgressState(): void {\n    if (this.playbackHasBegun) {\n      return;\n    }\n    if (this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS) {\n      this.playbackHasBegun = true;\n    }\n  }\n\n  updateSettings(newSettings: RendererSettings): void {\n    const previousUseContainer = this._settings.useContainerResizeObserver;\n    const previousDirection = this._settings.scrollDirection;\n    const previousUseDprScaling = this._settings.useDprScaling;\n    const previousSyncMode = this._settings.syncMode;\n    this.settings = newSettings;\n    const directionChanged = previousDirection !== this._settings.scrollDirection;\n    const useDprScalingChanged = previousUseDprScaling !== this._settings.useDprScaling;\n    const syncModeChanged = previousSyncMode !== this._settings.syncMode;\n\n    this.comments.forEach((comment) => {\n      comment.syncWithSettings(this._settings, this.settingsVersion);\n    });\n\n    if (directionChanged) {\n      this.resetCommentActivity();\n    }\n\n    if (!this._settings.isCommentVisible && this.ctx && this.canvas) {\n      this.comments.forEach((comment) => {\n        comment.isActive = false;\n        comment.clearActivation();\n      });\n      this.activeComments.clear();\n      const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n      const width = this.displayWidth > 0 ? this.displayWidth : this.canvas.width / effectiveDpr;\n      const height =\n        this.displayHeight > 0 ? this.displayHeight : this.canvas.height / effectiveDpr;\n      this.ctx.clearRect(0, 0, width, height);\n      this.reservedLanes.clear();\n      this.topStaticLaneReservations.length = 0;\n      this.bottomStaticLaneReservations.length = 0;\n    }\n\n    if (previousUseContainer !== this._settings.useContainerResizeObserver && this.videoElement) {\n      this.setupResizeHandling(this.videoElement);\n    }\n\n    if (useDprScalingChanged) {\n      this.resize();\n    }\n\n    if (syncModeChanged && this.videoElement) {\n      this.startAnimation();\n    }\n\n    this.calculateLaneMetrics();\n  }\n\n  getVideoElement(): HTMLVideoElement | null {\n    return this.videoElement;\n  }\n\n  getCurrentVideoSource(): string | null {\n    const video = this.videoElement;\n    if (!video) {\n      return null;\n    }\n    if (typeof video.currentSrc === \"string\" && video.currentSrc.length > 0) {\n      return video.currentSrc;\n    }\n    const attribute = video.getAttribute(\"src\");\n    if (attribute && attribute.length > 0) {\n      return attribute;\n    }\n    const sourceElement = video.querySelector(\"source[src]\") as HTMLSourceElement | null;\n    if (sourceElement && typeof sourceElement.src === \"string\") {\n      return sourceElement.src;\n    }\n    return null;\n  }\n\n  getCommentsSnapshot(): Comment[] {\n    return [...this.comments];\n  }\n\n  private rebuildNgMatchers(): void {\n    const normalizedWords: string[] = [];\n    const compiledRegexps: RegExp[] = [];\n\n    const sourceWords = Array.isArray(this._settings.ngWords) ? this._settings.ngWords : [];\n    for (const word of sourceWords) {\n      if (typeof word !== \"string\") {\n        continue;\n      }\n      const normalized = word.trim().toLowerCase();\n      if (normalized.length === 0) {\n        continue;\n      }\n      normalizedWords.push(normalized);\n    }\n\n    const sourcePatterns = Array.isArray(this._settings.ngRegexps) ? this._settings.ngRegexps : [];\n    for (const pattern of sourcePatterns) {\n      if (typeof pattern !== \"string\" || pattern.length === 0) {\n        continue;\n      }\n      try {\n        compiledRegexps.push(new RegExp(pattern));\n      } catch (regexError) {\n        this.log.error(\"CommentRenderer.rebuildNgMatchers.regex\", regexError as Error, {\n          pattern,\n        });\n      }\n    }\n\n    this.normalizedNgWords = normalizedWords;\n    this.compiledNgRegexps = compiledRegexps;\n  }\n\n  isNGComment(text: string): boolean {\n    try {\n      if (typeof text !== \"string\") {\n        return true;\n      }\n\n      if (this.normalizedNgWords.length > 0) {\n        const normalizedText = text.toLowerCase();\n        const containsNgWord = this.normalizedNgWords.some((word) => normalizedText.includes(word));\n        if (containsNgWord) {\n          return true;\n        }\n      }\n\n      if (this.compiledNgRegexps.length > 0) {\n        return this.compiledNgRegexps.some((regexp) => regexp.test(text));\n      }\n\n      return false;\n    } catch (error) {\n      this.log.error(\"CommentRenderer.isNGComment\", error as Error, { text });\n      return true;\n    }\n  }\n\n  resize(width?: number, height?: number): void {\n    const video = this.videoElement;\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (!video || !canvas) {\n      return;\n    }\n\n    const rect = video.getBoundingClientRect();\n    const currentDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const fallbackWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / currentDpr;\n    const fallbackHeight = this.displayHeight > 0 ? this.displayHeight : canvas.height / currentDpr;\n\n    const measuredWidth = width ?? rect.width ?? fallbackWidth;\n    const measuredHeight = height ?? rect.height ?? fallbackHeight;\n\n    if (\n      !Number.isFinite(measuredWidth) ||\n      !Number.isFinite(measuredHeight) ||\n      measuredWidth <= 0 ||\n      measuredHeight <= 0\n    ) {\n      return;\n    }\n\n    const cssWidth = Math.max(1, Math.floor(measuredWidth));\n    const cssHeight = Math.max(1, Math.floor(measuredHeight));\n    const previousDisplayWidth = this.displayWidth > 0 ? this.displayWidth : cssWidth;\n    const previousDisplayHeight = this.displayHeight > 0 ? this.displayHeight : cssHeight;\n    const nextDpr = this._settings.useDprScaling ? this.resolveDevicePixelRatio() : 1;\n    const pixelWidth = Math.max(1, Math.round(cssWidth * nextDpr));\n    const pixelHeight = Math.max(1, Math.round(cssHeight * nextDpr));\n\n    const needsResize =\n      this.displayWidth !== cssWidth ||\n      this.displayHeight !== cssHeight ||\n      Math.abs(this.canvasDpr - nextDpr) > Number.EPSILON ||\n      canvas.width !== pixelWidth ||\n      canvas.height !== pixelHeight;\n\n    if (!needsResize) {\n      return;\n    }\n\n    this.displayWidth = cssWidth;\n    this.displayHeight = cssHeight;\n    this.canvasDpr = nextDpr;\n\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    canvas.style.width = `${cssWidth}px`;\n    canvas.style.height = `${cssHeight}px`;\n\n    if (context) {\n      context.setTransform(1, 0, 0, 1, 0, 0);\n      if (this._settings.useDprScaling) {\n        context.scale(nextDpr, nextDpr);\n      }\n    }\n\n    const scaleX = previousDisplayWidth > 0 ? cssWidth / previousDisplayWidth : 1;\n    const scaleY = previousDisplayHeight > 0 ? cssHeight / previousDisplayHeight : 1;\n\n    if (scaleX !== 1 || scaleY !== 1) {\n      this.comments.forEach((comment) => {\n        if (comment.isActive) {\n          comment.x *= scaleX;\n          comment.y *= scaleY;\n          comment.width *= scaleX;\n          comment.fontSize = Math.max(\n            MIN_FONT_SIZE_PX,\n            Math.floor(Math.max(1, comment.fontSize) * scaleY),\n          );\n          comment.height = comment.fontSize;\n          comment.virtualStartX *= scaleX;\n          comment.exitThreshold *= scaleX;\n          comment.baseSpeed *= scaleX;\n          comment.speed *= scaleX;\n          comment.speedPixelsPerMs *= scaleX;\n          comment.bufferWidth *= scaleX;\n          comment.reservationWidth *= scaleX;\n        }\n      });\n    }\n\n    this.calculateLaneMetrics();\n  }\n\n  private resolveDevicePixelRatio(): number {\n    if (typeof window === \"undefined\") {\n      return 1;\n    }\n    const ratio = Number(window.devicePixelRatio);\n    if (!Number.isFinite(ratio) || ratio <= 0) {\n      return 1;\n    }\n    return ratio;\n  }\n\n  private destroyCanvasOnly(): void {\n    this.stopAnimation();\n    this.cleanupResizeHandling();\n    this.runCleanupTasks();\n    if (this.canvas) {\n      this.canvas.remove();\n    }\n    this.canvas = null;\n    this.ctx = null;\n    this.displayWidth = 0;\n    this.displayHeight = 0;\n    this.canvasDpr = 1;\n    this.fullscreenActive = false;\n  }\n\n  private calculateLaneMetrics(): void {\n    const canvas = this.canvas;\n    if (!canvas) {\n      return;\n    }\n\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / Math.max(this.canvasDpr, 1);\n    const baseHeight = Math.max(MIN_FONT_SIZE_PX, Math.floor(effectiveHeight * 0.05));\n    this.laneHeight = baseHeight * 1.2;\n    const availableLanes = Math.floor(effectiveHeight / Math.max(this.laneHeight, 1));\n    if (this._settings.useFixedLaneCount) {\n      // 利用可能レーン数の範囲にクランプして固定値を適用\n      const desired = Number.isFinite(this._settings.fixedLaneCount)\n        ? Math.floor(this._settings.fixedLaneCount)\n        : DEFAULT_LANE_COUNT;\n      const clamped = Math.max(MIN_LANE_COUNT, Math.min(availableLanes, desired));\n      this.laneCount = clamped;\n    } else {\n      this.laneCount = Math.max(MIN_LANE_COUNT, availableLanes);\n    }\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n  }\n\n  private updateComments(frameTimeMs?: number): void {\n    const video = this.videoElement;\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (!video || !canvas || !context) {\n      return;\n    }\n\n    // ゴースト検出を実行（フレームごと）\n    const ghosts = this.detectGhostComments();\n    if (ghosts.length > 0) {\n      this.removeGhostComments(ghosts);\n    }\n\n    const referenceTime =\n      typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n    this.currentTime = referenceTime;\n    this.playbackRate = video.playbackRate;\n    this.isPlaying = !video.paused;\n    this.updatePlaybackProgressState();\n    this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n    if (this.skipDrawingForCurrentFrame) {\n      return;\n    }\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n    const isNearEnd =\n      this.duration > 0 && this.duration - this.currentTime <= FINAL_PHASE_THRESHOLD_MS;\n\n    if (isNearEnd && !this.finalPhaseActive) {\n      this.finalPhaseActive = true;\n      this.finalPhaseStartTime = this.currentTime;\n      this.finalPhaseVposOverrides.clear();\n      this.finalPhaseScheduleDirty = true;\n      context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n      this.comments.forEach((comment) => {\n        comment.isActive = false;\n        comment.clearActivation();\n      });\n      this.activeComments.clear();\n      this.reservedLanes.clear();\n      this.topStaticLaneReservations.length = 0;\n      this.bottomStaticLaneReservations.length = 0;\n    }\n\n    if (!isNearEnd && this.finalPhaseActive) {\n      this.resetFinalPhaseState();\n    }\n\n    if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n      this.recomputeFinalPhaseTimeline();\n    }\n\n    this.pruneStaticLaneReservations(this.currentTime);\n\n    // 時間インデックスを用いて、アクティブウィンドウ内のコメントのみを処理\n    const activeWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n    for (const comment of activeWindowComments) {\n      const debugActive = isDebugLoggingEnabled();\n      const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n      if (debugActive) {\n        debugLog(\"comment-evaluate\", {\n          stage: \"update\",\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          currentTime: this.currentTime,\n          isActive: comment.isActive,\n          hasShown: comment.hasShown,\n        });\n      }\n\n      if (this.isNGComment(comment.text)) {\n        if (debugActive) {\n          debugLog(\"comment-eval-skip\", {\n            preview,\n            vposMs: comment.vposMs,\n            effectiveVposMs: this.getEffectiveCommentVpos(comment),\n            reason: \"ng-runtime\",\n          });\n        }\n        continue;\n      }\n      if (comment.isInvisible) {\n        if (debugActive) {\n          debugLog(\"comment-eval-skip\", {\n            preview,\n            vposMs: comment.vposMs,\n            effectiveVposMs: this.getEffectiveCommentVpos(comment),\n            reason: \"invisible\",\n          });\n        }\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.hasShown = true;\n        comment.clearActivation();\n        continue;\n      }\n\n      comment.syncWithSettings(this._settings, this.settingsVersion);\n\n      if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n        this.activateComment(\n          comment,\n          context,\n          effectiveWidth,\n          effectiveHeight,\n          prepareOptions,\n          this.currentTime,\n        );\n      }\n\n      if (comment.isActive) {\n        if (comment.layout !== \"naka\" && comment.hasStaticExpired(this.currentTime)) {\n          const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n          this.releaseStaticLane(staticPosition, comment.lane);\n          comment.isActive = false;\n          this.activeComments.delete(comment);\n          comment.clearActivation();\n          continue;\n        }\n\n        if (\n          comment.layout === \"naka\" &&\n          this.getEffectiveCommentVpos(comment) > this.currentTime + SEEK_DIRECTION_EPSILON_MS\n        ) {\n          comment.x = comment.virtualStartX;\n          comment.lastUpdateTime = this.timeSource.now();\n          continue;\n        }\n\n        comment.hasShown = true;\n        comment.update(this.playbackRate, !this.isPlaying);\n        if (!comment.isScrolling && comment.hasStaticExpired(this.currentTime)) {\n          const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n          this.releaseStaticLane(staticPosition, comment.lane);\n          comment.isActive = false;\n          this.activeComments.delete(comment);\n          comment.clearActivation();\n        }\n      }\n    }\n\n    for (const comment of this.comments) {\n      if (\n        comment.isActive &&\n        comment.isScrolling &&\n        ((comment.scrollDirection === \"rtl\" && comment.x <= comment.exitThreshold) ||\n          (comment.scrollDirection === \"ltr\" && comment.x >= comment.exitThreshold))\n      ) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n  }\n\n  private buildPrepareOptions(visibleWidth: number): CommentPrepareOptions {\n    const overrideDuration = this._settings.scrollVisibleDurationMs;\n    let maxVisibleDurationMs = MAX_VISIBLE_DURATION_MS;\n    let minVisibleDurationMs = MIN_VISIBLE_DURATION_MS;\n\n    if (overrideDuration !== null) {\n      maxVisibleDurationMs = overrideDuration;\n      minVisibleDurationMs = Math.max(1, Math.min(overrideDuration, MIN_VISIBLE_DURATION_MS));\n    }\n\n    return {\n      visibleWidth,\n      virtualExtension: VIRTUAL_CANVAS_EXTENSION_PX,\n      maxVisibleDurationMs,\n      minVisibleDurationMs,\n      maxWidthRatio: MAX_COMMENT_WIDTH_RATIO,\n      bufferRatio: COLLISION_BUFFER_RATIO,\n      baseBufferPx: BASE_COLLISION_BUFFER_PX,\n      entryBufferPx: ENTRY_BUFFER_PX,\n    };\n  }\n\n  private findAvailableLane(comment: Comment): number {\n    const currentTime = this.currentTime;\n    this.pruneLaneReservations(currentTime);\n    this.pruneStaticLaneReservations(currentTime);\n    const laneCandidates = this.getLanePriorityOrder(currentTime);\n    const newReservation = this.createLaneReservation(comment, currentTime);\n\n    for (const lane of laneCandidates) {\n      if (this.isLaneAvailable(lane, newReservation, currentTime)) {\n        this.storeLaneReservation(lane, newReservation);\n        return lane;\n      }\n    }\n\n    const fallbackLane = laneCandidates[0] ?? 0;\n    this.storeLaneReservation(fallbackLane, newReservation);\n    return fallbackLane;\n  }\n\n  /**\n   * 二分探索で、指定した時刻より後に終了する最初の予約のインデックスを返す\n   */\n  private findFirstValidReservationIndex(\n    reservations: LaneReservation[],\n    cutoffTime: number,\n  ): number {\n    let left = 0;\n    let right = reservations.length;\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      const reservation = reservations[mid];\n      if (\n        reservation !== undefined &&\n        reservation.totalEndTime + RESERVATION_TIME_MARGIN_MS <= cutoffTime\n      ) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n    return left;\n  }\n\n  private pruneLaneReservations(currentTime: number): void {\n    for (const [lane, reservations] of this.reservedLanes.entries()) {\n      // 二分探索で有効な予約の開始インデックスを取得\n      const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n      if (firstValidIndex >= reservations.length) {\n        // 全て期限切れ\n        this.reservedLanes.delete(lane);\n      } else if (firstValidIndex > 0) {\n        // 一部を削除\n        this.reservedLanes.set(lane, reservations.slice(firstValidIndex));\n      }\n      // firstValidIndex === 0 の場合は何もしない（全て有効）\n    }\n  }\n\n  private pruneStaticLaneReservations(currentTime: number): void {\n    // 期限切れの予約を削除（時間でフィルタリング）\n    const filterValid = (reservations: StaticLaneReservation[]): StaticLaneReservation[] =>\n      reservations.filter((reservation) => reservation.releaseTime > currentTime);\n\n    const topFiltered = filterValid(this.topStaticLaneReservations);\n    const bottomFiltered = filterValid(this.bottomStaticLaneReservations);\n\n    // 配列を置き換え\n    this.topStaticLaneReservations.length = 0;\n    this.topStaticLaneReservations.push(...topFiltered);\n\n    this.bottomStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.push(...bottomFiltered);\n  }\n\n  /**\n   * 二分探索で、指定した時刻以上の最初のコメントのインデックスを返す\n   */\n  private findCommentIndexAtOrAfter(targetVposMs: number): number {\n    let left = 0;\n    let right = this.comments.length;\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      const comment = this.comments[mid];\n      if (comment !== undefined && comment.vposMs < targetVposMs) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n    return left;\n  }\n\n  /**\n   * 指定した時刻範囲内のコメントのみを返す\n   */\n  private getCommentsInTimeWindow(centerTimeMs: number, windowMs: number): Comment[] {\n    if (this.comments.length === 0) {\n      return [];\n    }\n    const startTime = centerTimeMs - windowMs;\n    const endTime = centerTimeMs + windowMs;\n    const startIndex = this.findCommentIndexAtOrAfter(startTime);\n\n    // 開始インデックスから順に、終了時刻までのコメントを集める\n    const result: Comment[] = [];\n    for (let i = startIndex; i < this.comments.length; i++) {\n      const comment = this.comments[i];\n      if (comment === undefined) {\n        break;\n      }\n      if (comment.vposMs > endTime) {\n        break;\n      }\n      result.push(comment);\n    }\n    return result;\n  }\n\n  private getStaticReservations(position: \"ue\" | \"shita\"): StaticLaneReservation[] {\n    return position === \"ue\" ? this.topStaticLaneReservations : this.bottomStaticLaneReservations;\n  }\n\n  private getStaticLaneDepth(position: \"ue\" | \"shita\"): number {\n    const reservations = this.getStaticReservations(position);\n    if (reservations.length === 0) {\n      return 0;\n    }\n    let maxIndex = -1;\n    for (const reservation of reservations) {\n      if (reservation.lane > maxIndex) {\n        maxIndex = reservation.lane;\n      }\n    }\n    return Math.max(0, maxIndex + 1);\n  }\n\n  private getStaticLaneLimit(position: \"ue\" | \"shita\"): number {\n    const otherPosition = position === \"ue\" ? \"shita\" : \"ue\";\n    const otherDepth = this.getStaticLaneDepth(otherPosition);\n    const available = this.laneCount - otherDepth;\n    if (available <= 0) {\n      return -1;\n    }\n    return available - 1;\n  }\n\n  private getGlobalLaneIndexForBottom(localIndex: number): number {\n    const clampedLaneCount = Math.max(1, this.laneCount);\n    const clampedIndex = Math.max(0, localIndex);\n    return Math.max(0, clampedLaneCount - 1 - clampedIndex);\n  }\n\n  private resolveStaticCommentOffset(\n    position: \"ue\" | \"shita\",\n    lane: number,\n    displayHeight: number,\n    comment: Comment,\n  ): number {\n    const effectiveHeight = Math.max(1, displayHeight);\n    const commentHeight = Math.max(comment.height, comment.fontSize);\n    // 描画時のパディング（影やエフェクトのため）を考慮\n    const padding = calculateStaticCommentVerticalPadding(comment.fontSize);\n\n    if (position === \"ue\") {\n      // 上コメント：レーンベースの位置を計算\n      const baseY = lane * this.laneHeight;\n      // 実際の描画は y - padding から始まるので、上端がマイナスにならないようクランプ\n      const minY = padding;\n      // 下端が画面からはみ出ないようクランプ（実際の下端は y + height + padding）\n      const maxY = Math.max(padding, effectiveHeight - commentHeight - padding);\n      return Math.max(minY, Math.min(baseY, maxY));\n    }\n\n    // 下コメント：下端を基準に配置\n    // lane 0 = 画面下端、lane 1 = laneHeight分上、というように配置\n    const targetBottomY = effectiveHeight - lane * this.laneHeight;\n    // 実際の描画下端は y + height + padding なので、これが targetBottomY になるように計算\n    const adjustedY = targetBottomY - commentHeight - padding;\n    // 上端が画面外に出ないようクランプ（描画開始位置は y - padding）\n    return Math.max(padding, adjustedY);\n  }\n\n  private getStaticReservedLaneSet(): Set<number> {\n    const reserved = new Set<number>();\n    for (const reservation of this.topStaticLaneReservations) {\n      reserved.add(reservation.lane);\n    }\n    for (const reservation of this.bottomStaticLaneReservations) {\n      reserved.add(this.getGlobalLaneIndexForBottom(reservation.lane));\n    }\n    return reserved;\n  }\n\n  private shouldActivateCommentAtTime(\n    comment: Comment,\n    timeMs: number,\n    preview: string = \"\",\n  ): boolean {\n    const debugActive = preview.length > 0 && isDebugLoggingEnabled();\n    const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n    if (\n      this.finalPhaseActive &&\n      this.finalPhaseStartTime !== null &&\n      comment.vposMs < this.finalPhaseStartTime - EDGE_EPSILON\n    ) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          reason: \"final-phase-trimmed\",\n          finalPhaseStartTime: this.finalPhaseStartTime,\n        });\n      }\n      this.finalPhaseVposOverrides.delete(comment);\n      return false;\n    }\n\n    if (comment.isInvisible) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          reason: \"invisible\",\n        });\n      }\n      return false;\n    }\n    if (comment.isActive) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          reason: \"already-active\",\n        });\n      }\n      return false;\n    }\n    if (effectiveVpos > timeMs + SEEK_DIRECTION_EPSILON_MS) {\n      if (debugActive) {\n        debugLog(\"comment-eval-pending\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          reason: \"future\",\n          currentTime: timeMs,\n        });\n      }\n      return false;\n    }\n    if (effectiveVpos < timeMs - ACTIVE_WINDOW_MS) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          reason: \"expired-window\",\n          currentTime: timeMs,\n        });\n      }\n      return false;\n    }\n\n    if (debugActive) {\n      debugLog(\"comment-eval-ready\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        currentTime: timeMs,\n      });\n    }\n    return true;\n  }\n\n  private activateComment(\n    comment: Comment,\n    context: CanvasRenderingContext2D,\n    displayWidth: number,\n    displayHeight: number,\n    options: CommentPrepareOptions,\n    referenceTime: number,\n  ): void {\n    comment.prepare(context, displayWidth, displayHeight, options);\n    const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n    if (isDebugLoggingEnabled()) {\n      debugLog(\"comment-prepared\", {\n        preview: formatCommentPreview(comment.text),\n        layout: comment.layout,\n        isScrolling: comment.isScrolling,\n        width: comment.width,\n        height: comment.height,\n        bufferWidth: comment.bufferWidth,\n        visibleDurationMs: comment.visibleDurationMs,\n        effectiveVposMs: effectiveVpos,\n      });\n    }\n\n    if (comment.layout === \"naka\") {\n      const elapsedMs = Math.max(0, referenceTime - effectiveVpos);\n      const displacement = comment.speedPixelsPerMs * elapsedMs;\n\n      // --- ファイナルフェーズ時の速度調整ロジック ---\n      if (this.finalPhaseActive && this.finalPhaseStartTime !== null) {\n        // コメントが画面を横断しきるべき最終時刻を決定\n        const videoDuration =\n          this.duration > 0 ? this.duration : this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS;\n        const finalPhaseWindowEnd = Math.max(\n          this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS,\n          videoDuration,\n        );\n\n        // コメントが移動すべき全距離\n        const travelDistance = Math.abs(comment.exitThreshold - comment.virtualStartX);\n        // コメントが移動に使える時間\n        const availableTravelTime = finalPhaseWindowEnd - effectiveVpos;\n\n        if (availableTravelTime > 0 && travelDistance > 0) {\n          const requiredSpeedPixelsPerMs = travelDistance / availableTravelTime;\n\n          // 必要な速度が現在の速度より速い場合のみ調整\n          if (requiredSpeedPixelsPerMs > comment.speedPixelsPerMs) {\n            comment.speedPixelsPerMs = requiredSpeedPixelsPerMs;\n            comment.baseSpeed = requiredSpeedPixelsPerMs * (1000 / 60); // px/ms を px/frame に変換\n            comment.speed = comment.baseSpeed; // 即座に適用 (playbackRate は update() で適用される)\n            comment.totalDurationMs = Math.ceil(travelDistance / requiredSpeedPixelsPerMs); // 総移動時間も更新\n          }\n        }\n      }\n      // --- ファイナルフェーズ時の速度調整ロジックここまで ---\n\n      const directionSign = comment.getDirectionSign();\n      const projectedX = comment.virtualStartX + directionSign * displacement;\n      const exitThreshold = comment.exitThreshold;\n      const direction = comment.scrollDirection;\n      const alreadyExited =\n        (direction === \"rtl\" && projectedX <= exitThreshold) ||\n        (direction === \"ltr\" && projectedX >= exitThreshold);\n\n      if (alreadyExited) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.hasShown = true;\n        comment.clearActivation();\n        comment.lane = -1;\n        if (isDebugLoggingEnabled()) {\n          debugLog(\"comment-skip-exited\", {\n            preview: formatCommentPreview(comment.text),\n            vposMs: comment.vposMs,\n            effectiveVposMs: effectiveVpos,\n            referenceTime,\n          });\n        }\n        return;\n      }\n\n      comment.lane = this.findAvailableLane(comment);\n      comment.y = comment.lane * this.laneHeight;\n      comment.x = projectedX;\n      comment.isActive = true;\n      this.activeComments.add(comment);\n      comment.hasShown = true;\n      comment.isPaused = !this.isPlaying;\n      comment.markActivated(referenceTime);\n      comment.lastUpdateTime = this.timeSource.now();\n      if (isDebugLoggingEnabled()) {\n        debugLog(\"comment-activate-scroll\", {\n          preview: formatCommentPreview(comment.text),\n          lane: comment.lane,\n          startX: comment.x,\n          width: comment.width,\n          visibleDurationMs: comment.visibleDurationMs,\n          effectiveVposMs: effectiveVpos,\n        });\n      }\n      return;\n    }\n\n    const displayEnd = effectiveVpos + STATIC_VISIBLE_DURATION_MS;\n    if (referenceTime > displayEnd) {\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.hasShown = true;\n      comment.clearActivation();\n      comment.lane = -1;\n      if (isDebugLoggingEnabled()) {\n        debugLog(\"comment-skip-expired\", {\n          preview: formatCommentPreview(comment.text),\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          referenceTime,\n          displayEnd,\n        });\n      }\n      return;\n    }\n\n    const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n    const laneIndex = this.assignStaticLane(staticPosition, comment, displayHeight, referenceTime);\n    comment.lane = laneIndex;\n    comment.y = this.resolveStaticCommentOffset(staticPosition, laneIndex, displayHeight, comment);\n    comment.x = comment.virtualStartX;\n    comment.isActive = true;\n    this.activeComments.add(comment);\n    comment.hasShown = true;\n    comment.isPaused = !this.isPlaying;\n    comment.markActivated(referenceTime);\n    comment.lastUpdateTime = this.timeSource.now();\n    comment.staticExpiryTimeMs = displayEnd;\n    this.reserveStaticLane(staticPosition, comment, laneIndex, displayEnd);\n    if (isDebugLoggingEnabled()) {\n      debugLog(\"comment-activate-static\", {\n        preview: formatCommentPreview(comment.text),\n        lane: comment.lane,\n        position: staticPosition,\n        displayEnd,\n        effectiveVposMs: effectiveVpos,\n      });\n    }\n  }\n\n  private assignStaticLane(\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    displayHeight: number,\n    currentTime: number,\n  ): number {\n    const reservations = this.getStaticReservations(position);\n    const limit = this.getStaticLaneLimit(position);\n    const laneCount = limit >= 0 ? limit + 1 : 0;\n    const laneIndices = Array.from({ length: laneCount }, (_, index) => index);\n\n    // 各候補レーンに対してY座標を計算し、重なりがないかチェック\n    for (const lane of laneIndices) {\n      // このレーンに配置した場合のY座標範囲を計算\n      const yOffset = this.resolveStaticCommentOffset(position, lane, displayHeight, comment);\n      const commentHeight = Math.max(comment.height, comment.fontSize);\n      const padding = calculateStaticCommentVerticalPadding(comment.fontSize);\n      const yStart = yOffset - padding;\n      const yEnd = yOffset + commentHeight + padding;\n\n      // 既存の予約と重なりがないかチェック\n      const hasConflict = reservations.some((reservation) => {\n        // 時間的な重なりチェック（余裕を持たせる）\n        const timeOverlap = reservation.releaseTime > currentTime;\n        if (!timeOverlap) {\n          return false;\n        }\n\n        // Y座標の重なりチェック\n        const yOverlap = !(yEnd <= reservation.yStart || yStart >= reservation.yEnd);\n        return yOverlap;\n      });\n\n      if (!hasConflict) {\n        return lane;\n      }\n    }\n\n    // 全レーンに衝突がある場合、最も早くリリースされるレーンを選択\n    let fallbackLane = laneIndices[0] ?? 0;\n    let earliestRelease = Number.POSITIVE_INFINITY;\n    for (const reservation of reservations) {\n      if (reservation.releaseTime < earliestRelease) {\n        earliestRelease = reservation.releaseTime;\n        fallbackLane = reservation.lane;\n      }\n    }\n    return fallbackLane;\n  }\n\n  private reserveStaticLane(\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    lane: number,\n    releaseTime: number,\n  ): void {\n    const reservations = this.getStaticReservations(position);\n    const commentHeight = Math.max(comment.height, comment.fontSize);\n    const padding = calculateStaticCommentVerticalPadding(comment.fontSize);\n    const yStart = comment.y - padding;\n    const yEnd = comment.y + commentHeight + padding;\n\n    reservations.push({\n      comment,\n      releaseTime,\n      yStart,\n      yEnd,\n      lane,\n    });\n  }\n\n  private releaseStaticLane(position: \"ue\" | \"shita\", lane: number): void {\n    if (lane < 0) {\n      return;\n    }\n    const reservations = this.getStaticReservations(position);\n    const index = reservations.findIndex((r) => r.lane === lane);\n    if (index >= 0) {\n      reservations.splice(index, 1);\n    }\n  }\n\n  private getLanePriorityOrder(currentTime: number): number[] {\n    const indices = Array.from({ length: this.laneCount }, (_, index) => index);\n    const sorted = indices.sort((a, b) => {\n      const nextA = this.getLaneNextAvailableTime(a, currentTime);\n      const nextB = this.getLaneNextAvailableTime(b, currentTime);\n      if (Math.abs(nextA - nextB) <= EDGE_EPSILON) {\n        return a - b;\n      }\n      return nextA - nextB;\n    });\n    const staticReserved = this.getStaticReservedLaneSet();\n    if (staticReserved.size === 0) {\n      return sorted;\n    }\n    const preferred = sorted.filter((lane) => !staticReserved.has(lane));\n    if (preferred.length === 0) {\n      return sorted;\n    }\n    const blocked = sorted.filter((lane) => staticReserved.has(lane));\n    return [...preferred, ...blocked];\n  }\n\n  private getLaneNextAvailableTime(lane: number, currentTime: number): number {\n    const reservations = this.reservedLanes.get(lane);\n    if (!reservations || reservations.length === 0) {\n      return currentTime;\n    }\n    // 有効な予約から開始して最大のendTimeを見つける\n    const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n    let nextTime = currentTime;\n    for (let i = firstValidIndex; i < reservations.length; i++) {\n      const reservation = reservations[i];\n      if (reservation !== undefined) {\n        nextTime = Math.max(nextTime, reservation.endTime);\n      }\n    }\n    return nextTime;\n  }\n\n  private createLaneReservation(comment: Comment, referenceTime: number): LaneReservation {\n    const speed = Math.max(comment.speedPixelsPerMs, EDGE_EPSILON);\n    const effectiveStart = this.getEffectiveCommentVpos(comment);\n    const baseStartTime = Number.isFinite(effectiveStart) ? effectiveStart : referenceTime;\n    const startTime = Math.max(0, baseStartTime);\n    const endTime = startTime + comment.preCollisionDurationMs + RESERVATION_TIME_MARGIN_MS;\n    const totalEndTime = startTime + comment.totalDurationMs + RESERVATION_TIME_MARGIN_MS;\n    return {\n      comment,\n      startTime,\n      endTime: Math.max(startTime, endTime),\n      totalEndTime: Math.max(startTime, totalEndTime),\n      startLeft: comment.virtualStartX,\n      width: comment.width,\n      speed,\n      buffer: comment.bufferWidth,\n      directionSign: comment.getDirectionSign(),\n    };\n  }\n\n  private isLaneAvailable(lane: number, candidate: LaneReservation, currentTime: number): boolean {\n    const reservations = this.reservedLanes.get(lane);\n    if (!reservations || reservations.length === 0) {\n      return true;\n    }\n    // リストはtotalEndTimeでソート済みなので、有効な予約から開始\n    const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n    for (let i = firstValidIndex; i < reservations.length; i++) {\n      const reservation = reservations[i];\n      if (reservation === undefined) {\n        break;\n      }\n      if (this.areReservationsConflicting(reservation, candidate)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private storeLaneReservation(lane: number, reservation: LaneReservation): void {\n    const existing = this.reservedLanes.get(lane) ?? [];\n    // totalEndTimeでソートすることで、期限切れ予約の削除を効率化\n    const updated = [...existing, reservation].sort((a, b) => a.totalEndTime - b.totalEndTime);\n    this.reservedLanes.set(lane, updated);\n  }\n\n  private areReservationsConflicting(a: LaneReservation, b: LaneReservation): boolean {\n    const overlapStart = Math.max(a.startTime, b.startTime);\n    const overlapEnd = Math.min(a.endTime, b.endTime);\n    if (overlapStart >= overlapEnd) {\n      return false;\n    }\n\n    const evaluationTimes = new Set<number>([\n      overlapStart,\n      overlapEnd,\n      overlapStart + (overlapEnd - overlapStart) / 2,\n    ]);\n\n    const forwardIntersection = this.solveLeftRightEqualityTime(a, b);\n    if (\n      forwardIntersection !== null &&\n      forwardIntersection >= overlapStart - EDGE_EPSILON &&\n      forwardIntersection <= overlapEnd + EDGE_EPSILON\n    ) {\n      evaluationTimes.add(forwardIntersection);\n    }\n\n    const backwardIntersection = this.solveLeftRightEqualityTime(b, a);\n    if (\n      backwardIntersection !== null &&\n      backwardIntersection >= overlapStart - EDGE_EPSILON &&\n      backwardIntersection <= overlapEnd + EDGE_EPSILON\n    ) {\n      evaluationTimes.add(backwardIntersection);\n    }\n\n    for (const time of evaluationTimes) {\n      if (time < overlapStart - EDGE_EPSILON || time > overlapEnd + EDGE_EPSILON) {\n        continue;\n      }\n      const forwardGap = this.computeForwardGap(a, b, time);\n      const backwardGap = this.computeForwardGap(b, a, time);\n      if (forwardGap <= EDGE_EPSILON && backwardGap <= EDGE_EPSILON) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private computeForwardGap(from: LaneReservation, to: LaneReservation, time: number): number {\n    const fromEdges = this.getBufferedEdges(from, time);\n    const toEdges = this.getBufferedEdges(to, time);\n    return fromEdges.left - toEdges.right;\n  }\n\n  private getBufferedEdges(\n    reservation: LaneReservation,\n    time: number,\n  ): { left: number; right: number } {\n    const elapsed = Math.max(0, time - reservation.startTime);\n    const displacement = reservation.speed * elapsed;\n    const rawLeft = reservation.startLeft + reservation.directionSign * displacement;\n    const left = rawLeft - reservation.buffer;\n    const right = rawLeft + reservation.width + reservation.buffer;\n    return { left, right };\n  }\n\n  private solveLeftRightEqualityTime(left: LaneReservation, right: LaneReservation): number | null {\n    const leftSign = left.directionSign;\n    const rightSign = right.directionSign;\n    const denominator = rightSign * right.speed - leftSign * left.speed;\n    if (Math.abs(denominator) < EDGE_EPSILON) {\n      return null;\n    }\n    const numerator =\n      right.startLeft +\n      rightSign * right.speed * right.startTime +\n      right.width +\n      right.buffer -\n      left.startLeft -\n      leftSign * left.speed * left.startTime +\n      left.buffer;\n    const time = numerator / denominator;\n    if (!Number.isFinite(time)) {\n      return null;\n    }\n    return time;\n  }\n\n  private draw(): void {\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (!canvas || !context) {\n      return;\n    }\n\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n\n    const now = this.timeSource.now();\n\n    if (this.skipDrawingForCurrentFrame || this.shouldSuppressRendering() || this.isStalled) {\n      context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n      this.lastDrawTime = now;\n      return;\n    }\n\n    context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    const activeComments = Array.from(this.activeComments);\n\n    if (this._settings.isCommentVisible) {\n      const deltaTime = (now - this.lastDrawTime) / (1000 / 60);\n      activeComments.sort((a, b) => {\n        const aVpos = this.getEffectiveCommentVpos(a);\n        const bVpos = this.getEffectiveCommentVpos(b);\n        const vposMsDiff = aVpos - bVpos;\n        if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n          return vposMsDiff;\n        }\n        if (a.isScrolling !== b.isScrolling) {\n          return a.isScrolling ? 1 : -1;\n        }\n        return a.creationIndex - b.creationIndex;\n      });\n      activeComments.forEach((comment) => {\n        const shouldInterpolate = this.isPlaying && !comment.isPaused;\n        const interpolatedX = shouldInterpolate\n          ? comment.x + comment.getDirectionSign() * comment.speed * deltaTime\n          : comment.x;\n        comment.draw(context, interpolatedX);\n      });\n    }\n\n    this.lastDrawTime = now;\n  }\n\n  /**\n   * 初回フレームで絶対時間同期を実行\n   * 相対進行（dt積分）で初期区間を駆け抜けないようにする\n   */\n  private performInitialSync(frameTimeMs?: number): void {\n    const video = this.videoElement;\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (!video || !canvas || !context) {\n      return;\n    }\n\n    // 絶対時間を取得（VFCのmediaTimeまたはvideo.currentTime）\n    const absoluteTime =\n      typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n    this.currentTime = absoluteTime;\n    this.lastDrawTime = this.timeSource.now();\n\n    // 既存のアクティブコメントは全てクリア済み（hardReset()で実施）\n    // 現在時刻に基づいてコメントを再配置（onSeek()と同様のロジック）\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n    // 時間ウィンドウ内のコメントを取得\n    const windowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n    windowComments.forEach((comment) => {\n      if (this.isNGComment(comment.text) || comment.isInvisible) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n        return;\n      }\n\n      comment.syncWithSettings(this._settings, this.settingsVersion);\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.lane = -1;\n      comment.clearActivation();\n\n      if (this.shouldActivateCommentAtTime(comment, this.currentTime)) {\n        this.activateComment(\n          comment,\n          context,\n          effectiveWidth,\n          effectiveHeight,\n          prepareOptions,\n          this.currentTime,\n        );\n        return;\n      }\n\n      const effectiveVpos = this.getEffectiveCommentVpos(comment);\n      if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n        comment.hasShown = true;\n      } else {\n        comment.hasShown = false;\n      }\n    });\n  }\n\n  private processFrame(frameTimeMs?: number): void {\n    if (!this.videoElement) {\n      return;\n    }\n    if (!this._settings.isCommentVisible) {\n      return;\n    }\n\n    // 初回フレームでは絶対時間同期を実行\n    if (this.pendingInitialSync) {\n      this.performInitialSync(frameTimeMs);\n      this.pendingInitialSync = false;\n    }\n\n    this.updateComments(frameTimeMs);\n    this.draw();\n  }\n\n  private readonly handleAnimationFrame = (): void => {\n    const pendingId = this.frameId;\n    this.frameId = null;\n    if (pendingId !== null) {\n      this.animationFrameProvider.cancel(pendingId);\n    }\n    this.processFrame();\n    this.scheduleNextFrame();\n  };\n\n  private readonly handleVideoFrame = (\n    _now: DOMHighResTimeStamp,\n    metadata: VideoFrameCallbackMetadataLike,\n  ): void => {\n    this.videoFrameHandle = null;\n    const mediaTime =\n      typeof metadata?.mediaTime === \"number\" ? metadata.mediaTime * 1000 : undefined;\n    this.processFrame(typeof mediaTime === \"number\" ? mediaTime : undefined);\n    this.scheduleNextFrame();\n  };\n\n  private shouldUseVideoFrameCallback(): boolean {\n    if (this._settings.syncMode !== \"video-frame\") {\n      return false;\n    }\n    const video = this.videoElement as HTMLVideoElement & {\n      requestVideoFrameCallback?: RequestVideoFrameCallback;\n      cancelVideoFrameCallback?: CancelVideoFrameCallback;\n    };\n    return (\n      Boolean(video) &&\n      typeof video.requestVideoFrameCallback === \"function\" &&\n      typeof video.cancelVideoFrameCallback === \"function\"\n    );\n  }\n\n  private scheduleNextFrame(): void {\n    const video = this.videoElement;\n    if (!video) {\n      return;\n    }\n    if (this.shouldUseVideoFrameCallback()) {\n      this.cancelAnimationFrameRequest();\n      this.cancelVideoFrameCallback();\n      const request = (\n        video as HTMLVideoElement & {\n          requestVideoFrameCallback?: RequestVideoFrameCallback;\n        }\n      ).requestVideoFrameCallback;\n      if (typeof request === \"function\") {\n        this.videoFrameHandle = request.call(video, this.handleVideoFrame);\n      }\n      return;\n    }\n    this.cancelVideoFrameCallback();\n    this.frameId = this.animationFrameProvider.request(this.handleAnimationFrame);\n  }\n\n  private cancelAnimationFrameRequest(): void {\n    if (this.frameId !== null) {\n      this.animationFrameProvider.cancel(this.frameId);\n      this.frameId = null;\n    }\n  }\n\n  private cancelVideoFrameCallback(): void {\n    if (this.videoFrameHandle === null) {\n      return;\n    }\n    const video = this.videoElement as HTMLVideoElement & {\n      cancelVideoFrameCallback?: CancelVideoFrameCallback;\n    };\n    if (video && typeof video.cancelVideoFrameCallback === \"function\") {\n      video.cancelVideoFrameCallback(this.videoFrameHandle);\n    }\n    this.videoFrameHandle = null;\n  }\n\n  private startAnimation(): void {\n    this.stopAnimation();\n    this.scheduleNextFrame();\n  }\n\n  private stopAnimation(): void {\n    this.cancelAnimationFrameRequest();\n    this.cancelVideoFrameCallback();\n  }\n\n  private onSeek(): void {\n    const canvas = this.canvas;\n    const context = this.ctx;\n    const video = this.videoElement;\n    if (!canvas || !context || !video) {\n      return;\n    }\n\n    const nextTime = toMilliseconds(video.currentTime);\n    this.currentTime = nextTime;\n    this.resetFinalPhaseState();\n    this.updatePlaybackProgressState();\n\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n    // シーク時も時間インデックスを用いて範囲を限定\n    // ただし、シーク後のhasShown状態更新のため、範囲外も一部処理する\n    const seekWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n    seekWindowComments.forEach((comment) => {\n      const debugActive = isDebugLoggingEnabled();\n      const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n      if (debugActive) {\n        debugLog(\"comment-evaluate\", {\n          stage: \"seek\",\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          currentTime: this.currentTime,\n          isActive: comment.isActive,\n          hasShown: comment.hasShown,\n        });\n      }\n\n      if (this.isNGComment(comment.text)) {\n        if (debugActive) {\n          debugLog(\"comment-eval-skip\", {\n            preview,\n            vposMs: comment.vposMs,\n            effectiveVposMs: this.getEffectiveCommentVpos(comment),\n            reason: \"ng-runtime\",\n          });\n        }\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n        return;\n      }\n\n      if (comment.isInvisible) {\n        if (debugActive) {\n          debugLog(\"comment-eval-skip\", {\n            preview,\n            vposMs: comment.vposMs,\n            effectiveVposMs: this.getEffectiveCommentVpos(comment),\n            reason: \"invisible\",\n          });\n        }\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.hasShown = true;\n        comment.clearActivation();\n        return;\n      }\n\n      comment.syncWithSettings(this._settings, this.settingsVersion);\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.lane = -1;\n      comment.clearActivation();\n\n      if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n        this.activateComment(\n          comment,\n          context,\n          effectiveWidth,\n          effectiveHeight,\n          prepareOptions,\n          this.currentTime,\n        );\n        return;\n      }\n\n      const effectiveVpos = this.getEffectiveCommentVpos(comment);\n      if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n        comment.hasShown = true;\n      } else {\n        comment.hasShown = false;\n      }\n    });\n\n    if (this._settings.isCommentVisible) {\n      this.lastDrawTime = this.timeSource.now();\n      this.draw();\n    }\n  }\n\n  private setupVideoEventListeners(videoElement: HTMLVideoElement): void {\n    try {\n      const onPlay = (): void => {\n        this.isPlaying = true;\n        this.playbackHasBegun = true;\n        const now = this.timeSource.now();\n        this.lastDrawTime = now;\n\n        // 再生開始時に前エポックのゴーストコメントを掃除\n        // 次のフレームで絶対時間同期を行う\n        if (!this.pendingInitialSync) {\n          this.hardReset();\n        }\n\n        this.comments.forEach((comment) => {\n          comment.lastUpdateTime = now;\n          comment.isPaused = false;\n        });\n      };\n      const onPause = (): void => {\n        this.isPlaying = false;\n        const now = this.timeSource.now();\n        this.comments.forEach((comment) => {\n          comment.lastUpdateTime = now;\n          comment.isPaused = true;\n        });\n      };\n      const onSeeking = (): void => {\n        this.onSeek();\n      };\n      const onSeeked = (): void => {\n        this.onSeek();\n      };\n      const onRateChange = (): void => {\n        this.playbackRate = videoElement.playbackRate;\n        const now = this.timeSource.now();\n        this.comments.forEach((comment) => {\n          comment.lastUpdateTime = now;\n        });\n      };\n      const onLoadedMetadata = (): void => {\n        this.handleVideoMetadataLoaded(videoElement);\n      };\n      const onDurationChange = (): void => {\n        this.duration = Number.isFinite(videoElement.duration)\n          ? toMilliseconds(videoElement.duration)\n          : 0;\n      };\n      const onEmptied = (): void => {\n        this.handleVideoSourceChange();\n      };\n      const onWaiting = (): void => {\n        this.handleVideoStalled();\n      };\n      const onCanPlay = (): void => {\n        this.handleVideoCanPlay();\n      };\n      const onPlaying = (): void => {\n        this.handleVideoCanPlay();\n      };\n\n      videoElement.addEventListener(\"play\", onPlay);\n      videoElement.addEventListener(\"pause\", onPause);\n      videoElement.addEventListener(\"seeking\", onSeeking);\n      videoElement.addEventListener(\"seeked\", onSeeked);\n      videoElement.addEventListener(\"ratechange\", onRateChange);\n      videoElement.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n      videoElement.addEventListener(\"durationchange\", onDurationChange);\n      videoElement.addEventListener(\"emptied\", onEmptied);\n      videoElement.addEventListener(\"waiting\", onWaiting);\n      videoElement.addEventListener(\"canplay\", onCanPlay);\n      videoElement.addEventListener(\"playing\", onPlaying);\n\n      this.addCleanup(() => videoElement.removeEventListener(\"play\", onPlay));\n      this.addCleanup(() => videoElement.removeEventListener(\"pause\", onPause));\n      this.addCleanup(() => videoElement.removeEventListener(\"seeking\", onSeeking));\n      this.addCleanup(() => videoElement.removeEventListener(\"seeked\", onSeeked));\n      this.addCleanup(() => videoElement.removeEventListener(\"ratechange\", onRateChange));\n      this.addCleanup(() => videoElement.removeEventListener(\"loadedmetadata\", onLoadedMetadata));\n      this.addCleanup(() => videoElement.removeEventListener(\"durationchange\", onDurationChange));\n      this.addCleanup(() => videoElement.removeEventListener(\"emptied\", onEmptied));\n      this.addCleanup(() => videoElement.removeEventListener(\"waiting\", onWaiting));\n      this.addCleanup(() => videoElement.removeEventListener(\"canplay\", onCanPlay));\n      this.addCleanup(() => videoElement.removeEventListener(\"playing\", onPlaying));\n    } catch (error) {\n      this.log.error(\"CommentRenderer.setupVideoEventListeners\", error as Error);\n      throw error;\n    }\n  }\n\n  private handleVideoMetadataLoaded(videoElement: HTMLVideoElement): void {\n    this.incrementEpoch(\"metadata-loaded\");\n    this.handleVideoSourceChange(videoElement);\n    this.resize();\n    this.calculateLaneMetrics();\n    // メタデータロード時に絶対時間同期を準備\n    this.hardReset();\n    this.onSeek();\n    this.emitStateSnapshot(\"metadata-loaded\");\n  }\n\n  private handleVideoStalled(): void {\n    const canvas = this.canvas;\n    const ctx = this.ctx;\n    if (!canvas || !ctx) {\n      return;\n    }\n\n    this.isStalled = true;\n\n    // キャンバスをクリア\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n\n    // アクティブコメントの状態を保持しつつ、描画をクリア\n    // （ストール解除後に再描画されるよう、isActiveは維持）\n    this.comments.forEach((comment) => {\n      if (comment.isActive) {\n        comment.lastUpdateTime = this.timeSource.now();\n      }\n    });\n  }\n\n  private handleVideoCanPlay(): void {\n    if (!this.isStalled) {\n      return;\n    }\n\n    this.isStalled = false;\n\n    // 時刻を同期\n    if (this.videoElement) {\n      this.currentTime = toMilliseconds(this.videoElement.currentTime);\n      this.isPlaying = !this.videoElement.paused;\n    }\n\n    // lastDrawTimeを更新して補間計算を正常化\n    this.lastDrawTime = this.timeSource.now();\n\n    // 次のフレームで描画を再開\n    // （アニメーションループが動いているので自動的に再描画される）\n  }\n\n  private handleVideoSourceChange(videoElement?: HTMLVideoElement | null): void {\n    const target = videoElement ?? this.videoElement;\n    if (!target) {\n      this.isPlaying = false;\n      this.resetFinalPhaseState();\n      this.resetCommentActivity();\n      return;\n    }\n    this.incrementEpoch(\"source-change\");\n    this.syncVideoState(target);\n    this.resetFinalPhaseState();\n    this.resetCommentActivity();\n    this.emitStateSnapshot(\"source-change\");\n  }\n\n  private syncVideoState(videoElement: HTMLVideoElement): void {\n    this.duration = Number.isFinite(videoElement.duration)\n      ? toMilliseconds(videoElement.duration)\n      : 0;\n    this.currentTime = toMilliseconds(videoElement.currentTime);\n    this.playbackRate = videoElement.playbackRate;\n    this.isPlaying = !videoElement.paused;\n    this.isStalled = false;\n    this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n    this.lastDrawTime = this.timeSource.now();\n  }\n\n  private resetCommentActivity(): void {\n    const now = this.timeSource.now();\n    const canvas = this.canvas;\n    const context = this.ctx;\n    this.resetFinalPhaseState();\n    this.skipDrawingForCurrentFrame = false;\n    this.isStalled = false;\n    this.pendingInitialSync = false;\n    this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n    if (canvas && context) {\n      const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n      const width = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n      const height = this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n      context.clearRect(0, 0, width, height);\n    }\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n    this.comments.forEach((comment) => {\n      comment.isActive = false;\n      comment.isPaused = !this.isPlaying;\n      comment.hasShown = false;\n      comment.lane = -1;\n      comment.x = comment.virtualStartX;\n      comment.speed = comment.baseSpeed;\n      comment.lastUpdateTime = now;\n      comment.clearActivation();\n    });\n    this.activeComments.clear();\n  }\n\n  private setupVideoChangeDetection(videoElement: HTMLVideoElement, container: HTMLElement): void {\n    if (typeof MutationObserver === \"undefined\") {\n      this.log.debug(\n        \"MutationObserver is not available in this environment. Video change detection is disabled.\",\n      );\n      return;\n    }\n\n    const videoObserver = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === \"attributes\" && mutation.attributeName === \"src\") {\n          const targetNode = mutation.target;\n          let previous: string | null = null;\n          let current: string | null = null;\n          if (targetNode instanceof HTMLVideoElement || targetNode instanceof HTMLSourceElement) {\n            previous = typeof mutation.oldValue === \"string\" ? mutation.oldValue : null;\n            current = targetNode.getAttribute(\"src\");\n          }\n          if (previous === current) {\n            continue;\n          }\n          this.handleVideoSourceChange(videoElement);\n          return;\n        }\n        if (mutation.type === \"childList\") {\n          for (const node of mutation.addedNodes) {\n            if (node instanceof HTMLSourceElement) {\n              this.handleVideoSourceChange(videoElement);\n              return;\n            }\n          }\n          for (const node of mutation.removedNodes) {\n            if (node instanceof HTMLSourceElement) {\n              this.handleVideoSourceChange(videoElement);\n              return;\n            }\n          }\n        }\n      }\n    });\n\n    videoObserver.observe(videoElement, {\n      attributes: true,\n      attributeFilter: [\"src\"],\n      attributeOldValue: true,\n      childList: true,\n      subtree: true,\n    });\n    this.addCleanup(() => videoObserver.disconnect());\n\n    const containerObserver = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type !== \"childList\") {\n          continue;\n        }\n        for (const node of mutation.addedNodes) {\n          const nextVideo = this.extractVideoElement(node);\n          if (nextVideo && nextVideo !== this.videoElement) {\n            this.initialize(nextVideo);\n            return;\n          }\n        }\n        for (const node of mutation.removedNodes) {\n          if (node === this.videoElement) {\n            this.videoElement = null;\n            this.handleVideoSourceChange(null);\n            return;\n          }\n          if (node instanceof Element) {\n            const removedVideo = node.querySelector(\"video\");\n            if (removedVideo && removedVideo === this.videoElement) {\n              this.videoElement = null;\n              this.handleVideoSourceChange(null);\n              return;\n            }\n          }\n        }\n      }\n    });\n\n    containerObserver.observe(container, { childList: true, subtree: true });\n    this.addCleanup(() => containerObserver.disconnect());\n  }\n\n  private extractVideoElement(node: Node): HTMLVideoElement | null {\n    if (node instanceof HTMLVideoElement) {\n      return node;\n    }\n    if (node instanceof Element) {\n      const candidate = node.querySelector(\"video\");\n      if (candidate instanceof HTMLVideoElement) {\n        return candidate;\n      }\n    }\n    return null;\n  }\n\n  private setupVisibilityHandling(): void {\n    if (\n      typeof document === \"undefined\" ||\n      typeof document.addEventListener !== \"function\" ||\n      typeof document.removeEventListener !== \"function\"\n    ) {\n      return;\n    }\n\n    const enforceVisibilityState = (): void => {\n      const state = document.visibilityState;\n      if (state !== \"visible\") {\n        this.stopAnimation();\n        return;\n      }\n      if (!this._settings.isCommentVisible) {\n        return;\n      }\n      // ビジビリティ復帰時にコメント状態をリセット\n      this.handleVisibilityRestore();\n      this.startAnimation();\n    };\n\n    document.addEventListener(\"visibilitychange\", enforceVisibilityState);\n    this.addCleanup(() => document.removeEventListener(\"visibilitychange\", enforceVisibilityState));\n\n    if (document.visibilityState !== \"visible\") {\n      this.stopAnimation();\n    }\n  }\n\n  private handleVisibilityRestore(): void {\n    const canvas = this.canvas;\n    const ctx = this.ctx;\n    const video = this.videoElement;\n    if (!canvas || !ctx || !video) {\n      return;\n    }\n\n    // ビデオ時刻を更新（visibilitychange中に時間が進んでいる可能性がある）\n    this.currentTime = toMilliseconds(video.currentTime);\n    this.isPlaying = !video.paused;\n\n    // 内部状態を完全にクリア\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n\n    // キャンバスをクリア\n    ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n\n    const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n    const now = this.timeSource.now();\n\n    // アクティブウィンドウ内のコメントを再評価\n    const windowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n    windowComments.forEach((comment) => {\n      if (this.isNGComment(comment.text) || comment.isInvisible) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n        return;\n      }\n\n      comment.syncWithSettings(this._settings, this.settingsVersion);\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.lane = -1;\n      comment.clearActivation();\n      comment.lastUpdateTime = now;\n\n      if (this.shouldActivateCommentAtTime(comment, this.currentTime)) {\n        this.activateComment(\n          comment,\n          ctx,\n          effectiveWidth,\n          effectiveHeight,\n          prepareOptions,\n          this.currentTime,\n        );\n      }\n\n      const effectiveVpos = this.getEffectiveCommentVpos(comment);\n      if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n        comment.hasShown = true;\n      } else if (effectiveVpos > this.currentTime) {\n        comment.hasShown = false;\n      }\n    });\n\n    // lastDrawTimeを更新して補間計算を正常化\n    this.lastDrawTime = now;\n  }\n\n  private setupResizeHandling(videoElement: HTMLVideoElement): void {\n    this.cleanupResizeHandling();\n\n    if (this._settings.useContainerResizeObserver && this.isResizeObserverAvailable) {\n      const target = this.resolveResizeObserverTarget(videoElement);\n      const observer = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          const { width, height } = entry.contentRect;\n          if (width > 0 && height > 0) {\n            this.resize(width, height);\n          } else {\n            this.resize();\n          }\n        }\n      });\n      observer.observe(target);\n      this.resizeObserver = observer;\n      this.resizeObserverTarget = target;\n    } else if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\") {\n      const onResize = (): void => {\n        this.resize();\n      };\n      window.addEventListener(\"resize\", onResize);\n      this.addCleanup(() => window.removeEventListener(\"resize\", onResize));\n    } else {\n      this.log.debug(\n        \"Resize handling is disabled because neither ResizeObserver nor window APIs are available.\",\n      );\n    }\n  }\n\n  private cleanupResizeHandling(): void {\n    if (this.resizeObserver && this.resizeObserverTarget) {\n      this.resizeObserver.unobserve(this.resizeObserverTarget);\n    }\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n    this.resizeObserverTarget = null;\n  }\n\n  private setupFullscreenHandling(): void {\n    if (\n      typeof document === \"undefined\" ||\n      typeof document.addEventListener !== \"function\" ||\n      typeof document.removeEventListener !== \"function\"\n    ) {\n      return;\n    }\n\n    const onFullscreenChange = (): void => {\n      void this.handleFullscreenChange();\n    };\n\n    const events = [\n      \"fullscreenchange\",\n      \"webkitfullscreenchange\",\n      \"mozfullscreenchange\",\n      \"MSFullscreenChange\",\n    ];\n\n    events.forEach((eventName) => {\n      document.addEventListener(eventName, onFullscreenChange);\n      this.addCleanup(() => document.removeEventListener(eventName, onFullscreenChange));\n    });\n\n    void this.handleFullscreenChange();\n  }\n\n  private resolveResizeObserverTarget(videoElement: HTMLVideoElement): Element {\n    const fullscreenContainer = this.resolveFullscreenContainer(videoElement);\n    if (fullscreenContainer) {\n      return fullscreenContainer;\n    }\n    return videoElement.parentElement ?? videoElement;\n  }\n\n  private async handleFullscreenChange(): Promise<void> {\n    const canvas = this.canvas;\n    const video = this.videoElement;\n    if (!canvas || !video) {\n      return;\n    }\n\n    const baseContainer = this.containerElement ?? video.parentElement ?? null;\n    const fullscreenElement = this.getFullscreenElement();\n    const nextContainer = this.resolveActiveOverlayContainer(\n      video,\n      baseContainer,\n      fullscreenElement,\n    );\n\n    if (!(nextContainer instanceof HTMLElement)) {\n      return;\n    }\n\n    if (canvas.parentElement !== nextContainer) {\n      this.ensureContainerPositioning(nextContainer);\n      nextContainer.appendChild(canvas);\n    } else {\n      this.ensureContainerPositioning(nextContainer);\n    }\n\n    const fullscreenContainer =\n      fullscreenElement instanceof HTMLElement && fullscreenElement.contains(video)\n        ? fullscreenElement\n        : null;\n    const isFullscreenNow = fullscreenContainer !== null;\n    if (this.fullscreenActive !== isFullscreenNow) {\n      this.fullscreenActive = isFullscreenNow;\n      this.setupResizeHandling(video);\n    }\n\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0\";\n    canvas.style.left = \"0\";\n\n    this.resize();\n  }\n\n  private resolveFullscreenContainer(videoElement: HTMLVideoElement): HTMLElement | null {\n    const fullscreenElement = this.getFullscreenElement();\n    if (!(fullscreenElement instanceof HTMLElement)) {\n      return null;\n    }\n    if (fullscreenElement === videoElement) {\n      return fullscreenElement;\n    }\n    if (fullscreenElement.contains(videoElement)) {\n      return fullscreenElement;\n    }\n    return null;\n  }\n\n  private resolveActiveOverlayContainer(\n    videoElement: HTMLVideoElement,\n    baseContainer: HTMLElement | null,\n    fullscreenElement: Element | null,\n  ): HTMLElement | null {\n    if (fullscreenElement instanceof HTMLElement && fullscreenElement.contains(videoElement)) {\n      if (fullscreenElement instanceof HTMLVideoElement) {\n        if (baseContainer instanceof HTMLElement) {\n          return baseContainer;\n        }\n        return fullscreenElement;\n      }\n      return fullscreenElement;\n    }\n    return baseContainer ?? null;\n  }\n\n  private getFullscreenElement(): Element | null {\n    if (typeof document === \"undefined\") {\n      return null;\n    }\n    const doc = document as Document & {\n      webkitFullscreenElement?: Element | null;\n      msFullscreenElement?: Element | null;\n      mozFullScreenElement?: Element | null;\n    };\n    return (\n      document.fullscreenElement ??\n      doc.webkitFullscreenElement ??\n      doc.mozFullScreenElement ??\n      doc.msFullscreenElement ??\n      null\n    );\n  }\n\n  private addCleanup(task: () => void): void {\n    this.cleanupTasks.push(task);\n  }\n\n  private runCleanupTasks(): void {\n    while (this.cleanupTasks.length > 0) {\n      const task = this.cleanupTasks.pop();\n      try {\n        task?.();\n      } catch (error) {\n        this.log.error(\"CommentRenderer.cleanupTask\", error as Error);\n      }\n    }\n  }\n}\n"],"names":["LEVEL_PRIORITY","fallbackEmitter","level","namespace","args","consoleArgs","createLogger","options","emitter","threshold","emit","logLevel","messages","COMMENT_SIZE_SCALE","FONT_FAMILY_MAP","COLOR_COMMAND_MAP","HEX_COLOR_REGEX","COMMAND_PREFIX_STRIP_REGEX","COMMAND_SUFFIX_STRIP_REGEX","normalizeCommandToken","value","trimmed","normalizeHexColor","command","parseNumericCommandValue","withoutPx","parsed","parseLineHeightValue","numeric","clampLetterSpacing","clampLineHeight","isLayoutCommand","isSizeCommand","isFontCommand","isColorCommand","parseCommentCommands","commands","context","layout","size","font","colorOverride","opacityMultiplier","opacityOverride","isInvisible","letterSpacing","lineHeight","rawCommand","normalizedToken","normalized","lower","separatorIndex","numericValue","clampedOpacityMultiplier","resolvedColor","resolvedOpacityOverride","DEFAULT_MAX_LOGS_PER_CATEGORY","state","categoryCounters","normalizeLimit","limit","rounded","configureDebugLogging","resetDebugCounters","isDebugLoggingEnabled","shouldEmitLog","category","currentCount","debugLog","payload","formatCommentPreview","text","maxLength","visualizeGhostComments","ghosts","ghost","index","dumpRendererState","label","snapshot","logEpochChange","previousEpochId","newEpochId","reason","logger","textMeasurementCaches","getTextMeasurementCache","ctx","cache","measureTextWidth","cacheKey","cached","width","STATIC_VISIBLE_DURATION_MS","HEX_COLOR_PATTERN","STATIC_COMMENT_SIDE_MARGIN_PX","MIN_STATIC_FONT_SIZE_PX","clampOpacity","expandHex","fragment","parseHexComponent","component","resolveFillStyleWithOpacity","color","opacity","match","body","red","green","blue","alpha","combinedAlpha","createPerformanceTimeSource","createDefaultTimeSource","resolveScrollDirection","input","getDirectionSign","direction","Comment","vposMs","settings","dependencies","parsedCommands","visibleWidth","canvasHeight","safeVisibleWidth","baseFontSize","scaledFontSize","rawLines","isStaticTopOrBottom","maxStaticWidth","minimumFontSize","shrinkFactor","initialShrink","iteration","currentShrink","proposedSize","margin","centeredX","maxStart","clampedX","maxReservationWidth","bufferFromWidth","entryBuffer","startLeft","exitLeft","trailingBoundary","trailingEdgeAtStart","widthRatio","hasFixedDuration","visibleDurationMs","clampedRatio","adjustedDuration","visibleDistance","safeVisibleDuration","pixelsPerMs","pixelsPerFrame","travelDistance","preCollisionDistance","safePixelsPerMs","reservationBase","error","playbackRate","isPaused","currentTime","deltaTime","now","total","hitRate","avgCharsPerComment","totalOutlineCalls","totalFillCalls","hasLetterSpacing","isMultiLine","padding","textureWidth","textureHeight","offscreen","offscreenCtx","effectiveOpacity","drawX","linesToRender","lineAdvance","baselineStart","drawSegment","outlineOffsets","drawOutline","outlineAlpha","offsetX","offsetY","line","baseline","drawFill","fillStyle","baseShadowOffset","baseShadowBlur","layer","effectiveShadowAlpha","resolvedFillStyle","interpolatedX","currentCacheKey","settingsVersion","defaultColor","candidate","defaultOpacity","scaled","atTimeMs","currentTimeMs","resolved","targetCtx","measurementCtx","statsTarget","baseDrawX","baselineY","mode","leadingSpaces","leadingSpaceCount","leadingSpaceOffset","effectiveDrawX","trimmedLine","recordDraw","cursorX","char","advance","outlineThickness","offsets","diagonal","maxLineWidth","effectiveLetterSpacing","baseWidth","extraSpacing","totalWidth","computedLineHeightPx","additionalHeight","NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS","BASE_SETTINGS","DEFAULT_RENDERER_SETTINGS","cloneDefaultSettings","COMMENT_OVERLAY_VERSION","toMilliseconds","seconds","sanitizeVposMs","MAX_VISIBLE_DURATION_MS","MIN_VISIBLE_DURATION_MS","MAX_COMMENT_WIDTH_RATIO","COLLISION_BUFFER_RATIO","BASE_COLLISION_BUFFER_PX","ENTRY_BUFFER_PX","RESERVATION_TIME_MARGIN_MS","FINAL_PHASE_THRESHOLD_MS","FINAL_PHASE_MIN_GAP_MS","FINAL_PHASE_MAX_GAP_MS","FINAL_PHASE_ORDER_EPSILON_MS","FINAL_PHASE_MIN_WINDOW_MS","ACTIVE_WINDOW_MS","VIRTUAL_CANVAS_EXTENSION_PX","MIN_LANE_COUNT","DEFAULT_LANE_COUNT","MIN_FONT_SIZE_PX","EDGE_EPSILON","SEEK_DIRECTION_EPSILON_MS","STATIC_COMMENT_VERTICAL_PADDING_RATIO","STATIC_COMMENT_MIN_VERTICAL_PADDING_PX","calculateStaticCommentVerticalPadding","fontSize","normalizeSettings","rawDuration","normalizedDuration","createDefaultAnimationFrameProvider","timeSource","callback","handle","createBrowserCanvasFactory","isRendererSettings","CommentRenderer","settingsOrConfig","maybeConfig","baseSettings","config","configCandidate","explicit","video","container","containerCandidate","canvas","parent","entries","addedComments","entry","preview","normalizedVposMs","comment","a","b","vposMsDiff","effectiveDpr","height","effectiveWidth","effectiveHeight","info","staleThreshold","ghostSet","g","durations","override","fallback","windowStart","durationMs","windowEnd","candidates","diff","baseGap","boundedGap","gap","nextStart","durationNeeded","availableLatestStart","assigned","epsilon","spacing","newSettings","previousUseContainer","previousDirection","previousUseDprScaling","previousSyncMode","directionChanged","useDprScalingChanged","syncModeChanged","attribute","sourceElement","normalizedWords","compiledRegexps","sourceWords","word","sourcePatterns","pattern","regexError","normalizedText","regexp","rect","currentDpr","fallbackWidth","fallbackHeight","measuredWidth","measuredHeight","cssWidth","cssHeight","previousDisplayWidth","previousDisplayHeight","nextDpr","pixelWidth","pixelHeight","scaleX","scaleY","ratio","baseHeight","availableLanes","desired","clamped","frameTimeMs","referenceTime","prepareOptions","isNearEnd","activeWindowComments","debugActive","staticPosition","overrideDuration","maxVisibleDurationMs","minVisibleDurationMs","laneCandidates","newReservation","lane","fallbackLane","reservations","cutoffTime","left","right","mid","reservation","firstValidIndex","filterValid","topFiltered","bottomFiltered","targetVposMs","centerTimeMs","windowMs","startTime","endTime","startIndex","result","i","position","maxIndex","otherPosition","otherDepth","available","localIndex","clampedLaneCount","clampedIndex","displayHeight","commentHeight","baseY","minY","maxY","adjustedY","reserved","timeMs","effectiveVpos","displayWidth","elapsedMs","displacement","videoDuration","finalPhaseWindowEnd","availableTravelTime","requiredSpeedPixelsPerMs","directionSign","projectedX","exitThreshold","displayEnd","laneIndex","laneCount","laneIndices","_","yOffset","yStart","yEnd","earliestRelease","releaseTime","r","sorted","nextA","nextB","staticReserved","preferred","blocked","nextTime","speed","effectiveStart","baseStartTime","totalEndTime","updated","overlapStart","overlapEnd","evaluationTimes","forwardIntersection","backwardIntersection","time","forwardGap","backwardGap","from","to","fromEdges","toEdges","elapsed","rawLeft","leftSign","rightSign","denominator","activeComments","aVpos","bVpos","absoluteTime","pendingId","_now","metadata","mediaTime","request","videoElement","onPlay","onPause","onSeeking","onSeeked","onRateChange","onLoadedMetadata","onDurationChange","onEmptied","onWaiting","onCanPlay","onPlaying","target","videoObserver","mutations","mutation","targetNode","previous","current","node","containerObserver","nextVideo","removedVideo","enforceVisibilityState","observer","onResize","onFullscreenChange","eventName","fullscreenContainer","baseContainer","fullscreenElement","nextContainer","isFullscreenNow","doc","task"],"mappings":"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"}