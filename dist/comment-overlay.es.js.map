{"version":3,"file":"comment-overlay.es.js","sources":["../src/comment/comment-commands.ts","../src/comment/color.ts","../src/comment/time-source.ts","../src/shared/constants.ts","../src/shared/logger.ts","../src/comment/logger.ts","../src/comment/text-measure.ts","../src/comment/prepare.ts","../src/shared/debug.ts","../src/comment/render.ts","../src/comment/direction.ts","../src/comment/comment.ts","../src/config/default-settings.ts","../src/shared/settings.ts","../src/renderer/comments.ts","../src/renderer/final-phase.ts","../src/renderer/playback.ts","../src/renderer/activation.ts","../src/renderer/lanes-prune.ts","../src/renderer/lanes-static.ts","../src/renderer/lanes-activation.ts","../src/renderer/lanes-reservations.ts","../src/renderer/render.ts","../src/renderer/timing.ts","../src/renderer/lifecycle-core.ts","../src/renderer/lifecycle-video-events.ts","../src/renderer/visibility.ts","../src/renderer/resize.ts","../src/renderer/fullscreen.ts","../src/renderer/cleanup.ts","../src/renderer/comment-renderer.ts"],"sourcesContent":["import {\n  type CommentColorCommand,\n  type CommentCommandParseContext,\n  type CommentCommandParseResult,\n  type CommentFontCommand,\n  type CommentHexColorCommand,\n  type CommentLayoutCommand,\n  type CommentSizeCommand,\n} from \"@/shared/types\";\n\nconst COMMENT_SIZE_SCALE: Record<CommentSizeCommand, number> = {\n  small: 0.8,\n  medium: 1,\n  big: 1.4,\n};\n\nconst FONT_FAMILY_MAP: Record<CommentFontCommand, string> = {\n  defont:\n    '\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Hiragino Kaku Gothic Pro\",\"Yu Gothic UI\",\"Yu Gothic\",\"Meiryo\",\"Segoe UI\",\"Osaka\",\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"IPAPGothic\",\"TakaoPGothic\",\"Roboto\",\"Helvetica Neue\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  gothic:\n    '\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"Yu Gothic\",\"Yu Gothic Medium\",\"Meiryo\",\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Segoe UI\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  mincho:\n    '\"MS PMincho\",\"MS Mincho\",\"Hiragino Mincho ProN\",\"Hiragino Mincho Pro\",\"Yu Mincho\",\"Noto Serif CJK JP\",\"Noto Serif JP\",\"Source Han Serif JP\",\"Times New Roman\",\"serif\"',\n};\n\nconst COLOR_COMMAND_MAP: Record<CommentColorCommand, string> = {\n  white: \"#FFFFFC\",\n  red: \"#FF8888\",\n  pink: \"#FFA5CC\",\n  orange: \"#FFBA66\",\n  yellow: \"#FFFFAA\",\n  green: \"#88FF88\",\n  cyan: \"#88FFFF\",\n  blue: \"#8899FF\",\n  purple: \"#D9A5FF\",\n  black: \"#444444\",\n  white2: \"#CC9\",\n  red2: \"#C03\",\n  pink2: \"#F3C\",\n  orange2: \"#F60\",\n  yellow2: \"#990\",\n  green2: \"#0C6\",\n  cyan2: \"#0CC\",\n  blue2: \"#39F\",\n  purple2: \"#63C\",\n  black2: \"#666\",\n};\n\nconst HEX_COLOR_REGEX = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;\n\nconst COMMAND_PREFIX_STRIP_REGEX = /^[,.:;]+/;\nconst COMMAND_SUFFIX_STRIP_REGEX = /[,.:;]+$/;\n\nconst normalizeCommandToken = (value: string): string => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return \"\";\n  }\n  if (HEX_COLOR_REGEX.test(trimmed)) {\n    return trimmed;\n  }\n  const withoutPrefix = trimmed.replace(COMMAND_PREFIX_STRIP_REGEX, \"\");\n  const withoutSuffix = withoutPrefix.replace(COMMAND_SUFFIX_STRIP_REGEX, \"\");\n  return withoutSuffix;\n};\n\nconst normalizeHexColor = (command: CommentHexColorCommand): string | null => {\n  if (!HEX_COLOR_REGEX.test(command)) {\n    return null;\n  }\n  return command.toUpperCase();\n};\n\nconst parseNumericCommandValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  const withoutPx = trimmed.toLowerCase().endsWith(\"px\") ? trimmed.slice(0, -2) : trimmed;\n  const parsed = Number.parseFloat(withoutPx);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst parseLineHeightValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  if (trimmed.endsWith(\"%\")) {\n    const numeric = Number.parseFloat(trimmed.slice(0, -1));\n    if (!Number.isFinite(numeric)) {\n      return null;\n    }\n    return numeric / 100;\n  }\n  return parseNumericCommandValue(trimmed);\n};\n\nconst clampLetterSpacing = (value: number): number => {\n  const maxSpacing = 100;\n  const minSpacing = -100;\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  return Math.min(maxSpacing, Math.max(minSpacing, value));\n};\n\nconst clampLineHeight = (value: number): number => {\n  const minHeight = 0.25;\n  const maxHeight = 5;\n  if (!Number.isFinite(value) || value === 0) {\n    return 1;\n  }\n  return Math.min(maxHeight, Math.max(minHeight, value));\n};\n\nconst isLayoutCommand = (command: string): command is CommentLayoutCommand =>\n  command === \"naka\" || command === \"ue\" || command === \"shita\";\n\nconst isSizeCommand = (command: string): command is CommentSizeCommand =>\n  command === \"small\" || command === \"medium\" || command === \"big\";\n\nconst isFontCommand = (command: string): command is CommentFontCommand =>\n  command === \"defont\" || command === \"gothic\" || command === \"mincho\";\n\nconst isColorCommand = (command: string): command is CommentColorCommand =>\n  command in COLOR_COMMAND_MAP;\n\nexport const parseCommentCommands = (\n  commands: readonly string[],\n  context: CommentCommandParseContext,\n): CommentCommandParseResult => {\n  let layout: CommentLayoutCommand = \"naka\";\n  let size: CommentSizeCommand = \"medium\";\n  let font: CommentFontCommand = \"defont\";\n  let colorOverride: string | null = null;\n  let opacityMultiplier = 1;\n  let opacityOverride: number | null = null;\n  let isInvisible = false;\n  let letterSpacing = 0;\n  let lineHeight = 1;\n\n  for (const rawCommand of commands) {\n    const normalizedToken = normalizeCommandToken(typeof rawCommand === \"string\" ? rawCommand : \"\");\n    if (!normalizedToken) {\n      continue;\n    }\n\n    if (HEX_COLOR_REGEX.test(normalizedToken)) {\n      const normalized = normalizeHexColor(normalizedToken as CommentHexColorCommand);\n      if (normalized) {\n        colorOverride = normalized;\n        continue;\n      }\n    }\n\n    const lower = normalizedToken.toLowerCase();\n\n    if (isLayoutCommand(lower)) {\n      layout = lower;\n      continue;\n    }\n\n    if (isSizeCommand(lower)) {\n      size = lower;\n      continue;\n    }\n\n    if (isFontCommand(lower)) {\n      font = lower;\n      continue;\n    }\n\n    if (isColorCommand(lower)) {\n      colorOverride = COLOR_COMMAND_MAP[lower].toUpperCase();\n      continue;\n    }\n\n    if (lower === \"_live\") {\n      opacityOverride = 0.5;\n      continue;\n    }\n\n    if (lower === \"invisible\") {\n      opacityMultiplier = 0;\n      isInvisible = true;\n      continue;\n    }\n\n    if (lower.startsWith(\"ls:\") || lower.startsWith(\"letterspacing:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseNumericCommandValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          letterSpacing = clampLetterSpacing(numericValue);\n        }\n      }\n      continue;\n    }\n\n    if (lower.startsWith(\"lh:\") || lower.startsWith(\"lineheight:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseLineHeightValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          lineHeight = clampLineHeight(numericValue);\n        }\n      }\n      continue;\n    }\n  }\n\n  const clampedOpacityMultiplier = Math.max(0, Math.min(1, opacityMultiplier));\n  const resolvedColor = (colorOverride ?? context.defaultColor).toUpperCase();\n  const resolvedOpacityOverride =\n    typeof opacityOverride === \"number\" ? Math.max(0, Math.min(1, opacityOverride)) : null;\n\n  return {\n    layout,\n    size,\n    sizeScale: COMMENT_SIZE_SCALE[size],\n    font,\n    fontFamily: FONT_FAMILY_MAP[font],\n    resolvedColor,\n    colorOverride,\n    opacityMultiplier: clampedOpacityMultiplier,\n    opacityOverride: resolvedOpacityOverride,\n    isInvisible,\n    letterSpacing,\n    lineHeight,\n  };\n};\n","const HEX_COLOR_PATTERN = /^#([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;\n\nconst expandHex = (fragment: string): string =>\n  fragment.length === 1 ? fragment.repeat(2) : fragment;\n\nconst parseHexComponent = (component: string): number => Number.parseInt(component, 16);\n\nexport const clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nexport const resolveFillStyleWithOpacity = (color: string, opacity: number): string => {\n  const match = HEX_COLOR_PATTERN.exec(color);\n  if (!match) {\n    return color;\n  }\n  const body = match[1];\n  let red: number;\n  let green: number;\n  let blue: number;\n  let alpha = 1;\n\n  if (body.length === 3 || body.length === 4) {\n    red = parseHexComponent(expandHex(body[0]));\n    green = parseHexComponent(expandHex(body[1]));\n    blue = parseHexComponent(expandHex(body[2]));\n    if (body.length === 4) {\n      alpha = parseHexComponent(expandHex(body[3])) / 255;\n    }\n  } else {\n    red = parseHexComponent(body.slice(0, 2));\n    green = parseHexComponent(body.slice(2, 4));\n    blue = parseHexComponent(body.slice(4, 6));\n    if (body.length === 8) {\n      alpha = parseHexComponent(body.slice(6, 8)) / 255;\n    }\n  }\n\n  const combinedAlpha = clampOpacity(alpha * clampOpacity(opacity));\n  return `rgba(${red}, ${green}, ${blue}, ${combinedAlpha})`;\n};\n","import type { TimeSource } from \"@/shared/types\";\n\nconst createPerformanceTimeSource = (): TimeSource => ({\n  now: () => {\n    if (typeof performance !== \"undefined\" && typeof performance.now === \"function\") {\n      return performance.now();\n    }\n    return Date.now();\n  },\n});\n\nexport const createDefaultTimeSource = (): TimeSource => createPerformanceTimeSource();\n","export const toMilliseconds = (seconds: number): number => seconds * 1000;\n\nexport const sanitizeVposMs = (value: number): number | null => {\n  if (!Number.isFinite(value)) {\n    return null;\n  }\n  if (value < 0) {\n    return null;\n  }\n  return Math.round(value);\n};\n\nexport const MAX_VISIBLE_DURATION_MS = 4_000;\nexport const MIN_VISIBLE_DURATION_MS = 1_800;\nexport const MAX_COMMENT_WIDTH_RATIO = 3;\nexport const COLLISION_BUFFER_RATIO = 0.25;\nexport const BASE_COLLISION_BUFFER_PX = 32;\nexport const ENTRY_BUFFER_PX = 48;\nexport const RESERVATION_TIME_MARGIN_MS = 120;\nexport const FINAL_PHASE_THRESHOLD_MS = 4_000;\nexport const FINAL_PHASE_MIN_GAP_MS = 120;\nexport const FINAL_PHASE_MAX_GAP_MS = 800;\nexport const FINAL_PHASE_ORDER_EPSILON_MS = 2;\nexport const FINAL_PHASE_MIN_WINDOW_MS = 4_000;\nexport const STATIC_VISIBLE_DURATION_MS = 4_000;\nexport const ACTIVE_WINDOW_MS = STATIC_VISIBLE_DURATION_MS + MAX_VISIBLE_DURATION_MS;\nexport const VIRTUAL_CANVAS_EXTENSION_PX = 1_000;\nexport const MIN_LANE_COUNT = 1;\nexport const DEFAULT_LANE_COUNT = 12;\nexport const MIN_FONT_SIZE_PX = 24;\nexport const EDGE_EPSILON = 1e-3;\nexport const SEEK_DIRECTION_EPSILON_MS = 50;\nexport const STATIC_COMMENT_VERTICAL_PADDING_RATIO = 0.05;\nexport const STATIC_COMMENT_MIN_VERTICAL_PADDING_PX = 10;\nexport const STATIC_COMMENT_SIDE_MARGIN_PX = 8;\nexport const MIN_STATIC_FONT_SIZE_PX = 12;\n","import type { LogLevel, Logger, LoggerOptions } from \"@/shared/types\";\n\nconst LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nconst fallbackEmitter = (level: LogLevel, namespace: string, args: unknown[]): void => {\n  const prefix = `[${namespace}]`;\n  const consoleArgs: unknown[] = [prefix, ...args];\n  switch (level) {\n    case \"debug\":\n      console.debug(...consoleArgs);\n      break;\n    case \"info\":\n      console.info(...consoleArgs);\n      break;\n    case \"warn\":\n      console.warn(...consoleArgs);\n      break;\n    case \"error\":\n      console.error(...consoleArgs);\n      break;\n    default:\n      console.log(...consoleArgs);\n  }\n};\n\nexport const createLogger = (namespace: string, options: LoggerOptions = {}): Logger => {\n  const { level = \"info\", emitter = fallbackEmitter } = options;\n  const threshold = LEVEL_PRIORITY[level];\n\n  const emit = (logLevel: LogLevel, args: unknown[]): void => {\n    if (LEVEL_PRIORITY[logLevel] < threshold) {\n      return;\n    }\n    emitter(logLevel, namespace, args);\n  };\n\n  return {\n    debug: (...messages: unknown[]) => emit(\"debug\", messages),\n    info: (...messages: unknown[]) => emit(\"info\", messages),\n    warn: (...messages: unknown[]) => emit(\"warn\", messages),\n    error: (...messages: unknown[]) => emit(\"error\", messages),\n  };\n};\n\nexport type { LogLevel, Logger, LoggerOptions } from \"@/shared/types\";\n","import { createLogger } from \"@/shared/logger\";\n\nexport const commentLogger = createLogger(\"CommentEngine:Comment\");\n","import type { TextMeasurementCache } from \"@/shared/types\";\n\nconst textMeasurementCaches = new WeakMap<CanvasRenderingContext2D, TextMeasurementCache>();\n\nconst getTextMeasurementCache = (ctx: CanvasRenderingContext2D): TextMeasurementCache => {\n  let cache = textMeasurementCaches.get(ctx);\n  if (!cache) {\n    cache = new Map();\n    textMeasurementCaches.set(ctx, cache);\n  }\n  return cache;\n};\n\nexport const measureTextWidth = (ctx: CanvasRenderingContext2D, text: string): number => {\n  if (!ctx) {\n    return 0;\n  }\n  const fontKey = ctx.font ?? \"\";\n  const cacheKey = `${fontKey}::${text}`;\n  const cache = getTextMeasurementCache(ctx);\n  const cached = cache.get(cacheKey);\n  if (cached !== undefined) {\n    return cached;\n  }\n  const width = ctx.measureText(text).width;\n  cache.set(cacheKey, width);\n  return width;\n};\n","import type { CommentPrepareOptions } from \"@/shared/types\";\nimport type { Comment } from \"@/comment/comment\";\nimport {\n  STATIC_VISIBLE_DURATION_MS,\n  STATIC_COMMENT_SIDE_MARGIN_PX,\n  MIN_STATIC_FONT_SIZE_PX,\n} from \"@/shared/constants\";\nimport { commentLogger as logger } from \"@/comment/logger\";\nimport { measureTextWidth } from \"@/comment/text-measure\";\n\nconst ensureLines = (text: string): string[] => {\n  if (text.includes(\"\\n\")) {\n    const rawLines = text.split(/\\r?\\n/);\n    return rawLines.length > 0 ? rawLines : [\"\"];\n  }\n  return [text];\n};\n\nconst clampFontSize = (value: number): number => Math.max(24, value);\n\nconst updateTextMetrics = (comment: Comment, ctx: CanvasRenderingContext2D): void => {\n  let maxLineWidth = 0;\n  const effectiveLetterSpacing = comment.letterSpacing;\n  for (const line of comment.lines) {\n    const baseWidth = measureTextWidth(ctx, line);\n    const extraSpacing = line.length > 1 ? effectiveLetterSpacing * (line.length - 1) : 0;\n    const totalWidth = Math.max(0, baseWidth + extraSpacing);\n    if (totalWidth > maxLineWidth) {\n      maxLineWidth = totalWidth;\n    }\n  }\n  comment.width = maxLineWidth;\n  const computedLineHeightPx = Math.max(\n    1,\n    Math.floor(comment.fontSize * comment.lineHeightMultiplier),\n  );\n  comment.lineHeightPx = computedLineHeightPx;\n  const additionalHeight =\n    comment.lines.length > 1 ? (comment.lines.length - 1) * computedLineHeightPx : 0;\n  comment.height = comment.fontSize + additionalHeight;\n};\n\nexport const prepareComment = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  visibleWidth: number,\n  canvasHeight: number,\n  options: CommentPrepareOptions,\n): void => {\n  try {\n    if (!ctx) {\n      throw new Error(\"Canvas context is required\");\n    }\n    if (!Number.isFinite(visibleWidth) || !Number.isFinite(canvasHeight)) {\n      throw new Error(\"Canvas dimensions must be numbers\");\n    }\n    if (!options) {\n      throw new Error(\"Prepare options are required\");\n    }\n\n    const safeVisibleWidth = Math.max(visibleWidth, 1);\n    const baseFontSize = clampFontSize(Math.floor(canvasHeight * 0.05));\n    const scaledFontSize = clampFontSize(Math.floor(baseFontSize * comment.sizeScale));\n    comment.fontSize = scaledFontSize;\n    ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n    comment.lines = ensureLines(comment.text);\n    updateTextMetrics(comment, ctx);\n\n    const isStaticTopOrBottom =\n      !comment.isScrolling && (comment.layout === \"ue\" || comment.layout === \"shita\");\n    if (isStaticTopOrBottom) {\n      const maxStaticWidth = Math.max(1, safeVisibleWidth - STATIC_COMMENT_SIDE_MARGIN_PX * 2);\n      if (comment.width > maxStaticWidth) {\n        const minimumFontSize = Math.max(\n          MIN_STATIC_FONT_SIZE_PX,\n          Math.min(comment.fontSize, Math.floor(baseFontSize * 0.6)),\n        );\n        const shrinkFactor = maxStaticWidth / Math.max(comment.width, 1);\n        const initialShrink = Math.max(\n          minimumFontSize,\n          Math.floor(comment.fontSize * Math.min(shrinkFactor, 1)),\n        );\n        if (initialShrink < comment.fontSize) {\n          comment.fontSize = initialShrink;\n          ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n          updateTextMetrics(comment, ctx);\n        }\n        let iteration = 0;\n        while (\n          comment.width > maxStaticWidth &&\n          comment.fontSize > minimumFontSize &&\n          iteration < 5\n        ) {\n          const currentShrink = maxStaticWidth / Math.max(comment.width, 1);\n          const proposedSize = Math.max(\n            minimumFontSize,\n            Math.floor(comment.fontSize * Math.max(currentShrink, 0.7)),\n          );\n          if (proposedSize >= comment.fontSize) {\n            comment.fontSize = Math.max(minimumFontSize, comment.fontSize - 1);\n          } else {\n            comment.fontSize = proposedSize;\n          }\n          ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n          updateTextMetrics(comment, ctx);\n          iteration += 1;\n        }\n      }\n    }\n\n    if (!comment.isScrolling) {\n      comment.bufferWidth = 0;\n      const margin = isStaticTopOrBottom ? STATIC_COMMENT_SIDE_MARGIN_PX : 0;\n      const centeredX = Math.max((safeVisibleWidth - comment.width) / 2, margin);\n      const maxStart = Math.max(margin, safeVisibleWidth - comment.width - margin);\n      const clampedX = Math.min(centeredX, Math.max(maxStart, margin));\n      comment.virtualStartX = clampedX;\n      comment.x = clampedX;\n      comment.baseSpeed = 0;\n      comment.speed = 0;\n      comment.speedPixelsPerMs = 0;\n      comment.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.preCollisionDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.totalDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.reservationWidth = comment.width;\n      comment.staticExpiryTimeMs = comment.vposMs + STATIC_VISIBLE_DURATION_MS;\n      comment.lastUpdateTime = comment.getTimeSource().now();\n      comment.isPaused = false;\n      return;\n    }\n\n    comment.staticExpiryTimeMs = null;\n    const maxReservationWidth = measureTextWidth(ctx, \"??\".repeat(150));\n\n    const bufferFromWidth = comment.width * Math.max(options.bufferRatio, 0);\n    comment.bufferWidth = Math.max(options.baseBufferPx, bufferFromWidth);\n    const entryBuffer = Math.max(options.entryBufferPx, comment.bufferWidth);\n\n    const direction = comment.scrollDirection;\n\n    const startLeft =\n      direction === \"rtl\"\n        ? safeVisibleWidth + options.virtualExtension\n        : -comment.width - comment.bufferWidth - options.virtualExtension;\n    const exitLeft =\n      direction === \"rtl\"\n        ? -comment.width - comment.bufferWidth - entryBuffer\n        : safeVisibleWidth + entryBuffer;\n    const trailingBoundary = direction === \"rtl\" ? safeVisibleWidth + entryBuffer : -entryBuffer;\n    const trailingEdgeAtStart =\n      direction === \"rtl\"\n        ? startLeft + comment.width + comment.bufferWidth\n        : startLeft - comment.bufferWidth;\n\n    comment.virtualStartX = startLeft;\n    comment.x = startLeft;\n    comment.exitThreshold = exitLeft;\n\n    const widthRatio = safeVisibleWidth > 0 ? comment.width / safeVisibleWidth : 0;\n    const hasFixedDuration = options.maxVisibleDurationMs === options.minVisibleDurationMs;\n    let visibleDurationMs = options.maxVisibleDurationMs;\n    if (!hasFixedDuration && widthRatio > 1) {\n      const clampedRatio = Math.min(widthRatio, options.maxWidthRatio);\n      const adjustedDuration = options.maxVisibleDurationMs / Math.max(clampedRatio, 1);\n      visibleDurationMs = Math.max(options.minVisibleDurationMs, Math.floor(adjustedDuration));\n    }\n\n    const visibleDistance = safeVisibleWidth + comment.width + comment.bufferWidth + entryBuffer;\n    const safeVisibleDuration = Math.max(visibleDurationMs, 1);\n    const pixelsPerMs = visibleDistance / safeVisibleDuration;\n    const pixelsPerFrame = (pixelsPerMs * 1000) / 60;\n    comment.baseSpeed = pixelsPerFrame;\n    comment.speed = comment.baseSpeed;\n    comment.speedPixelsPerMs = pixelsPerMs;\n\n    const travelDistance = Math.abs(exitLeft - startLeft);\n    const preCollisionDistance =\n      direction === \"rtl\"\n        ? Math.max(0, trailingEdgeAtStart - trailingBoundary)\n        : Math.max(0, trailingBoundary - trailingEdgeAtStart);\n    const safePixelsPerMs = Math.max(pixelsPerMs, Number.EPSILON);\n\n    comment.visibleDurationMs = visibleDurationMs;\n    comment.preCollisionDurationMs = Math.max(0, Math.ceil(preCollisionDistance / safePixelsPerMs));\n    comment.totalDurationMs = Math.max(\n      comment.preCollisionDurationMs,\n      Math.ceil(travelDistance / safePixelsPerMs),\n    );\n\n    const reservationBase = comment.width + comment.bufferWidth + entryBuffer;\n    comment.reservationWidth = Math.min(maxReservationWidth, reservationBase);\n    comment.lastUpdateTime = comment.getTimeSource().now();\n    comment.isPaused = false;\n  } catch (error) {\n    logger.error(\"Comment.prepare\", error as Error, {\n      text: comment.text,\n      visibleWidth,\n      canvasHeight,\n      hasContext: Boolean(ctx),\n    });\n    throw error;\n  }\n};\n\nexport { updateTextMetrics };\n","import type { DebugLoggingOptions, DebugState } from \"@/shared/types\";\nexport type { DebugLoggingOptions } from \"@/shared/types\";\n\nconst DEFAULT_MAX_LOGS_PER_CATEGORY = 5;\n\nconst state: DebugState = {\n  enabled: false,\n  maxLogsPerCategory: DEFAULT_MAX_LOGS_PER_CATEGORY,\n};\n\nconst categoryCounters = new Map<string, number>();\n\nconst normalizeLimit = (limit: number | undefined): number => {\n  if (limit === undefined) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  if (!Number.isFinite(limit)) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  const rounded = Math.max(1, Math.floor(limit));\n  return Math.min(10_000, rounded);\n};\n\nexport const configureDebugLogging = (options: DebugLoggingOptions): void => {\n  state.enabled = Boolean(options.enabled);\n  state.maxLogsPerCategory = normalizeLimit(options.maxLogsPerCategory);\n  if (!state.enabled) {\n    categoryCounters.clear();\n  }\n};\n\nexport const resetDebugCounters = (): void => {\n  categoryCounters.clear();\n};\n\nexport const isDebugLoggingEnabled = (): boolean => state.enabled;\n\nconst shouldEmitLog = (category: string): boolean => {\n  const currentCount = categoryCounters.get(category) ?? 0;\n  if (currentCount >= state.maxLogsPerCategory) {\n    if (currentCount === state.maxLogsPerCategory) {\n      console.debug(`[CommentOverlay][${category}]`, \"Further logs suppressed.\");\n      categoryCounters.set(category, currentCount + 1);\n    }\n    return false;\n  }\n  categoryCounters.set(category, currentCount + 1);\n  return true;\n};\n\nexport const debugLog = (category: string, ...payload: unknown[]): void => {\n  if (!state.enabled) {\n    return;\n  }\n  if (!shouldEmitLog(category)) {\n    return;\n  }\n  console.debug(`[CommentOverlay][${category}]`, ...payload);\n};\n\nexport const formatCommentPreview = (text: string, maxLength = 32): string => {\n  if (text.length <= maxLength) {\n    return text;\n  }\n  return `${text.slice(0, maxLength)}…`;\n};\n\n// 内部状態ダンプ\nexport const dumpRendererState = (\n  label: string,\n  snapshot: {\n    currentTime: number;\n    duration: number;\n    isPlaying: boolean;\n    epochId: number;\n    totalComments: number;\n    activeComments: number;\n    reservedLanes: number;\n    finalPhaseActive: boolean;\n    playbackHasBegun: boolean;\n    isStalled: boolean;\n  },\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  console.group(`[CommentOverlay][state-dump] ${label}`);\n  console.table({\n    \"Current Time\": `${snapshot.currentTime.toFixed(2)}ms`,\n    Duration: `${snapshot.duration.toFixed(2)}ms`,\n    \"Is Playing\": snapshot.isPlaying,\n    \"Epoch ID\": snapshot.epochId,\n    \"Total Comments\": snapshot.totalComments,\n    \"Active Comments\": snapshot.activeComments,\n    \"Reserved Lanes\": snapshot.reservedLanes,\n    \"Final Phase\": snapshot.finalPhaseActive,\n    \"Playback Begun\": snapshot.playbackHasBegun,\n    \"Is Stalled\": snapshot.isStalled,\n  });\n  console.groupEnd();\n};\n\n// エポック変更のログ\nexport const logEpochChange = (\n  previousEpochId: number,\n  newEpochId: number,\n  reason: string,\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  debugLog(\"epoch-change\", `Epoch changed: ${previousEpochId} → ${newEpochId} (reason: ${reason})`);\n};\n","import type { Comment } from \"@/comment/comment\";\nimport type { DrawMode } from \"@/shared/types\";\nimport { clampOpacity, resolveFillStyleWithOpacity } from \"@/comment/color\";\nimport { commentLogger as logger } from \"@/comment/logger\";\nimport { isDebugLoggingEnabled } from \"@/shared/debug\";\nimport { measureTextWidth } from \"@/comment/text-measure\";\n\nconst cacheStats = {\n  hits: 0,\n  misses: 0,\n  creates: 0,\n  fallbacks: 0,\n  outlineCallsInCache: 0,\n  fillCallsInCache: 0,\n  outlineCallsInFallback: 0,\n  fillCallsInFallback: 0,\n  letterSpacingComments: 0,\n  normalComments: 0,\n  multiLineComments: 0,\n  totalCharactersDrawn: 0,\n  lastReported: 0,\n};\n\nconst reportCacheStats = (): void => {\n  if (!isDebugLoggingEnabled()) {\n    return;\n  }\n  const now = performance.now();\n  if (now - cacheStats.lastReported <= 5000) {\n    return;\n  }\n  const total = cacheStats.hits + cacheStats.misses;\n  const hitRate = total > 0 ? (cacheStats.hits / total) * 100 : 0;\n  const avgCharsPerComment =\n    cacheStats.creates > 0\n      ? (cacheStats.totalCharactersDrawn / cacheStats.creates).toFixed(1)\n      : \"0\";\n  const totalOutlineCalls = cacheStats.outlineCallsInCache + cacheStats.outlineCallsInFallback;\n  const totalFillCalls = cacheStats.fillCallsInCache + cacheStats.fillCallsInFallback;\n  console.log(\n    `[TextureCache Stats]`,\n    `\\n  Cache: Hits=${cacheStats.hits}, Misses=${cacheStats.misses}, Hit Rate=${hitRate.toFixed(1)}%`,\n    `\\n  Creates: ${cacheStats.creates}, Fallbacks: ${cacheStats.fallbacks}`,\n    `\\n  Comments: Normal=${cacheStats.normalComments}, LetterSpacing=${cacheStats.letterSpacingComments}, MultiLine=${cacheStats.multiLineComments}`,\n    `\\n  Draw Calls: Outline=${totalOutlineCalls}, Fill=${totalFillCalls}`,\n    `\\n  Avg Characters/Comment: ${avgCharsPerComment}`,\n  );\n  cacheStats.lastReported = now;\n};\n\nconst isOffscreenCanvasSupported = (): boolean => typeof OffscreenCanvas !== \"undefined\";\n\nconst getOutlineOffsets = (fontSize: number): Array<[number, number]> => {\n  const outlineThickness = Math.max(1, Math.round(fontSize * 0.08));\n  const offsets: Array<[number, number]> = [\n    [-outlineThickness, 0],\n    [outlineThickness, 0],\n    [0, -outlineThickness],\n    [0, outlineThickness],\n  ];\n  if (outlineThickness > 1) {\n    const diagonal = Math.max(1, Math.round(outlineThickness * 0.7));\n    offsets.push(\n      [-diagonal, -diagonal],\n      [-diagonal, diagonal],\n      [diagonal, -diagonal],\n      [diagonal, diagonal],\n    );\n  }\n  return offsets;\n};\n\nconst createSegmentDrawer = (\n  comment: Comment,\n  targetCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  measurementCtx: CanvasRenderingContext2D,\n  statsTarget: \"cache\" | \"fallback\",\n  baseDrawX: number,\n): ((line: string, baselineY: number, mode: DrawMode, offsetX?: number) => void) => {\n  return (line, baselineY, mode, offsetX = 0) => {\n    if (line.length === 0) {\n      return;\n    }\n    const leadingSpaces = line.match(/^[\\u3000\\u00A0]+/);\n    const leadingSpaceCount = leadingSpaces ? leadingSpaces[0].length : 0;\n    const leadingSpaceOffset =\n      leadingSpaceCount > 0 ? measureTextWidth(measurementCtx, leadingSpaces![0]) : 0;\n    const effectiveDrawX = baseDrawX + leadingSpaceOffset + offsetX;\n    const trimmedLine = leadingSpaceCount > 0 ? line.substring(leadingSpaceCount) : line;\n\n    const recordDraw = (): void => {\n      if (statsTarget === \"cache\") {\n        if (mode === \"outline\") {\n          cacheStats.outlineCallsInCache++;\n        } else {\n          cacheStats.fillCallsInCache++;\n        }\n      } else if (mode === \"outline\") {\n        cacheStats.outlineCallsInFallback++;\n      } else {\n        cacheStats.fillCallsInFallback++;\n      }\n    };\n\n    if (Math.abs(comment.letterSpacing) < Number.EPSILON) {\n      recordDraw();\n      targetCtx.fillText(trimmedLine, effectiveDrawX, baselineY);\n      return;\n    }\n\n    let cursorX = effectiveDrawX;\n    for (let index = 0; index < trimmedLine.length; index += 1) {\n      const char = trimmedLine[index];\n      recordDraw();\n      targetCtx.fillText(char, cursorX, baselineY);\n      const advance = measureTextWidth(measurementCtx, char);\n      cursorX += advance;\n      if (index < trimmedLine.length - 1) {\n        cursorX += comment.letterSpacing;\n      }\n    }\n  };\n};\n\nconst generateTextureCacheKey = (comment: Comment): string => {\n  return `v2::${comment.text}::${comment.fontSize}::${comment.fontFamily}::${comment.color}::${comment.opacity}::${comment.renderStyle}::${comment.letterSpacing}::${comment.lines.length}`;\n};\n\nconst createTextureCanvas = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n): OffscreenCanvas | null => {\n  if (!isOffscreenCanvasSupported()) {\n    return null;\n  }\n\n  const hasLetterSpacing = Math.abs(comment.letterSpacing) >= Number.EPSILON;\n  const isMultiLine = comment.lines.length > 1;\n  if (hasLetterSpacing) {\n    cacheStats.letterSpacingComments++;\n  }\n  if (isMultiLine) {\n    cacheStats.multiLineComments++;\n  }\n  if (!hasLetterSpacing && !isMultiLine) {\n    cacheStats.normalComments++;\n  }\n  cacheStats.totalCharactersDrawn += comment.text.length;\n\n  const padding = Math.max(10, comment.fontSize * 0.5);\n  const textureWidth = Math.ceil(comment.width + padding * 2);\n  const textureHeight = Math.ceil(comment.height + padding * 2);\n\n  const offscreen = new OffscreenCanvas(textureWidth, textureHeight);\n  const offscreenCtx = offscreen.getContext(\"2d\");\n  if (!offscreenCtx) {\n    return null;\n  }\n\n  offscreenCtx.save();\n  offscreenCtx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n  const effectiveOpacity = clampOpacity(comment.opacity);\n  const drawX = padding;\n  const linesToRender = comment.lines.length > 0 ? comment.lines : [comment.text];\n  const lineAdvance =\n    comment.lines.length > 1 && comment.lineHeightPx > 0 ? comment.lineHeightPx : comment.fontSize;\n  const baselineStart = padding + comment.fontSize;\n  const drawSegment = createSegmentDrawer(comment, offscreenCtx, ctx, \"cache\", drawX);\n  const outlineOffsets = getOutlineOffsets(comment.fontSize);\n\n  const drawOutline = (): void => {\n    const outlineAlpha = clampOpacity(effectiveOpacity * 0.6);\n    offscreenCtx.save();\n    offscreenCtx.fillStyle = `rgba(0, 0, 0, ${outlineAlpha})`;\n    for (const [offsetX, offsetY] of outlineOffsets) {\n      linesToRender.forEach((line: string, index: number) => {\n        const baseline = baselineStart + index * lineAdvance + offsetY;\n        drawSegment(line, baseline, \"outline\", offsetX);\n      });\n    }\n    offscreenCtx.restore();\n  };\n\n  const drawFill = (fillStyle: string): void => {\n    offscreenCtx.save();\n    offscreenCtx.fillStyle = fillStyle;\n    linesToRender.forEach((line: string, index: number) => {\n      const baseline = baselineStart + index * lineAdvance;\n      drawSegment(line, baseline, \"fill\");\n    });\n    offscreenCtx.restore();\n  };\n\n  drawOutline();\n\n  if (comment.renderStyle === \"classic\") {\n    const baseShadowOffset = Math.max(1, comment.fontSize * 0.04);\n    const baseShadowBlur = comment.fontSize * 0.18;\n    type ShadowLayer = Readonly<{\n      offsetXMultiplier: number;\n      offsetYMultiplier: number;\n      blurMultiplier: number;\n      alpha: number;\n      rgb: string;\n    }>;\n    const shadowLayers: ReadonlyArray<ShadowLayer> = [\n      {\n        offsetXMultiplier: 0.9,\n        offsetYMultiplier: 1.1,\n        blurMultiplier: 0.55,\n        alpha: 0.52,\n        rgb: \"20, 28, 40\",\n      },\n      {\n        offsetXMultiplier: 2.4,\n        offsetYMultiplier: 2.7,\n        blurMultiplier: 1.45,\n        alpha: 0.32,\n        rgb: \"0, 0, 0\",\n      },\n      {\n        offsetXMultiplier: -0.7,\n        offsetYMultiplier: -0.6,\n        blurMultiplier: 0.4,\n        alpha: 0.42,\n        rgb: \"255, 255, 255\",\n      },\n    ];\n\n    shadowLayers.forEach((layer) => {\n      const effectiveShadowAlpha = clampOpacity(layer.alpha * effectiveOpacity);\n      offscreenCtx.save();\n      offscreenCtx.shadowColor = `rgba(${layer.rgb}, ${effectiveShadowAlpha})`;\n      offscreenCtx.shadowBlur = baseShadowBlur * layer.blurMultiplier;\n      offscreenCtx.shadowOffsetX = baseShadowOffset * layer.offsetXMultiplier;\n      offscreenCtx.shadowOffsetY = baseShadowOffset * layer.offsetYMultiplier;\n      offscreenCtx.fillStyle = \"rgba(0, 0, 0, 0)\";\n      linesToRender.forEach((line: string, index: number) => {\n        const baseline = baselineStart + index * lineAdvance;\n        drawSegment(line, baseline, \"fill\");\n      });\n      offscreenCtx.restore();\n    });\n  }\n\n  const resolvedFillStyle = resolveFillStyleWithOpacity(comment.color, effectiveOpacity);\n  drawFill(resolvedFillStyle);\n\n  offscreenCtx.restore();\n  return offscreen;\n};\n\nconst drawWithFallback = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  interpolatedX: number | null,\n): void => {\n  cacheStats.fallbacks++;\n  ctx.save();\n  ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n  const effectiveOpacity = clampOpacity(comment.opacity);\n  const drawX = interpolatedX ?? comment.x;\n  const linesToRender = comment.lines.length > 0 ? comment.lines : [comment.text];\n  const lineAdvance =\n    comment.lines.length > 1 && comment.lineHeightPx > 0 ? comment.lineHeightPx : comment.fontSize;\n  const baselineStart = comment.y + comment.fontSize;\n  const drawSegment = createSegmentDrawer(comment, ctx, ctx, \"fallback\", drawX);\n  const outlineOffsets = getOutlineOffsets(comment.fontSize);\n\n  const drawOutline = (): void => {\n    const outlineAlpha = clampOpacity(effectiveOpacity * 0.6);\n    ctx.save();\n    ctx.fillStyle = `rgba(0, 0, 0, ${outlineAlpha})`;\n    for (const [offsetX, offsetY] of outlineOffsets) {\n      linesToRender.forEach((line: string, index: number) => {\n        const baseline = baselineStart + index * lineAdvance + offsetY;\n        drawSegment(line, baseline, \"outline\", offsetX);\n      });\n    }\n    ctx.restore();\n  };\n\n  const drawFill = (fillStyle: string): void => {\n    ctx.save();\n    ctx.fillStyle = fillStyle;\n    linesToRender.forEach((line: string, index: number) => {\n      const baseline = baselineStart + index * lineAdvance;\n      drawSegment(line, baseline, \"fill\");\n    });\n    ctx.restore();\n  };\n\n  drawOutline();\n\n  if (comment.renderStyle === \"classic\") {\n    const baseShadowOffset = Math.max(1, comment.fontSize * 0.04);\n    const baseShadowBlur = comment.fontSize * 0.18;\n    type ShadowLayer = Readonly<{\n      offsetXMultiplier: number;\n      offsetYMultiplier: number;\n      blurMultiplier: number;\n      alpha: number;\n      rgb: string;\n    }>;\n    const shadowLayers: ReadonlyArray<ShadowLayer> = [\n      {\n        offsetXMultiplier: 0.9,\n        offsetYMultiplier: 1.1,\n        blurMultiplier: 0.55,\n        alpha: 0.52,\n        rgb: \"20, 28, 40\",\n      },\n      {\n        offsetXMultiplier: 2.4,\n        offsetYMultiplier: 2.7,\n        blurMultiplier: 1.45,\n        alpha: 0.32,\n        rgb: \"0, 0, 0\",\n      },\n      {\n        offsetXMultiplier: -0.7,\n        offsetYMultiplier: -0.6,\n        blurMultiplier: 0.4,\n        alpha: 0.42,\n        rgb: \"255, 255, 255\",\n      },\n    ];\n\n    shadowLayers.forEach((layer) => {\n      const effectiveShadowAlpha = clampOpacity(layer.alpha * effectiveOpacity);\n      ctx.save();\n      ctx.shadowColor = `rgba(${layer.rgb}, ${effectiveShadowAlpha})`;\n      ctx.shadowBlur = baseShadowBlur * layer.blurMultiplier;\n      ctx.shadowOffsetX = baseShadowOffset * layer.offsetXMultiplier;\n      ctx.shadowOffsetY = baseShadowOffset * layer.offsetYMultiplier;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n      linesToRender.forEach((line: string, index: number) => {\n        const baseline = baselineStart + index * lineAdvance;\n        drawSegment(line, baseline, \"fill\");\n      });\n      ctx.restore();\n    });\n  }\n\n  const resolvedFillStyle = resolveFillStyleWithOpacity(comment.color, effectiveOpacity);\n  drawFill(resolvedFillStyle);\n  ctx.restore();\n};\n\nexport const drawComment = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  interpolatedX: number | null,\n): void => {\n  try {\n    if (!comment.isActive || !ctx) {\n      return;\n    }\n    const currentCacheKey = generateTextureCacheKey(comment);\n    const cachedTexture = comment.getCachedTexture();\n    if (comment.getTextureCacheKey() !== currentCacheKey || !cachedTexture) {\n      cacheStats.misses++;\n      cacheStats.creates++;\n      const created = createTextureCanvas(comment, ctx);\n      comment.setCachedTexture(created);\n      comment.setTextureCacheKey(currentCacheKey);\n    } else {\n      cacheStats.hits++;\n    }\n\n    const texture = comment.getCachedTexture();\n    if (texture) {\n      const drawX = interpolatedX ?? comment.x;\n      const padding = Math.max(10, comment.fontSize * 0.5);\n      ctx.drawImage(texture, drawX - padding, comment.y - padding);\n      reportCacheStats();\n      return;\n    }\n\n    drawWithFallback(comment, ctx, interpolatedX);\n    reportCacheStats();\n  } catch (error) {\n    logger.error(\"Comment.draw\", error as Error, {\n      text: comment.text,\n      isActive: comment.isActive,\n      hasContext: Boolean(ctx),\n      interpolatedX,\n    });\n  }\n};\n","import type { ScrollDirection } from \"@/shared/types\";\n\nexport const resolveScrollDirection = (input: ScrollDirection | string): ScrollDirection =>\n  input === \"ltr\" ? \"ltr\" : \"rtl\";\n\nexport const getDirectionSign = (direction: ScrollDirection): -1 | 1 =>\n  direction === \"ltr\" ? 1 : -1;\n","import type {\n  CommentLayoutCommand,\n  RenderStyle,\n  RendererSettings,\n  ScrollDirection,\n  CommentDependencies,\n  CommentPrepareOptions,\n  TimeSource,\n} from \"@/shared/types\";\nimport { parseCommentCommands } from \"@/comment/comment-commands\";\nimport { clampOpacity } from \"@/comment/color\";\nimport { createDefaultTimeSource } from \"@/comment/time-source\";\nimport { prepareComment } from \"@/comment/prepare\";\nimport { drawComment } from \"@/comment/render\";\nimport { resolveScrollDirection, getDirectionSign } from \"@/comment/direction\";\nimport { commentLogger as logger } from \"@/comment/logger\";\n\nexport class Comment {\n  readonly text: string;\n  readonly vposMs: number;\n  readonly commands: string[];\n  readonly layout: CommentLayoutCommand;\n  readonly isScrolling: boolean;\n  readonly sizeScale: number;\n  readonly opacityMultiplier: number;\n  readonly opacityOverride: number | null;\n  readonly colorOverride: string | null;\n  readonly isInvisible: boolean;\n\n  x = 0;\n  y = 0;\n  width = 0;\n  height = 0;\n  baseSpeed = 0;\n  speed = 0;\n  lane = -1;\n  color: string;\n  fontSize = 0;\n  fontFamily: string;\n  opacity: number;\n  activationTimeMs: number | null = null;\n  staticExpiryTimeMs: number | null = null;\n  isActive = false;\n  hasShown = false;\n  isPaused = false;\n  lastUpdateTime = 0;\n  reservationWidth = 0;\n  bufferWidth = 0;\n  visibleDurationMs = 0;\n  totalDurationMs = 0;\n  preCollisionDurationMs = 0;\n  speedPixelsPerMs = 0;\n  virtualStartX = 0;\n  exitThreshold = 0;\n  scrollDirection: ScrollDirection = \"rtl\";\n  renderStyle: RenderStyle = \"outline-only\";\n  creationIndex = 0;\n  letterSpacing = 0;\n  lineHeightMultiplier = 1;\n  lineHeightPx = 0;\n  lines: string[] = [];\n  epochId = 0;\n  private directionSign: -1 | 1 = -1;\n  private readonly timeSource: TimeSource;\n  private lastSyncedSettingsVersion = -1;\n  private cachedTexture: OffscreenCanvas | null = null;\n  private textureCacheKey = \"\";\n\n  constructor(\n    text: string,\n    vposMs: number,\n    commands: string[] | undefined,\n    settings: RendererSettings,\n    dependencies: CommentDependencies = {},\n  ) {\n    if (typeof text !== \"string\") {\n      throw new Error(\"Comment text must be a string\");\n    }\n    if (!Number.isFinite(vposMs) || vposMs < 0) {\n      throw new Error(\"Comment vposMs must be a non-negative number\");\n    }\n\n    this.text = text;\n    this.vposMs = vposMs;\n    this.commands = Array.isArray(commands) ? [...commands] : [];\n\n    const parsedCommands = parseCommentCommands(this.commands, {\n      defaultColor: settings.commentColor,\n    });\n\n    this.layout = parsedCommands.layout;\n    this.isScrolling = this.layout === \"naka\";\n    this.sizeScale = parsedCommands.sizeScale;\n    this.opacityMultiplier = parsedCommands.opacityMultiplier;\n    this.opacityOverride = parsedCommands.opacityOverride;\n    this.colorOverride = parsedCommands.colorOverride;\n    this.isInvisible = parsedCommands.isInvisible;\n    this.fontFamily = parsedCommands.fontFamily;\n    this.color = parsedCommands.resolvedColor;\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.renderStyle = settings.renderStyle;\n    this.letterSpacing = parsedCommands.letterSpacing;\n    this.lineHeightMultiplier = parsedCommands.lineHeight;\n\n    this.timeSource = dependencies.timeSource ?? createDefaultTimeSource();\n    this.applyScrollDirection(settings.scrollDirection);\n    this.syncWithSettings(settings, dependencies.settingsVersion);\n  }\n\n  prepare(\n    ctx: CanvasRenderingContext2D,\n    visibleWidth: number,\n    canvasHeight: number,\n    options: CommentPrepareOptions,\n  ): void {\n    prepareComment(this, ctx, visibleWidth, canvasHeight, options);\n  }\n\n  draw(ctx: CanvasRenderingContext2D, interpolatedX: number | null = null): void {\n    drawComment(this, ctx, interpolatedX);\n  }\n\n  update(playbackRate = 1.0, isPaused = false): void {\n    try {\n      if (!this.isActive) {\n        this.isPaused = isPaused;\n        return;\n      }\n\n      const currentTime = this.timeSource.now();\n\n      if (!this.isScrolling) {\n        this.isPaused = isPaused;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      if (isPaused) {\n        this.isPaused = true;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      const deltaTime = (currentTime - this.lastUpdateTime) / (1000 / 60);\n      this.speed = this.baseSpeed * playbackRate;\n      this.x += this.speed * deltaTime * this.directionSign;\n      const hasExited =\n        (this.scrollDirection === \"rtl\" && this.x <= this.exitThreshold) ||\n        (this.scrollDirection === \"ltr\" && this.x >= this.exitThreshold);\n      if (hasExited) {\n        this.isActive = false;\n      }\n      this.lastUpdateTime = currentTime;\n      this.isPaused = false;\n    } catch (error) {\n      logger.error(\"Comment.update\", error as Error, {\n        text: this.text,\n        playbackRate,\n        isPaused,\n        isActive: this.isActive,\n      });\n    }\n  }\n\n  syncWithSettings(settings: RendererSettings, settingsVersion?: number): void {\n    const hasSyncedVersion =\n      typeof settingsVersion === \"number\" && settingsVersion === this.lastSyncedSettingsVersion;\n    if (hasSyncedVersion) {\n      return;\n    }\n    this.color = this.getEffectiveColor(settings.commentColor);\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.applyScrollDirection(settings.scrollDirection);\n    this.renderStyle = settings.renderStyle;\n    if (typeof settingsVersion === \"number\") {\n      this.lastSyncedSettingsVersion = settingsVersion;\n    }\n  }\n\n  getEffectiveColor(defaultColor: string): string {\n    const candidate = this.colorOverride ?? defaultColor;\n    if (typeof candidate !== \"string\" || candidate.length === 0) {\n      return defaultColor;\n    }\n    return candidate.toUpperCase();\n  }\n\n  getEffectiveOpacity(defaultOpacity: number): number {\n    if (typeof this.opacityOverride === \"number\") {\n      return clampOpacity(this.opacityOverride);\n    }\n    const scaled = defaultOpacity * this.opacityMultiplier;\n    if (!Number.isFinite(scaled)) {\n      return 0;\n    }\n    return clampOpacity(scaled);\n  }\n\n  markActivated(atTimeMs: number): void {\n    this.activationTimeMs = atTimeMs;\n  }\n\n  clearActivation(): void {\n    this.activationTimeMs = null;\n    if (!this.isScrolling) {\n      this.staticExpiryTimeMs = null;\n    }\n    this.resetTextureCache();\n  }\n\n  hasStaticExpired(currentTimeMs: number): boolean {\n    if (this.isScrolling) {\n      return false;\n    }\n    if (this.staticExpiryTimeMs === null) {\n      return false;\n    }\n    return currentTimeMs >= this.staticExpiryTimeMs;\n  }\n\n  getDirectionSign(): -1 | 1 {\n    return this.directionSign;\n  }\n\n  getTimeSource(): TimeSource {\n    return this.timeSource;\n  }\n\n  getTextureCacheKey(): string {\n    return this.textureCacheKey;\n  }\n\n  setTextureCacheKey(value: string): void {\n    this.textureCacheKey = value;\n  }\n\n  getCachedTexture(): OffscreenCanvas | null {\n    return this.cachedTexture;\n  }\n\n  setCachedTexture(texture: OffscreenCanvas | null): void {\n    this.cachedTexture = texture;\n  }\n\n  resetTextureCache(): void {\n    this.cachedTexture = null;\n    this.textureCacheKey = \"\";\n  }\n\n  private applyScrollDirection(direction: ScrollDirection | string): void {\n    const resolved = resolveScrollDirection(direction);\n    this.scrollDirection = resolved;\n    this.directionSign = getDirectionSign(resolved);\n  }\n}\n","import type { RendererSettings, ReadonlyRendererSettings } from \"@/shared/types\";\n\nexport const NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS = 4_000;\n\nconst BASE_SETTINGS: RendererSettings = {\n  commentColor: \"#FFFFFF\",\n  commentOpacity: 1,\n  isCommentVisible: true,\n  useContainerResizeObserver: true,\n  ngWords: [],\n  ngRegexps: [],\n  scrollDirection: \"rtl\",\n  renderStyle: \"outline-only\",\n  syncMode: \"raf\",\n  scrollVisibleDurationMs: NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS,\n  useFixedLaneCount: false,\n  fixedLaneCount: 12,\n  useDprScaling: true,\n};\n\nexport const DEFAULT_RENDERER_SETTINGS: ReadonlyRendererSettings = BASE_SETTINGS;\n\nexport const cloneDefaultSettings = (): RendererSettings => ({\n  ...BASE_SETTINGS,\n  ngWords: [...BASE_SETTINGS.ngWords],\n  ngRegexps: [...BASE_SETTINGS.ngRegexps],\n});\n\nexport const COMMENT_OVERLAY_VERSION = \"v2.5.2\";\n","import type { RendererSettings, AnimationFrameProvider, TimeSource } from \"@/shared/types\";\nimport {\n  STATIC_COMMENT_MIN_VERTICAL_PADDING_PX,\n  STATIC_COMMENT_VERTICAL_PADDING_RATIO,\n} from \"@/shared/constants\";\n\nexport const clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 1;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nexport const calculateStaticCommentVerticalPadding = (fontSize: number): number =>\n  Math.max(\n    STATIC_COMMENT_MIN_VERTICAL_PADDING_PX,\n    Math.floor(fontSize * STATIC_COMMENT_VERTICAL_PADDING_RATIO),\n  );\n\nexport const normalizeSettings = (settings: RendererSettings): RendererSettings => {\n  const rawDuration = settings.scrollVisibleDurationMs;\n  const normalizedDuration =\n    rawDuration === null || rawDuration === undefined\n      ? null\n      : Number.isFinite(rawDuration)\n        ? Math.max(1, Math.floor(rawDuration))\n        : null;\n\n  return {\n    ...settings,\n    scrollDirection: settings.scrollDirection === \"ltr\" ? \"ltr\" : \"rtl\",\n    commentOpacity: clampOpacity(settings.commentOpacity),\n    renderStyle: settings.renderStyle === \"classic\" ? \"classic\" : \"outline-only\",\n    scrollVisibleDurationMs: normalizedDuration,\n    syncMode: settings.syncMode === \"video-frame\" ? \"video-frame\" : \"raf\",\n    useDprScaling: Boolean(settings.useDprScaling),\n  };\n};\n\nexport const createDefaultAnimationFrameProvider = (\n  timeSource: TimeSource,\n): AnimationFrameProvider => {\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.requestAnimationFrame === \"function\" &&\n    typeof window.cancelAnimationFrame === \"function\"\n  ) {\n    return {\n      request: (callback) => window.requestAnimationFrame(callback),\n      cancel: (handle) => window.cancelAnimationFrame(handle),\n    };\n  }\n  return {\n    request: (callback) => {\n      const timeoutId = globalThis.setTimeout(() => {\n        callback(timeSource.now());\n      }, 16);\n      return timeoutId;\n    },\n    cancel: (handle) => {\n      globalThis.clearTimeout(handle);\n    },\n  };\n};\n\nexport const createBrowserCanvasFactory = (): (() => HTMLCanvasElement) => {\n  if (typeof document === \"undefined\") {\n    return () => {\n      throw new Error(\n        \"Document is not available. Provide a custom createCanvasElement implementation.\",\n      );\n    };\n  }\n  return () => document.createElement(\"canvas\");\n};\n\nexport const isRendererSettings = (input: unknown): input is RendererSettings => {\n  if (!input || typeof input !== \"object\") {\n    return false;\n  }\n  const candidate = input as Record<string, unknown>;\n  return (\n    typeof candidate.commentColor === \"string\" &&\n    typeof candidate.commentOpacity === \"number\" &&\n    typeof candidate.isCommentVisible === \"boolean\"\n  );\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { Comment } from \"@/comment/comment\";\nimport { formatCommentPreview, debugLog } from \"@/shared/debug\";\nimport { EDGE_EPSILON, sanitizeVposMs } from \"@/shared/constants\";\n\nconst addCommentsImpl = function (\n  this: CommentRenderer,\n  entries: ReadonlyArray<{ text: string; vposMs: number; commands?: string[] }>,\n): Comment[] {\n  if (!Array.isArray(entries) || entries.length === 0) {\n    return [];\n  }\n\n  const addedComments: Comment[] = [];\n  this.commentDependencies.settingsVersion = this.settingsVersion;\n\n  for (const entry of entries) {\n    const { text, vposMs, commands = [] } = entry;\n    const preview = formatCommentPreview(text);\n\n    if (this.isNGComment(text)) {\n      debugLog(\"comment-skip-ng\", { preview, vposMs });\n      continue;\n    }\n\n    const normalizedVposMs = sanitizeVposMs(vposMs);\n    if (normalizedVposMs === null) {\n      this.log.warn(\"CommentRenderer.addComment.invalidVpos\", { text, vposMs });\n      debugLog(\"comment-skip-invalid-vpos\", { preview, vposMs });\n      continue;\n    }\n\n    const duplicate =\n      this.comments.some(\n        (comment) => comment.text === text && comment.vposMs === normalizedVposMs,\n      ) ||\n      addedComments.some((comment) => comment.text === text && comment.vposMs === normalizedVposMs);\n    if (duplicate) {\n      debugLog(\"comment-skip-duplicate\", { preview, vposMs: normalizedVposMs });\n      continue;\n    }\n\n    const comment = new Comment(\n      text,\n      normalizedVposMs,\n      commands,\n      this._settings,\n      this.commentDependencies,\n    );\n    comment.creationIndex = this.commentSequence++;\n    comment.epochId = this.epochId;\n    addedComments.push(comment);\n    debugLog(\"comment-added\", {\n      preview,\n      vposMs: normalizedVposMs,\n      commands: comment.commands.length,\n      layout: comment.layout,\n      isScrolling: comment.isScrolling,\n      invisible: comment.isInvisible,\n    });\n  }\n\n  if (addedComments.length === 0) {\n    return [];\n  }\n\n  this.comments.push(...addedComments);\n  if (this.finalPhaseActive) {\n    this.finalPhaseScheduleDirty = true;\n  }\n  this.comments.sort((a, b) => {\n    const vposMsDiff = a.vposMs - b.vposMs;\n    if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n      return vposMsDiff;\n    }\n    return a.creationIndex - b.creationIndex;\n  });\n\n  return addedComments;\n};\n\nconst addCommentImpl = function (\n  this: CommentRenderer,\n  text: string,\n  vposMs: number,\n  commands: string[] = [],\n): Comment | null {\n  const [comment] = this.addComments([{ text, vposMs, commands }]);\n  return comment ?? null;\n};\n\nconst clearCommentsImpl = function (this: CommentRenderer): void {\n  this.comments.length = 0;\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  this.commentSequence = 0;\n  if (this.ctx && this.canvas) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const width = this.displayWidth > 0 ? this.displayWidth : this.canvas.width / effectiveDpr;\n    const height = this.displayHeight > 0 ? this.displayHeight : this.canvas.height / effectiveDpr;\n    this.ctx.clearRect(0, 0, width, height);\n  }\n};\n\nconst resetStateImpl = function (this: CommentRenderer): void {\n  this.clearComments();\n  this.currentTime = 0;\n  this.resetFinalPhaseState();\n  this.playbackHasBegun = false;\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n};\n\nexport const rebuildNgMatchersImpl = function (this: CommentRenderer): void {\n  const settings = this._settings;\n  const ngWords = Array.isArray(settings.ngWords) ? settings.ngWords : [];\n  this.normalizedNgWords = ngWords.filter((word): word is string => typeof word === \"string\");\n  const sourcePatterns = Array.isArray(settings.ngRegexps) ? settings.ngRegexps : [];\n  this.compiledNgRegexps = sourcePatterns\n    .map((entry): RegExp | null => {\n      if (typeof entry !== \"string\") {\n        return null;\n      }\n      try {\n        return new RegExp(entry, \"i\");\n      } catch (error) {\n        this.log.warn(\"CommentRenderer.invalidNgRegexp\", error as Error, { entry });\n        return null;\n      }\n    })\n    .filter((entry): entry is RegExp => Boolean(entry));\n};\n\nconst isNgCommentImpl = function (this: CommentRenderer, text: string): boolean {\n  if (typeof text !== \"string\" || text.length === 0) {\n    return false;\n  }\n  if (this.normalizedNgWords.some((word) => word.length > 0 && text.includes(word))) {\n    return true;\n  }\n  return this.compiledNgRegexps.some((regexp) => regexp.test(text));\n};\n\nexport const registerCommentCollectionMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.addComments = addCommentsImpl;\n  ctor.prototype.addComment = addCommentImpl;\n  ctor.prototype.clearComments = clearCommentsImpl;\n  ctor.prototype.resetState = resetStateImpl;\n  ctor.prototype.rebuildNgMatchers = rebuildNgMatchersImpl;\n  ctor.prototype.isNGComment = isNgCommentImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  EDGE_EPSILON,\n  FINAL_PHASE_MIN_GAP_MS,\n  FINAL_PHASE_MAX_GAP_MS,\n  FINAL_PHASE_ORDER_EPSILON_MS,\n  FINAL_PHASE_MIN_WINDOW_MS,\n  MAX_VISIBLE_DURATION_MS,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"@/shared/constants\";\nimport { dumpRendererState, logEpochChange } from \"@/shared/debug\";\nimport type { EpochChangeInfo, RendererStateSnapshot } from \"@/shared/types\";\n\nconst hardResetImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n\n  this.incrementEpoch(\"manual-reset\");\n\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n\n  this.comments.forEach((comment) => {\n    comment.isActive = false;\n    comment.hasShown = false;\n    comment.lane = -1;\n    comment.clearActivation();\n    comment.epochId = this.epochId;\n  });\n\n  if (canvas && ctx) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n  }\n\n  this.pendingInitialSync = true;\n  this.resetFinalPhaseState();\n  this.emitStateSnapshot(\"hardReset\");\n};\n\nconst resetFinalPhaseStateImpl = function (this: CommentRenderer): void {\n  this.finalPhaseActive = false;\n  this.finalPhaseStartTime = null;\n  this.finalPhaseScheduleDirty = false;\n  this.finalPhaseVposOverrides.clear();\n};\n\nconst incrementEpochImpl = function (\n  this: CommentRenderer,\n  reason: \"source-change\" | \"metadata-loaded\" | \"manual-reset\",\n): void {\n  const previousEpochId = this.epochId;\n  this.epochId += 1;\n\n  logEpochChange(previousEpochId, this.epochId, reason);\n\n  if (this.eventHooks.onEpochChange) {\n    const info: EpochChangeInfo = {\n      previousEpochId,\n      newEpochId: this.epochId,\n      reason,\n      timestamp: this.timeSource.now(),\n    };\n    try {\n      this.eventHooks.onEpochChange(info);\n    } catch (error) {\n      this.log.error(\"CommentRenderer.incrementEpoch.callback\", error as Error, { info });\n    }\n  }\n\n  this.comments.forEach((comment) => {\n    comment.epochId = this.epochId;\n  });\n};\n\nconst emitStateSnapshotImpl = function (this: CommentRenderer, label: string): void {\n  const now = this.timeSource.now();\n  if (now - this.lastSnapshotEmitTime < this.snapshotEmitThrottleMs) {\n    return;\n  }\n\n  const snapshot: RendererStateSnapshot = {\n    currentTime: this.currentTime,\n    duration: this.duration,\n    isPlaying: this.isPlaying,\n    epochId: this.epochId,\n    totalComments: this.comments.length,\n    activeComments: this.activeComments.size,\n    reservedLanes: this.reservedLanes.size,\n    finalPhaseActive: this.finalPhaseActive,\n    playbackHasBegun: this.playbackHasBegun,\n    isStalled: this.isStalled,\n  };\n\n  dumpRendererState(label, snapshot);\n\n  if (this.eventHooks.onStateSnapshot) {\n    try {\n      this.eventHooks.onStateSnapshot(snapshot);\n    } catch (error) {\n      this.log.error(\"CommentRenderer.emitStateSnapshot.callback\", error as Error);\n    }\n  }\n\n  this.lastSnapshotEmitTime = now;\n};\n\nconst getEffectiveCommentVposImpl = function (this: CommentRenderer, comment: Comment): number {\n  if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n  const override = this.finalPhaseVposOverrides.get(comment);\n  return override ?? comment.vposMs;\n};\n\nconst getFinalPhaseDisplayDurationImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n): number {\n  if (!comment.isScrolling) {\n    return STATIC_VISIBLE_DURATION_MS;\n  }\n\n  const durations: number[] = [];\n  if (Number.isFinite(comment.visibleDurationMs) && comment.visibleDurationMs > 0) {\n    durations.push(comment.visibleDurationMs);\n  }\n  if (Number.isFinite(comment.totalDurationMs) && comment.totalDurationMs > 0) {\n    durations.push(comment.totalDurationMs);\n  }\n\n  if (durations.length > 0) {\n    return Math.max(...durations);\n  }\n\n  return MAX_VISIBLE_DURATION_MS;\n};\n\nconst resolveFinalPhaseVposImpl = function (this: CommentRenderer, comment: Comment): number {\n  if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n    this.finalPhaseVposOverrides.delete(comment);\n    return comment.vposMs;\n  }\n  if (this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n  const override = this.finalPhaseVposOverrides.get(comment);\n  if (override !== undefined) {\n    return override;\n  }\n  const fallback = Math.max(comment.vposMs, this.finalPhaseStartTime);\n  this.finalPhaseVposOverrides.set(comment, fallback);\n  return fallback;\n};\n\nconst recomputeFinalPhaseTimelineImpl = function (this: CommentRenderer): void {\n  if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n    this.finalPhaseVposOverrides.clear();\n    this.finalPhaseScheduleDirty = false;\n    return;\n  }\n\n  const windowStart = this.finalPhaseStartTime;\n  const durationMs = this.duration > 0 ? this.duration : windowStart + FINAL_PHASE_MIN_WINDOW_MS;\n  const windowEnd = Math.max(windowStart + FINAL_PHASE_MIN_WINDOW_MS, durationMs);\n\n  const candidates = this.comments\n    .filter((comment) => {\n      if (comment.hasShown) {\n        return false;\n      }\n      if (comment.isInvisible) {\n        return false;\n      }\n      if (this.isNGComment(comment.text)) {\n        return false;\n      }\n      return comment.vposMs >= windowStart - ACTIVE_WINDOW_MS;\n    })\n    .sort((a, b) => {\n      const diff = a.vposMs - b.vposMs;\n      if (Math.abs(diff) > EDGE_EPSILON) {\n        return diff;\n      }\n      return a.creationIndex - b.creationIndex;\n    });\n\n  this.finalPhaseVposOverrides.clear();\n\n  if (candidates.length === 0) {\n    this.finalPhaseScheduleDirty = false;\n    return;\n  }\n\n  const windowSpan = Math.max(windowEnd - windowStart, FINAL_PHASE_MIN_WINDOW_MS);\n  const baseGap = windowSpan / Math.max(candidates.length, 1);\n  const boundedGap = Number.isFinite(baseGap) ? baseGap : FINAL_PHASE_MIN_GAP_MS;\n  const gap = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(boundedGap, FINAL_PHASE_MAX_GAP_MS));\n\n  let nextStart = windowStart;\n  candidates.forEach((comment, index) => {\n    const durationNeeded = Math.max(1, this.getFinalPhaseDisplayDuration(comment));\n    const availableLatestStart = windowEnd - durationNeeded;\n    let assigned = Math.max(windowStart, Math.min(nextStart, availableLatestStart));\n    if (!Number.isFinite(assigned)) {\n      assigned = windowStart;\n    }\n    const epsilon = FINAL_PHASE_ORDER_EPSILON_MS * index;\n    if (assigned + epsilon <= availableLatestStart) {\n      assigned += epsilon;\n    }\n    this.finalPhaseVposOverrides.set(comment, assigned);\n    const spacing = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(durationNeeded / 2, gap));\n    nextStart = assigned + spacing;\n  });\n\n  this.finalPhaseScheduleDirty = false;\n};\n\nexport const registerFinalPhaseMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.hardReset = hardResetImpl;\n  ctor.prototype.resetFinalPhaseState = resetFinalPhaseStateImpl;\n  ctor.prototype.incrementEpoch = incrementEpochImpl;\n  ctor.prototype.emitStateSnapshot = emitStateSnapshotImpl;\n  ctor.prototype.getEffectiveCommentVpos = getEffectiveCommentVposImpl;\n  ctor.prototype.getFinalPhaseDisplayDuration = getFinalPhaseDisplayDurationImpl;\n  ctor.prototype.resolveFinalPhaseVpos = resolveFinalPhaseVposImpl;\n  ctor.prototype.recomputeFinalPhaseTimeline = recomputeFinalPhaseTimelineImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { SEEK_DIRECTION_EPSILON_MS } from \"@/shared/constants\";\n\nconst shouldSuppressRenderingImpl = function (this: CommentRenderer): boolean {\n  return !this.playbackHasBegun && !this.isPlaying && this.currentTime <= SEEK_DIRECTION_EPSILON_MS;\n};\n\nconst updatePlaybackProgressStateImpl = function (this: CommentRenderer): void {\n  if (this.playbackHasBegun) {\n    return;\n  }\n  if (this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS) {\n    this.playbackHasBegun = true;\n  }\n};\n\nexport const registerPlaybackHelpers = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.shouldSuppressRendering = shouldSuppressRenderingImpl;\n  ctor.prototype.updatePlaybackProgressState = updatePlaybackProgressStateImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { CommentPrepareOptions } from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  BASE_COLLISION_BUFFER_PX,\n  COLLISION_BUFFER_RATIO,\n  ENTRY_BUFFER_PX,\n  FINAL_PHASE_THRESHOLD_MS,\n  MAX_COMMENT_WIDTH_RATIO,\n  MAX_VISIBLE_DURATION_MS,\n  MIN_VISIBLE_DURATION_MS,\n  SEEK_DIRECTION_EPSILON_MS,\n  VIRTUAL_CANVAS_EXTENSION_PX,\n  toMilliseconds,\n} from \"@/shared/constants\";\nimport { formatCommentPreview, debugLog, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst updateCommentsImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas || !context) {\n    return;\n  }\n\n  const referenceTime =\n    typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n  this.currentTime = referenceTime;\n  this.playbackRate = video.playbackRate;\n  this.isPlaying = !video.paused;\n  this.updatePlaybackProgressState();\n  this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n  if (this.skipDrawingForCurrentFrame) {\n    return;\n  }\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const isNearEnd =\n    this.duration > 0 && this.duration - this.currentTime <= FINAL_PHASE_THRESHOLD_MS;\n\n  if (isNearEnd && !this.finalPhaseActive) {\n    this.finalPhaseActive = true;\n    this.finalPhaseStartTime = this.currentTime;\n    this.finalPhaseVposOverrides.clear();\n    this.finalPhaseScheduleDirty = true;\n    context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    this.comments.forEach((comment) => {\n      comment.isActive = false;\n      comment.clearActivation();\n    });\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n  }\n\n  if (!isNearEnd && this.finalPhaseActive) {\n    this.resetFinalPhaseState();\n  }\n\n  if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n\n  this.pruneStaticLaneReservations(this.currentTime);\n\n  const activeWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  for (const comment of activeWindowComments) {\n    const debugActive = isDebugLoggingEnabled();\n    const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n    if (debugActive) {\n      debugLog(\"comment-evaluate\", {\n        stage: \"update\",\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: this.getEffectiveCommentVpos(comment),\n        currentTime: this.currentTime,\n        isActive: comment.isActive,\n        hasShown: comment.hasShown,\n      });\n    }\n\n    if (this.isNGComment(comment.text)) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"ng-runtime\",\n        });\n      }\n      continue;\n    }\n    if (comment.isInvisible) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"invisible\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.hasShown = true;\n      comment.clearActivation();\n      continue;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n    }\n\n    if (comment.isActive) {\n      if (comment.layout !== \"naka\" && comment.hasStaticExpired(this.currentTime)) {\n        const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n        this.releaseStaticLane(staticPosition, comment.lane);\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n        continue;\n      }\n\n      if (\n        comment.layout === \"naka\" &&\n        this.getEffectiveCommentVpos(comment) > this.currentTime + SEEK_DIRECTION_EPSILON_MS\n      ) {\n        comment.x = comment.virtualStartX;\n        comment.lastUpdateTime = this.timeSource.now();\n        continue;\n      }\n\n      comment.hasShown = true;\n      comment.update(this.playbackRate, !this.isPlaying);\n      if (!comment.isScrolling && comment.hasStaticExpired(this.currentTime)) {\n        const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n        this.releaseStaticLane(staticPosition, comment.lane);\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n  }\n\n  if (this.isPlaying) {\n    for (const comment of this.comments) {\n      if (\n        comment.isActive &&\n        comment.isScrolling &&\n        ((comment.scrollDirection === \"rtl\" && comment.x <= comment.exitThreshold) ||\n          (comment.scrollDirection === \"ltr\" && comment.x >= comment.exitThreshold))\n      ) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n  }\n};\n\nconst buildPrepareOptionsImpl = function (\n  this: CommentRenderer,\n  visibleWidth: number,\n): CommentPrepareOptions {\n  const overrideDuration = this._settings.scrollVisibleDurationMs;\n  let maxVisibleDurationMs = MAX_VISIBLE_DURATION_MS;\n  let minVisibleDurationMs = MIN_VISIBLE_DURATION_MS;\n\n  if (overrideDuration !== null) {\n    maxVisibleDurationMs = overrideDuration;\n    minVisibleDurationMs = Math.max(1, Math.min(overrideDuration, MIN_VISIBLE_DURATION_MS));\n  }\n\n  return {\n    visibleWidth,\n    virtualExtension: VIRTUAL_CANVAS_EXTENSION_PX,\n    maxVisibleDurationMs,\n    minVisibleDurationMs,\n    maxWidthRatio: MAX_COMMENT_WIDTH_RATIO,\n    bufferRatio: COLLISION_BUFFER_RATIO,\n    baseBufferPx: BASE_COLLISION_BUFFER_PX,\n    entryBufferPx: ENTRY_BUFFER_PX,\n  };\n};\n\nconst findAvailableLaneImpl = function (this: CommentRenderer, comment: Comment): number {\n  const currentTime = this.currentTime;\n  this.pruneLaneReservations(currentTime);\n  this.pruneStaticLaneReservations(currentTime);\n  const laneCandidates = this.getLanePriorityOrder(currentTime);\n  const newReservation = this.createLaneReservation(comment, currentTime);\n\n  for (const lane of laneCandidates) {\n    if (this.isLaneAvailable(lane, newReservation, currentTime)) {\n      this.storeLaneReservation(lane, newReservation);\n      return lane;\n    }\n  }\n\n  const fallbackLane = laneCandidates[0] ?? 0;\n  this.storeLaneReservation(fallbackLane, newReservation);\n  return fallbackLane;\n};\n\nexport const registerActivationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.updateComments = updateCommentsImpl;\n  ctor.prototype.buildPrepareOptions = buildPrepareOptionsImpl;\n  ctor.prototype.findAvailableLane = findAvailableLaneImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { LaneReservation, StaticLaneReservation } from \"@/shared/types\";\nimport { RESERVATION_TIME_MARGIN_MS } from \"@/shared/constants\";\n\nconst findFirstValidReservationIndexImpl = function (\n  this: CommentRenderer,\n  reservations: LaneReservation[],\n  cutoffTime: number,\n): number {\n  let left = 0;\n  let right = reservations.length;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const reservation = reservations[mid];\n    if (\n      reservation !== undefined &&\n      reservation.totalEndTime + RESERVATION_TIME_MARGIN_MS <= cutoffTime\n    ) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return left;\n};\n\nconst pruneLaneReservationsImpl = function (this: CommentRenderer, currentTime: number): void {\n  for (const [lane, reservations] of this.reservedLanes.entries()) {\n    const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n    if (firstValidIndex >= reservations.length) {\n      this.reservedLanes.delete(lane);\n    } else if (firstValidIndex > 0) {\n      this.reservedLanes.set(lane, reservations.slice(firstValidIndex));\n    }\n  }\n};\n\nconst pruneStaticLaneReservationsImpl = function (\n  this: CommentRenderer,\n  currentTime: number,\n): void {\n  const filterValid = (reservations: StaticLaneReservation[]): StaticLaneReservation[] =>\n    reservations.filter((reservation) => reservation.releaseTime > currentTime);\n\n  const topFiltered = filterValid(this.topStaticLaneReservations);\n  const bottomFiltered = filterValid(this.bottomStaticLaneReservations);\n\n  this.topStaticLaneReservations.length = 0;\n  this.topStaticLaneReservations.push(...topFiltered);\n\n  this.bottomStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.push(...bottomFiltered);\n};\n\nexport const registerLanePruneMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.findFirstValidReservationIndex = findFirstValidReservationIndexImpl;\n  ctor.prototype.pruneLaneReservations = pruneLaneReservationsImpl;\n  ctor.prototype.pruneStaticLaneReservations = pruneStaticLaneReservationsImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { Comment } from \"@/comment/comment\";\n\nconst findCommentIndexAtOrAfterImpl = function (\n  this: CommentRenderer,\n  targetVposMs: number,\n): number {\n  let left = 0;\n  let right = this.comments.length;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const comment = this.comments[mid];\n    if (comment !== undefined && comment.vposMs < targetVposMs) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return left;\n};\n\nconst getCommentsInTimeWindowImpl = function (\n  this: CommentRenderer,\n  centerTimeMs: number,\n  windowMs: number,\n): Comment[] {\n  if (this.comments.length === 0) {\n    return [];\n  }\n  const startTime = centerTimeMs - windowMs;\n  const endTime = centerTimeMs + windowMs;\n  const startIndex = this.findCommentIndexAtOrAfter(startTime);\n  const result: Comment[] = [];\n  for (let i = startIndex; i < this.comments.length; i++) {\n    const comment = this.comments[i];\n    if (!comment) {\n      continue;\n    }\n    if (comment.vposMs > endTime) {\n      break;\n    }\n    result.push(comment);\n  }\n  return result;\n};\n\nconst getStaticReservationsImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n): CommentRenderer[\"topStaticLaneReservations\"] {\n  return position === \"ue\" ? this.topStaticLaneReservations : this.bottomStaticLaneReservations;\n};\n\nconst getStaticLaneDepthImpl = function (this: CommentRenderer, position: \"ue\" | \"shita\"): number {\n  return position === \"ue\"\n    ? this.topStaticLaneReservations.length\n    : this.bottomStaticLaneReservations.length;\n};\n\nconst getStaticLaneLimitImpl = function (this: CommentRenderer, position: \"ue\" | \"shita\"): number {\n  const otherPosition = position === \"ue\" ? \"shita\" : \"ue\";\n  const otherDepth = this.getStaticLaneDepth(otherPosition);\n  const available = this.laneCount - otherDepth;\n  if (available <= 0) {\n    return -1;\n  }\n  return available - 1;\n};\n\nconst getGlobalLaneIndexForBottomImpl = function (\n  this: CommentRenderer,\n  localIndex: number,\n): number {\n  return Math.max(0, this.laneCount - 1 - localIndex);\n};\n\nconst resolveStaticCommentOffsetImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  lane: number,\n  displayHeight: number,\n  comment: Comment,\n): number {\n  const effectiveHeight = Math.max(1, displayHeight);\n  const commentHeight = Math.max(comment.height, comment.fontSize);\n  const padding = Math.max(1, Math.floor(comment.fontSize * 0.05));\n\n  if (position === \"ue\") {\n    const baseY = lane * this.laneHeight;\n    const minY = padding;\n    const maxY = Math.max(padding, effectiveHeight - commentHeight - padding);\n    return Math.max(minY, Math.min(baseY, maxY));\n  }\n\n  const targetBottomY = effectiveHeight - lane * this.laneHeight;\n  const adjustedY = targetBottomY - commentHeight - padding;\n  return Math.max(padding, adjustedY);\n};\n\nconst getStaticReservedLaneSetImpl = function (this: CommentRenderer): Set<number> {\n  const reserved = new Set<number>();\n  for (const reservation of this.topStaticLaneReservations) {\n    reserved.add(reservation.lane);\n  }\n  for (const reservation of this.bottomStaticLaneReservations) {\n    reserved.add(this.getGlobalLaneIndexForBottom(reservation.lane));\n  }\n  return reserved;\n};\n\nexport const registerLaneStaticMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.findCommentIndexAtOrAfter = findCommentIndexAtOrAfterImpl;\n  ctor.prototype.getCommentsInTimeWindow = getCommentsInTimeWindowImpl;\n  ctor.prototype.getStaticReservations = getStaticReservationsImpl;\n  ctor.prototype.getStaticLaneDepth = getStaticLaneDepthImpl;\n  ctor.prototype.getStaticLaneLimit = getStaticLaneLimitImpl;\n  ctor.prototype.getGlobalLaneIndexForBottom = getGlobalLaneIndexForBottomImpl;\n  ctor.prototype.resolveStaticCommentOffset = resolveStaticCommentOffsetImpl;\n  ctor.prototype.getStaticReservedLaneSet = getStaticReservedLaneSetImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { CommentPrepareOptions } from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  EDGE_EPSILON,\n  FINAL_PHASE_MIN_WINDOW_MS,\n  SEEK_DIRECTION_EPSILON_MS,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"@/shared/constants\";\nimport { calculateStaticCommentVerticalPadding } from \"@/shared/settings\";\nimport { debugLog, formatCommentPreview, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst shouldActivateCommentAtTimeImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n  timeMs: number,\n  preview: string = \"\",\n): boolean {\n  const debugActive = preview.length > 0 && isDebugLoggingEnabled();\n  const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n  if (\n    this.finalPhaseActive &&\n    this.finalPhaseStartTime !== null &&\n    comment.vposMs < this.finalPhaseStartTime - EDGE_EPSILON\n  ) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"final-phase-trimmed\",\n        finalPhaseStartTime: this.finalPhaseStartTime,\n      });\n    }\n    this.finalPhaseVposOverrides.delete(comment);\n    return false;\n  }\n\n  if (comment.isInvisible) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"invisible\",\n      });\n    }\n    return false;\n  }\n  if (comment.isActive) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"already-active\",\n      });\n    }\n    return false;\n  }\n  if (comment.hasShown && effectiveVpos <= timeMs) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"already-shown\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n  if (effectiveVpos > timeMs + SEEK_DIRECTION_EPSILON_MS) {\n    if (debugActive) {\n      debugLog(\"comment-eval-pending\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"future\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n  if (effectiveVpos < timeMs - ACTIVE_WINDOW_MS) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"expired-window\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n\n  if (debugActive) {\n    debugLog(\"comment-eval-ready\", {\n      preview,\n      vposMs: comment.vposMs,\n      effectiveVposMs: effectiveVpos,\n      currentTime: timeMs,\n    });\n  }\n  return true;\n};\n\nconst activateCommentImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n  context: CanvasRenderingContext2D,\n  displayWidth: number,\n  displayHeight: number,\n  options: CommentPrepareOptions,\n  referenceTime: number,\n): void {\n  comment.prepare(context, displayWidth, displayHeight, options);\n  const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n  if (isDebugLoggingEnabled()) {\n    debugLog(\"comment-prepared\", {\n      preview: formatCommentPreview(comment.text),\n      layout: comment.layout,\n      isScrolling: comment.isScrolling,\n      width: comment.width,\n      height: comment.height,\n      bufferWidth: comment.bufferWidth,\n      visibleDurationMs: comment.visibleDurationMs,\n      effectiveVposMs: effectiveVpos,\n    });\n  }\n\n  if (comment.layout === \"naka\") {\n    const elapsedMs = Math.max(0, referenceTime - effectiveVpos);\n    const displacement = comment.speedPixelsPerMs * elapsedMs;\n\n    if (this.finalPhaseActive && this.finalPhaseStartTime !== null) {\n      const videoDuration =\n        this.duration > 0 ? this.duration : this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS;\n      const finalPhaseWindowEnd = Math.max(\n        this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS,\n        videoDuration,\n      );\n      const totalTravelDistance = comment.width + displayWidth;\n      const projectedTravelMs =\n        totalTravelDistance > 0 ? totalTravelDistance / Math.max(comment.speedPixelsPerMs, 1) : 0;\n      const projectedEndTime = effectiveVpos + projectedTravelMs;\n      if (projectedEndTime > finalPhaseWindowEnd) {\n        const remainingTime = finalPhaseWindowEnd - referenceTime;\n        const allowedTravel = Math.max(0, remainingTime) * comment.speedPixelsPerMs;\n        const startX =\n          comment.scrollDirection === \"rtl\"\n            ? Math.max(comment.virtualStartX - displacement, displayWidth - allowedTravel)\n            : Math.min(comment.virtualStartX + displacement, allowedTravel - comment.width);\n        comment.x = startX;\n      } else {\n        comment.x =\n          comment.scrollDirection === \"rtl\"\n            ? comment.virtualStartX - displacement\n            : comment.virtualStartX + displacement;\n      }\n    } else {\n      comment.x =\n        comment.scrollDirection === \"rtl\"\n          ? comment.virtualStartX - displacement\n          : comment.virtualStartX + displacement;\n    }\n    const laneIndex = this.findAvailableLane(comment);\n    comment.lane = laneIndex;\n    const laneHeight = Math.max(1, this.laneHeight);\n    const maxY = Math.max(0, displayHeight - comment.height);\n    const laneY = laneIndex * laneHeight;\n    comment.y = Math.max(0, Math.min(laneY, maxY));\n  } else {\n    const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n    const laneIndex = this.assignStaticLane(staticPosition, comment, displayHeight, referenceTime);\n    const verticalOffset = this.resolveStaticCommentOffset(\n      staticPosition,\n      laneIndex,\n      displayHeight,\n      comment,\n    );\n    comment.x = Math.max(0, Math.min(displayWidth - comment.width, comment.virtualStartX));\n    comment.y = verticalOffset;\n    comment.lane =\n      staticPosition === \"ue\" ? laneIndex : this.getGlobalLaneIndexForBottom(laneIndex);\n    comment.speed = 0;\n    comment.baseSpeed = 0;\n    comment.speedPixelsPerMs = 0;\n    comment.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n    const displayEnd = referenceTime + comment.visibleDurationMs;\n    this.activeComments.add(comment);\n    comment.isActive = true;\n    comment.hasShown = true;\n    comment.isPaused = !this.isPlaying;\n    comment.markActivated(referenceTime);\n    comment.lastUpdateTime = this.timeSource.now();\n    comment.staticExpiryTimeMs = displayEnd;\n    this.reserveStaticLane(staticPosition, comment, laneIndex, displayEnd);\n    if (isDebugLoggingEnabled()) {\n      debugLog(\"comment-activate-static\", {\n        preview: formatCommentPreview(comment.text),\n        lane: comment.lane,\n        position: staticPosition,\n        displayEnd,\n        effectiveVposMs: effectiveVpos,\n      });\n    }\n    return;\n  }\n\n  this.activeComments.add(comment);\n  comment.isActive = true;\n  comment.hasShown = true;\n  comment.isPaused = !this.isPlaying;\n  comment.markActivated(referenceTime);\n  comment.lastUpdateTime = this.timeSource.now();\n};\n\nconst assignStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  comment: Comment,\n  displayHeight: number,\n  currentTime: number,\n): number {\n  const reservations = this.getStaticReservations(position);\n  const limit = this.getStaticLaneLimit(position);\n  const laneCount = limit >= 0 ? limit + 1 : 0;\n  const laneIndices = Array.from({ length: laneCount }, (_, index) => index);\n\n  for (const lane of laneIndices) {\n    const yOffset = this.resolveStaticCommentOffset(position, lane, displayHeight, comment);\n    const commentHeight = Math.max(comment.height, comment.fontSize);\n    const padding = calculateStaticCommentVerticalPadding(comment.fontSize);\n    const yStart = yOffset - padding;\n    const yEnd = yOffset + commentHeight + padding;\n\n    const hasConflict = reservations.some((reservation) => {\n      const timeOverlap = reservation.releaseTime > currentTime;\n      if (!timeOverlap) {\n        return false;\n      }\n      const yOverlap = !(yEnd <= reservation.yStart || yStart >= reservation.yEnd);\n      return yOverlap;\n    });\n\n    if (!hasConflict) {\n      return lane;\n    }\n  }\n\n  let fallbackLane = laneIndices[0] ?? 0;\n  let earliestRelease = Number.POSITIVE_INFINITY;\n  for (const reservation of reservations) {\n    if (reservation.releaseTime < earliestRelease) {\n      earliestRelease = reservation.releaseTime;\n      fallbackLane = reservation.lane;\n    }\n  }\n  return fallbackLane;\n};\n\nconst reserveStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  comment: Comment,\n  lane: number,\n  releaseTime: number,\n): void {\n  const reservations = this.getStaticReservations(position);\n  const commentHeight = Math.max(comment.height, comment.fontSize);\n  const padding = calculateStaticCommentVerticalPadding(comment.fontSize);\n  const yStart = comment.y - padding;\n  const yEnd = comment.y + commentHeight + padding;\n\n  reservations.push({\n    comment,\n    releaseTime,\n    yStart,\n    yEnd,\n    lane,\n  });\n};\n\nconst releaseStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  lane: number,\n): void {\n  if (lane < 0) {\n    return;\n  }\n  const reservations = this.getStaticReservations(position);\n  const index = reservations.findIndex((r) => r.lane === lane);\n  if (index >= 0) {\n    reservations.splice(index, 1);\n  }\n};\n\nexport const registerLaneActivationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.shouldActivateCommentAtTime = shouldActivateCommentAtTimeImpl;\n  ctor.prototype.activateComment = activateCommentImpl;\n  ctor.prototype.assignStaticLane = assignStaticLaneImpl;\n  ctor.prototype.reserveStaticLane = reserveStaticLaneImpl;\n  ctor.prototype.releaseStaticLane = releaseStaticLaneImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { LaneReservation } from \"@/shared/types\";\nimport { EDGE_EPSILON, RESERVATION_TIME_MARGIN_MS } from \"@/shared/constants\";\n\nconst getLanePriorityOrderImpl = function (this: CommentRenderer, currentTime: number): number[] {\n  const indices = Array.from({ length: this.laneCount }, (_, index) => index);\n  const sorted = indices.sort((a, b) => {\n    const nextA = this.getLaneNextAvailableTime(a, currentTime);\n    const nextB = this.getLaneNextAvailableTime(b, currentTime);\n    if (Math.abs(nextA - nextB) <= EDGE_EPSILON) {\n      return a - b;\n    }\n    return nextA - nextB;\n  });\n  const staticReserved = this.getStaticReservedLaneSet();\n  if (staticReserved.size === 0) {\n    return sorted;\n  }\n  const preferred = sorted.filter((lane) => !staticReserved.has(lane));\n  if (preferred.length === 0) {\n    return sorted;\n  }\n  const blocked = sorted.filter((lane) => staticReserved.has(lane));\n  return [...preferred, ...blocked];\n};\n\nconst getLaneNextAvailableTimeImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  currentTime: number,\n): number {\n  const reservations = this.reservedLanes.get(lane);\n  if (!reservations || reservations.length === 0) {\n    return currentTime;\n  }\n  const validIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n  const candidate = reservations[validIndex];\n  if (!candidate) {\n    return currentTime;\n  }\n  return Math.max(currentTime, candidate.endTime + RESERVATION_TIME_MARGIN_MS);\n};\n\nconst createLaneReservationImpl = function (\n  this: CommentRenderer,\n  comment: CommentRenderer[\"comments\"][number],\n  referenceTime: number,\n): LaneReservation {\n  const speed = Math.max(comment.speedPixelsPerMs, EDGE_EPSILON);\n  const effectiveStart = this.getEffectiveCommentVpos(comment);\n  const baseStartTime = Number.isFinite(effectiveStart) ? effectiveStart : referenceTime;\n  const startTime = Math.max(0, baseStartTime);\n  const endTime = startTime + comment.preCollisionDurationMs + RESERVATION_TIME_MARGIN_MS;\n  const totalEndTime = startTime + comment.totalDurationMs + RESERVATION_TIME_MARGIN_MS;\n  return {\n    comment,\n    startTime,\n    endTime: Math.max(startTime, endTime),\n    totalEndTime: Math.max(startTime, totalEndTime),\n    startLeft: comment.virtualStartX,\n    width: comment.width,\n    speed,\n    buffer: comment.bufferWidth,\n    directionSign: comment.getDirectionSign(),\n  };\n};\n\nconst isLaneAvailableImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  candidate: LaneReservation,\n  currentTime: number,\n): boolean {\n  const reservations = this.reservedLanes.get(lane);\n  if (!reservations || reservations.length === 0) {\n    return true;\n  }\n  const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n  for (let i = firstValidIndex; i < reservations.length; i += 1) {\n    const reservation = reservations[i];\n    if (!reservation) {\n      continue;\n    }\n    if (this.areReservationsConflicting(reservation, candidate)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst storeLaneReservationImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  reservation: LaneReservation,\n): void {\n  const existing = this.reservedLanes.get(lane) ?? [];\n  const updated = [...existing, reservation].sort((a, b) => a.totalEndTime - b.totalEndTime);\n  this.reservedLanes.set(lane, updated);\n};\n\nconst areReservationsConflictingImpl = function (\n  this: CommentRenderer,\n  a: LaneReservation,\n  b: LaneReservation,\n): boolean {\n  const overlapStart = Math.max(a.startTime, b.startTime);\n  const overlapEnd = Math.min(a.endTime, b.endTime);\n  if (overlapStart >= overlapEnd) {\n    return false;\n  }\n\n  const evaluationTimes = new Set<number>([\n    overlapStart,\n    overlapEnd,\n    overlapStart + (overlapEnd - overlapStart) / 2,\n  ]);\n\n  const forwardIntersection = this.solveLeftRightEqualityTime(a, b);\n  if (\n    forwardIntersection !== null &&\n    forwardIntersection >= overlapStart - EDGE_EPSILON &&\n    forwardIntersection <= overlapEnd + EDGE_EPSILON\n  ) {\n    evaluationTimes.add(forwardIntersection);\n  }\n\n  const backwardIntersection = this.solveLeftRightEqualityTime(b, a);\n  if (\n    backwardIntersection !== null &&\n    backwardIntersection >= overlapStart - EDGE_EPSILON &&\n    backwardIntersection <= overlapEnd + EDGE_EPSILON\n  ) {\n    evaluationTimes.add(backwardIntersection);\n  }\n\n  for (const time of evaluationTimes) {\n    if (time < overlapStart - EDGE_EPSILON || time > overlapEnd + EDGE_EPSILON) {\n      continue;\n    }\n    const forwardGap = this.computeForwardGap(a, b, time);\n    const backwardGap = this.computeForwardGap(b, a, time);\n    if (forwardGap <= EDGE_EPSILON && backwardGap <= EDGE_EPSILON) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst computeForwardGapImpl = function (\n  this: CommentRenderer,\n  from: LaneReservation,\n  to: LaneReservation,\n  time: number,\n): number {\n  const fromEdges = this.getBufferedEdges(from, time);\n  const toEdges = this.getBufferedEdges(to, time);\n  return fromEdges.left - toEdges.right;\n};\n\nconst getBufferedEdgesImpl = function (\n  this: CommentRenderer,\n  reservation: LaneReservation,\n  time: number,\n): { left: number; right: number } {\n  const elapsed = Math.max(0, time - reservation.startTime);\n  const displacement = reservation.speed * elapsed;\n  const rawLeft = reservation.startLeft + reservation.directionSign * displacement;\n  const left = rawLeft - reservation.buffer;\n  const right = rawLeft + reservation.width + reservation.buffer;\n  return { left, right };\n};\n\nconst solveLeftRightEqualityTimeImpl = function (\n  this: CommentRenderer,\n  left: LaneReservation,\n  right: LaneReservation,\n): number | null {\n  const leftSign = left.directionSign;\n  const rightSign = right.directionSign;\n  const denominator = rightSign * right.speed - leftSign * left.speed;\n  if (Math.abs(denominator) < EDGE_EPSILON) {\n    return null;\n  }\n  const numerator =\n    right.startLeft +\n    rightSign * right.speed * right.startTime +\n    right.width +\n    right.buffer -\n    left.startLeft -\n    leftSign * left.speed * left.startTime +\n    left.buffer;\n  const time = numerator / denominator;\n  if (!Number.isFinite(time)) {\n    return null;\n  }\n  return time;\n};\n\nexport const registerLaneReservationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.getLanePriorityOrder = getLanePriorityOrderImpl;\n  ctor.prototype.getLaneNextAvailableTime = getLaneNextAvailableTimeImpl;\n  ctor.prototype.createLaneReservation = createLaneReservationImpl;\n  ctor.prototype.isLaneAvailable = isLaneAvailableImpl;\n  ctor.prototype.storeLaneReservation = storeLaneReservationImpl;\n  ctor.prototype.areReservationsConflicting = areReservationsConflictingImpl;\n  ctor.prototype.computeForwardGap = computeForwardGapImpl;\n  ctor.prototype.getBufferedEdges = getBufferedEdgesImpl;\n  ctor.prototype.solveLeftRightEqualityTime = solveLeftRightEqualityTimeImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { ACTIVE_WINDOW_MS, EDGE_EPSILON, toMilliseconds } from \"@/shared/constants\";\n\nconst drawImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!canvas || !context) {\n    return;\n  }\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n\n  const now = this.timeSource.now();\n\n  if (this.skipDrawingForCurrentFrame || this.shouldSuppressRendering() || this.isStalled) {\n    context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    this.lastDrawTime = now;\n    return;\n  }\n\n  context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n  const activeComments = Array.from(this.activeComments);\n\n  if (this._settings.isCommentVisible) {\n    const deltaTime = (now - this.lastDrawTime) / (1000 / 60);\n    activeComments.sort((a, b) => {\n      const aVpos = this.getEffectiveCommentVpos(a);\n      const bVpos = this.getEffectiveCommentVpos(b);\n      const vposMsDiff = aVpos - bVpos;\n      if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n        return vposMsDiff;\n      }\n      if (a.isScrolling !== b.isScrolling) {\n        return a.isScrolling ? 1 : -1;\n      }\n      return a.creationIndex - b.creationIndex;\n    });\n    activeComments.forEach((comment) => {\n      const shouldInterpolate = this.isPlaying && !comment.isPaused;\n      const interpolatedX = shouldInterpolate\n        ? comment.x + comment.getDirectionSign() * comment.speed * deltaTime\n        : comment.x;\n      comment.draw(context, interpolatedX);\n    });\n  }\n\n  this.lastDrawTime = now;\n};\n\nconst performInitialSyncImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas || !context) {\n    return;\n  }\n\n  const absoluteTime =\n    typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n  this.currentTime = absoluteTime;\n  this.lastDrawTime = this.timeSource.now();\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const windowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  windowComments.forEach((comment) => {\n    if (this.isNGComment(comment.text) || comment.isInvisible) {\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.clearActivation();\n      return;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n    comment.isActive = false;\n    this.activeComments.delete(comment);\n    comment.lane = -1;\n    comment.clearActivation();\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n      return;\n    }\n\n    const effectiveVpos = this.getEffectiveCommentVpos(comment);\n    if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n      comment.hasShown = true;\n    } else {\n      comment.hasShown = false;\n    }\n  });\n};\n\nexport const registerRenderMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.draw = drawImpl;\n  ctor.prototype.performInitialSync = performInitialSyncImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { ACTIVE_WINDOW_MS, SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\nimport type {\n  RequestVideoFrameCallback,\n  CancelVideoFrameCallback,\n  VideoFrameCallbackMetadataLike,\n} from \"@/shared/types\";\nimport { formatCommentPreview, debugLog, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst processFrameImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  if (!this.videoElement) {\n    return;\n  }\n  if (!this._settings.isCommentVisible) {\n    return;\n  }\n\n  if (this.pendingInitialSync) {\n    this.performInitialSync(frameTimeMs);\n    this.pendingInitialSync = false;\n  }\n\n  this.updateComments(frameTimeMs);\n  this.draw();\n};\n\nconst handleAnimationFrameImpl = function (this: CommentRenderer): void {\n  const pendingId = this.frameId;\n  this.frameId = null;\n  if (pendingId !== null) {\n    this.animationFrameProvider.cancel(pendingId);\n  }\n  this.processFrame();\n  this.scheduleNextFrame();\n};\n\nconst handleVideoFrameImpl = function (\n  this: CommentRenderer,\n  _now: DOMHighResTimeStamp,\n  metadata: VideoFrameCallbackMetadataLike,\n): void {\n  this.videoFrameHandle = null;\n  const mediaTime = typeof metadata?.mediaTime === \"number\" ? metadata.mediaTime * 1000 : undefined;\n  this.processFrame(typeof mediaTime === \"number\" ? mediaTime : undefined);\n  this.scheduleNextFrame();\n};\n\nconst shouldUseVideoFrameCallbackImpl = function (this: CommentRenderer): boolean {\n  if (this._settings.syncMode !== \"video-frame\") {\n    return false;\n  }\n  const video = this.videoElement as HTMLVideoElement & {\n    requestVideoFrameCallback?: RequestVideoFrameCallback;\n    cancelVideoFrameCallback?: CancelVideoFrameCallback;\n  };\n  return (\n    Boolean(video) &&\n    typeof video.requestVideoFrameCallback === \"function\" &&\n    typeof video.cancelVideoFrameCallback === \"function\"\n  );\n};\n\nconst scheduleNextFrameImpl = function (this: CommentRenderer): void {\n  const video = this.videoElement;\n  if (!video) {\n    return;\n  }\n  if (this.shouldUseVideoFrameCallback()) {\n    this.cancelAnimationFrameRequest();\n    this.cancelVideoFrameCallback();\n    const request = (\n      video as HTMLVideoElement & {\n        requestVideoFrameCallback?: RequestVideoFrameCallback;\n      }\n    ).requestVideoFrameCallback;\n    if (typeof request === \"function\") {\n      this.videoFrameHandle = request.call(video, this.handleVideoFrame);\n    }\n    return;\n  }\n  this.cancelVideoFrameCallback();\n  this.frameId = this.animationFrameProvider.request(this.handleAnimationFrame);\n};\n\nconst cancelAnimationFrameRequestImpl = function (this: CommentRenderer): void {\n  if (this.frameId !== null) {\n    this.animationFrameProvider.cancel(this.frameId);\n    this.frameId = null;\n  }\n};\n\nconst cancelVideoFrameCallbackImpl = function (this: CommentRenderer): void {\n  if (this.videoFrameHandle === null) {\n    return;\n  }\n  const video = this.videoElement as HTMLVideoElement & {\n    cancelVideoFrameCallback?: CancelVideoFrameCallback;\n  };\n  if (video && typeof video.cancelVideoFrameCallback === \"function\") {\n    video.cancelVideoFrameCallback(this.videoFrameHandle);\n  }\n  this.videoFrameHandle = null;\n};\n\nconst startAnimationImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  this.scheduleNextFrame();\n};\n\nconst stopAnimationImpl = function (this: CommentRenderer): void {\n  this.cancelAnimationFrameRequest();\n  this.cancelVideoFrameCallback();\n};\n\nconst onSeekImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const context = this.ctx;\n  const video = this.videoElement;\n  if (!canvas || !context || !video) {\n    return;\n  }\n\n  const nextTime = toMilliseconds(video.currentTime);\n  const timeDelta = Math.abs(nextTime - this.currentTime);\n  const now = this.timeSource.now();\n\n  const isRecentPlayResume = now - this.lastPlayResumeTime < this.playResumeSeekIgnoreDurationMs;\n  if (isRecentPlayResume) {\n    this.currentTime = nextTime;\n    if (this._settings.isCommentVisible) {\n      this.lastDrawTime = now;\n      this.draw();\n    }\n    return;\n  }\n\n  const isSignificantSeek = timeDelta > SEEK_DIRECTION_EPSILON_MS;\n\n  this.currentTime = nextTime;\n  this.resetFinalPhaseState();\n  this.updatePlaybackProgressState();\n\n  if (!isSignificantSeek) {\n    if (this._settings.isCommentVisible) {\n      this.lastDrawTime = this.timeSource.now();\n      this.draw();\n    }\n    return;\n  }\n\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const seekWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  seekWindowComments.forEach((comment) => {\n    const debugActive = isDebugLoggingEnabled();\n    const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n    if (debugActive) {\n      debugLog(\"comment-evaluate\", {\n        stage: \"seek\",\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: this.getEffectiveCommentVpos(comment),\n        currentTime: this.currentTime,\n        isActive: comment.isActive,\n        hasShown: comment.hasShown,\n      });\n    }\n\n    if (this.isNGComment(comment.text)) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"ng-runtime\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.clearActivation();\n      return;\n    }\n\n    if (comment.isInvisible) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"invisible\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.hasShown = true;\n      comment.clearActivation();\n      return;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n    comment.isActive = false;\n    this.activeComments.delete(comment);\n    comment.lane = -1;\n    comment.clearActivation();\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n      return;\n    }\n\n    const effectiveVpos = this.getEffectiveCommentVpos(comment);\n    if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n      comment.hasShown = true;\n    } else {\n      comment.hasShown = false;\n    }\n  });\n\n  if (this._settings.isCommentVisible) {\n    this.lastDrawTime = this.timeSource.now();\n    this.draw();\n  }\n};\n\nexport const registerTimingMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.processFrame = processFrameImpl;\n  ctor.prototype.handleAnimationFrame = handleAnimationFrameImpl;\n  ctor.prototype.handleVideoFrame = handleVideoFrameImpl;\n  ctor.prototype.shouldUseVideoFrameCallback = shouldUseVideoFrameCallbackImpl;\n  ctor.prototype.scheduleNextFrame = scheduleNextFrameImpl;\n  ctor.prototype.cancelAnimationFrameRequest = cancelAnimationFrameRequestImpl;\n  ctor.prototype.cancelVideoFrameCallback = cancelVideoFrameCallbackImpl;\n  ctor.prototype.startAnimation = startAnimationImpl;\n  ctor.prototype.stopAnimation = stopAnimationImpl;\n  ctor.prototype.onSeek = onSeekImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { CommentRendererInitializeOptions } from \"@/shared/types\";\nimport { SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\n\nconst resolveContainerImpl = function (\n  this: CommentRenderer,\n  explicit: HTMLElement | null | undefined,\n  video: HTMLVideoElement,\n): HTMLElement {\n  if (explicit) {\n    return explicit;\n  }\n  if (video.parentElement) {\n    return video.parentElement;\n  }\n  if (typeof document !== \"undefined\" && document.body) {\n    return document.body;\n  }\n  throw new Error(\n    \"Cannot resolve container element. Provide container explicitly when DOM is unavailable.\",\n  );\n};\n\nconst ensureContainerPositioningImpl = function (\n  this: CommentRenderer,\n  container: HTMLElement,\n): void {\n  if (typeof getComputedStyle === \"function\") {\n    const style = getComputedStyle(container);\n    if (style.position === \"static\") {\n      container.style.position = \"relative\";\n    }\n    return;\n  }\n  if (!container.style.position) {\n    container.style.position = \"relative\";\n  }\n};\n\nconst initializeImpl = function (\n  this: CommentRenderer,\n  options: HTMLVideoElement | CommentRendererInitializeOptions,\n): void {\n  try {\n    this.destroyCanvasOnly();\n\n    const video = options instanceof HTMLVideoElement ? options : options.video;\n    const containerCandidate =\n      options instanceof HTMLVideoElement\n        ? options.parentElement\n        : (options.container ?? options.video.parentElement);\n    const container = this.resolveContainer(containerCandidate ?? null, video);\n\n    this.videoElement = video;\n    this.containerElement = container;\n    this.lastVideoSource = this.getCurrentVideoSource();\n    this.duration = Number.isFinite(video.duration) ? toMilliseconds(video.duration) : 0;\n    this.currentTime = toMilliseconds(video.currentTime);\n    this.playbackRate = video.playbackRate;\n    this.isPlaying = !video.paused;\n    this.isStalled = false;\n    this.lastDrawTime = this.timeSource.now();\n    this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n    this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n\n    const canvas = this.createCanvasElement();\n    const context = canvas.getContext(\"2d\");\n    if (!context) {\n      throw new Error(\"Failed to acquire 2D canvas context\");\n    }\n\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0\";\n    canvas.style.left = \"0\";\n    canvas.style.pointerEvents = \"none\";\n    canvas.style.zIndex = \"1000\";\n\n    const parent = this.containerElement;\n    if (parent instanceof HTMLElement) {\n      this.ensureContainerPositioning(parent);\n      parent.appendChild(canvas);\n    }\n\n    this.canvas = canvas;\n    this.ctx = context;\n\n    this.resize();\n    this.calculateLaneMetrics();\n    this.setupVideoEventListeners(video);\n    this.setupResizeHandling(video);\n    this.setupFullscreenHandling();\n    this.setupVideoChangeDetection(video, container);\n    this.startAnimation();\n    this.setupVisibilityHandling();\n  } catch (error) {\n    this.log.error(\"CommentRenderer.initialize\", error as Error);\n    throw error;\n  }\n};\n\nconst destroyImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  this.cleanupResizeHandling();\n  this.runCleanupTasks();\n\n  if (this.canvas) {\n    this.canvas.remove();\n  }\n  this.canvas = null;\n  this.ctx = null;\n  this.videoElement = null;\n  this.containerElement = null;\n  this.comments.length = 0;\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.resetFinalPhaseState();\n  this.displayWidth = 0;\n  this.displayHeight = 0;\n  this.canvasDpr = 1;\n  this.commentSequence = 0;\n  this.playbackHasBegun = false;\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n};\n\nconst destroyCanvasOnlyImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  if (this.canvas) {\n    this.canvas.remove();\n  }\n  this.canvas = null;\n  this.ctx = null;\n  this.displayWidth = 0;\n  this.displayHeight = 0;\n  this.canvasDpr = 1;\n  this.fullscreenActive = false;\n};\n\nexport const registerLifecycleCoreMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.resolveContainer = resolveContainerImpl;\n  ctor.prototype.ensureContainerPositioning = ensureContainerPositioningImpl;\n  ctor.prototype.initialize = initializeImpl;\n  ctor.prototype.destroy = destroyImpl;\n  ctor.prototype.destroyCanvasOnly = destroyCanvasOnlyImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\n\nconst setupVideoEventListenersImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  try {\n    const onPlay = (): void => {\n      this.isPlaying = true;\n      this.playbackHasBegun = true;\n      const now = this.timeSource.now();\n      this.lastDrawTime = now;\n      this.lastPlayResumeTime = now;\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n        comment.isPaused = false;\n      });\n    };\n    const onPause = (): void => {\n      this.isPlaying = false;\n      const now = this.timeSource.now();\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n        comment.isPaused = true;\n      });\n    };\n    const onSeeking = (): void => {\n      this.onSeek();\n    };\n    const onSeeked = (): void => {\n      this.onSeek();\n    };\n    const onRateChange = (): void => {\n      this.playbackRate = videoElement.playbackRate;\n      const now = this.timeSource.now();\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n      });\n    };\n    const onLoadedMetadata = (): void => {\n      this.handleVideoMetadataLoaded(videoElement);\n    };\n    const onDurationChange = (): void => {\n      this.duration = Number.isFinite(videoElement.duration)\n        ? toMilliseconds(videoElement.duration)\n        : 0;\n    };\n    const onEmptied = (): void => {\n      this.handleVideoSourceChange();\n    };\n    const onWaiting = (): void => {\n      this.handleVideoStalled();\n    };\n    const onCanPlay = (): void => {\n      this.handleVideoCanPlay();\n    };\n    const onPlaying = (): void => {\n      this.handleVideoCanPlay();\n    };\n\n    videoElement.addEventListener(\"play\", onPlay);\n    videoElement.addEventListener(\"pause\", onPause);\n    videoElement.addEventListener(\"seeking\", onSeeking);\n    videoElement.addEventListener(\"seeked\", onSeeked);\n    videoElement.addEventListener(\"ratechange\", onRateChange);\n    videoElement.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n    videoElement.addEventListener(\"durationchange\", onDurationChange);\n    videoElement.addEventListener(\"emptied\", onEmptied);\n    videoElement.addEventListener(\"waiting\", onWaiting);\n    videoElement.addEventListener(\"canplay\", onCanPlay);\n    videoElement.addEventListener(\"playing\", onPlaying);\n\n    this.addCleanup(() => videoElement.removeEventListener(\"play\", onPlay));\n    this.addCleanup(() => videoElement.removeEventListener(\"pause\", onPause));\n    this.addCleanup(() => videoElement.removeEventListener(\"seeking\", onSeeking));\n    this.addCleanup(() => videoElement.removeEventListener(\"seeked\", onSeeked));\n    this.addCleanup(() => videoElement.removeEventListener(\"ratechange\", onRateChange));\n    this.addCleanup(() => videoElement.removeEventListener(\"loadedmetadata\", onLoadedMetadata));\n    this.addCleanup(() => videoElement.removeEventListener(\"durationchange\", onDurationChange));\n    this.addCleanup(() => videoElement.removeEventListener(\"emptied\", onEmptied));\n    this.addCleanup(() => videoElement.removeEventListener(\"waiting\", onWaiting));\n    this.addCleanup(() => videoElement.removeEventListener(\"canplay\", onCanPlay));\n    this.addCleanup(() => videoElement.removeEventListener(\"playing\", onPlaying));\n  } catch (error) {\n    this.log.error(\"CommentRenderer.setupVideoEventListeners\", error as Error);\n    throw error;\n  }\n};\n\nconst handleVideoMetadataLoadedImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  this.lastVideoSource = this.getCurrentVideoSource();\n  this.incrementEpoch(\"metadata-loaded\");\n  this.handleVideoSourceChange(videoElement);\n  this.resize();\n  this.calculateLaneMetrics();\n  this.hardReset();\n  this.onSeek();\n  this.emitStateSnapshot(\"metadata-loaded\");\n};\n\nconst handleVideoStalledImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  if (!canvas || !ctx) {\n    return;\n  }\n\n  this.isStalled = true;\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n\n  this.comments.forEach((comment) => {\n    if (comment.isActive) {\n      comment.lastUpdateTime = this.timeSource.now();\n    }\n  });\n};\n\nconst handleVideoCanPlayImpl = function (this: CommentRenderer): void {\n  if (!this.isStalled) {\n    return;\n  }\n\n  this.isStalled = false;\n\n  if (this.videoElement) {\n    this.currentTime = toMilliseconds(this.videoElement.currentTime);\n    this.isPlaying = !this.videoElement.paused;\n  }\n\n  this.lastDrawTime = this.timeSource.now();\n};\n\nconst handleVideoSourceChangeImpl = function (\n  this: CommentRenderer,\n  videoElement?: HTMLVideoElement | null,\n): void {\n  const target = videoElement ?? this.videoElement;\n  if (!target) {\n    this.lastVideoSource = null;\n    this.isPlaying = false;\n    this.resetFinalPhaseState();\n    this.resetCommentActivity();\n    return;\n  }\n\n  const currentSource = this.getCurrentVideoSource();\n  const sourceChanged = currentSource !== this.lastVideoSource;\n  if (!sourceChanged) {\n    return;\n  }\n\n  this.lastVideoSource = currentSource;\n  this.incrementEpoch(\"source-change\");\n  this.syncVideoState(target);\n  this.resetFinalPhaseState();\n  this.resetCommentActivity();\n  this.emitStateSnapshot(\"source-change\");\n};\n\nconst syncVideoStateImpl = function (this: CommentRenderer, videoElement: HTMLVideoElement): void {\n  this.duration = Number.isFinite(videoElement.duration)\n    ? toMilliseconds(videoElement.duration)\n    : 0;\n  this.currentTime = toMilliseconds(videoElement.currentTime);\n  this.playbackRate = videoElement.playbackRate;\n  this.isPlaying = !videoElement.paused;\n  this.isStalled = false;\n  this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n  this.lastDrawTime = this.timeSource.now();\n};\n\nconst resetCommentActivityImpl = function (this: CommentRenderer): void {\n  const now = this.timeSource.now();\n  const canvas = this.canvas;\n  const context = this.ctx;\n  this.resetFinalPhaseState();\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n  this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n  if (canvas && context) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const width = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const height = this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    context.clearRect(0, 0, width, height);\n  }\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  this.comments.forEach((comment) => {\n    comment.isActive = false;\n    comment.isPaused = !this.isPlaying;\n    comment.hasShown = false;\n    comment.lane = -1;\n    comment.x = comment.virtualStartX;\n    comment.speed = comment.baseSpeed;\n    comment.lastUpdateTime = now;\n    comment.clearActivation();\n  });\n  this.activeComments.clear();\n};\n\nconst setupVideoChangeDetectionImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n  container: HTMLElement,\n): void {\n  if (typeof MutationObserver === \"undefined\") {\n    this.log.debug(\n      \"MutationObserver is not available in this environment. Video change detection is disabled.\",\n    );\n    return;\n  }\n\n  const videoObserver = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      if (mutation.type === \"attributes\" && mutation.attributeName === \"src\") {\n        const targetNode = mutation.target;\n        let previous: string | null = null;\n        let current: string | null = null;\n        if (targetNode instanceof HTMLVideoElement || targetNode instanceof HTMLSourceElement) {\n          previous = typeof mutation.oldValue === \"string\" ? mutation.oldValue : null;\n          current = targetNode.getAttribute(\"src\");\n        }\n        if (previous === current) {\n          continue;\n        }\n        this.handleVideoSourceChange(videoElement);\n        return;\n      }\n      if (mutation.type === \"childList\") {\n        for (const node of mutation.addedNodes) {\n          if (node instanceof HTMLSourceElement) {\n            this.handleVideoSourceChange(videoElement);\n            return;\n          }\n        }\n        for (const node of mutation.removedNodes) {\n          if (node instanceof HTMLSourceElement) {\n            this.handleVideoSourceChange(videoElement);\n            return;\n          }\n        }\n      }\n    }\n  });\n\n  videoObserver.observe(videoElement, {\n    attributes: true,\n    attributeFilter: [\"src\"],\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  this.addCleanup(() => videoObserver.disconnect());\n\n  const containerObserver = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      if (mutation.type !== \"childList\") {\n        continue;\n      }\n      for (const node of mutation.addedNodes) {\n        const nextVideo = this.extractVideoElement(node);\n        if (nextVideo && nextVideo !== this.videoElement) {\n          this.initialize(nextVideo);\n          return;\n        }\n      }\n      for (const node of mutation.removedNodes) {\n        if (node === this.videoElement) {\n          this.videoElement = null;\n          this.handleVideoSourceChange(null);\n          return;\n        }\n        if (node instanceof Element) {\n          const removedVideo = node.querySelector(\"video\");\n          if (removedVideo && removedVideo === this.videoElement) {\n            this.videoElement = null;\n            this.handleVideoSourceChange(null);\n            return;\n          }\n        }\n      }\n    }\n  });\n\n  containerObserver.observe(container, { childList: true, subtree: true });\n  this.addCleanup(() => containerObserver.disconnect());\n};\n\nconst extractVideoElementImpl = function (\n  this: CommentRenderer,\n  node: Node,\n): HTMLVideoElement | null {\n  if (node instanceof HTMLVideoElement) {\n    return node;\n  }\n  if (node instanceof Element) {\n    const candidate = node.querySelector(\"video\");\n    if (candidate instanceof HTMLVideoElement) {\n      return candidate;\n    }\n  }\n  return null;\n};\n\nexport const registerLifecycleVideoMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupVideoEventListeners = setupVideoEventListenersImpl;\n  ctor.prototype.handleVideoMetadataLoaded = handleVideoMetadataLoadedImpl;\n  ctor.prototype.handleVideoStalled = handleVideoStalledImpl;\n  ctor.prototype.handleVideoCanPlay = handleVideoCanPlayImpl;\n  ctor.prototype.handleVideoSourceChange = handleVideoSourceChangeImpl;\n  ctor.prototype.syncVideoState = syncVideoStateImpl;\n  ctor.prototype.resetCommentActivity = resetCommentActivityImpl;\n  ctor.prototype.setupVideoChangeDetection = setupVideoChangeDetectionImpl;\n  ctor.prototype.extractVideoElement = extractVideoElementImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { toMilliseconds } from \"@/shared/constants\";\n\nconst setupVisibilityHandlingImpl = function (this: CommentRenderer): void {\n  if (\n    typeof document === \"undefined\" ||\n    typeof document.addEventListener !== \"function\" ||\n    typeof document.removeEventListener !== \"function\"\n  ) {\n    return;\n  }\n\n  const enforceVisibilityState = (): void => {\n    const state = document.visibilityState;\n    if (state !== \"visible\") {\n      this.stopAnimation();\n      return;\n    }\n    if (!this._settings.isCommentVisible) {\n      return;\n    }\n    this.handleVisibilityRestore();\n    this.startAnimation();\n  };\n\n  document.addEventListener(\"visibilitychange\", enforceVisibilityState);\n  this.addCleanup(() => document.removeEventListener(\"visibilitychange\", enforceVisibilityState));\n\n  if (document.visibilityState !== \"visible\") {\n    this.stopAnimation();\n  }\n};\n\nconst handleVisibilityRestoreImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  const video = this.videoElement;\n  if (!canvas || !ctx || !video) {\n    return;\n  }\n\n  this.currentTime = toMilliseconds(video.currentTime);\n  this.lastDrawTime = this.timeSource.now();\n  this.isPlaying = !video.paused;\n  this.isStalled = false;\n  this.pendingInitialSync = true;\n  this.resetFinalPhaseState();\n  this.updatePlaybackProgressState();\n  this.draw();\n};\n\nexport const registerVisibilityMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupVisibilityHandling = setupVisibilityHandlingImpl;\n  ctor.prototype.handleVisibilityRestore = handleVisibilityRestoreImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { DEFAULT_LANE_COUNT, MIN_FONT_SIZE_PX, MIN_LANE_COUNT } from \"@/shared/constants\";\n\nconst resizeImpl = function (this: CommentRenderer, width?: number, height?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas) {\n    return;\n  }\n\n  const rect = video.getBoundingClientRect();\n  const currentDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const fallbackWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / currentDpr;\n  const fallbackHeight = this.displayHeight > 0 ? this.displayHeight : canvas.height / currentDpr;\n\n  const measuredWidth = width ?? rect.width ?? fallbackWidth;\n  const measuredHeight = height ?? rect.height ?? fallbackHeight;\n\n  if (\n    !Number.isFinite(measuredWidth) ||\n    !Number.isFinite(measuredHeight) ||\n    measuredWidth <= 0 ||\n    measuredHeight <= 0\n  ) {\n    return;\n  }\n\n  const cssWidth = Math.max(1, Math.floor(measuredWidth));\n  const cssHeight = Math.max(1, Math.floor(measuredHeight));\n  const previousDisplayWidth = this.displayWidth > 0 ? this.displayWidth : cssWidth;\n  const previousDisplayHeight = this.displayHeight > 0 ? this.displayHeight : cssHeight;\n  const nextDpr = this._settings.useDprScaling ? this.resolveDevicePixelRatio() : 1;\n  const pixelWidth = Math.max(1, Math.round(cssWidth * nextDpr));\n  const pixelHeight = Math.max(1, Math.round(cssHeight * nextDpr));\n\n  const needsResize =\n    this.displayWidth !== cssWidth ||\n    this.displayHeight !== cssHeight ||\n    Math.abs(this.canvasDpr - nextDpr) > Number.EPSILON ||\n    canvas.width !== pixelWidth ||\n    canvas.height !== pixelHeight;\n\n  if (!needsResize) {\n    return;\n  }\n\n  this.displayWidth = cssWidth;\n  this.displayHeight = cssHeight;\n  this.canvasDpr = nextDpr;\n\n  canvas.width = pixelWidth;\n  canvas.height = pixelHeight;\n  canvas.style.width = `${cssWidth}px`;\n  canvas.style.height = `${cssHeight}px`;\n\n  if (context) {\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    if (this._settings.useDprScaling) {\n      context.scale(nextDpr, nextDpr);\n    }\n  }\n\n  const scaleX = previousDisplayWidth > 0 ? cssWidth / previousDisplayWidth : 1;\n  const scaleY = previousDisplayHeight > 0 ? cssHeight / previousDisplayHeight : 1;\n\n  if (scaleX !== 1 || scaleY !== 1) {\n    this.comments.forEach((comment) => {\n      if (comment.isActive) {\n        comment.x *= scaleX;\n        comment.y *= scaleY;\n        comment.width *= scaleX;\n        comment.fontSize = Math.max(\n          MIN_FONT_SIZE_PX,\n          Math.floor(Math.max(1, comment.fontSize) * scaleY),\n        );\n        comment.height = comment.fontSize;\n        comment.virtualStartX *= scaleX;\n        comment.exitThreshold *= scaleX;\n        comment.baseSpeed *= scaleX;\n        comment.speed *= scaleX;\n        comment.speedPixelsPerMs *= scaleX;\n        comment.bufferWidth *= scaleX;\n        comment.reservationWidth *= scaleX;\n      }\n    });\n  }\n\n  this.calculateLaneMetrics();\n};\n\nconst resolveDevicePixelRatioImpl = function (this: CommentRenderer): number {\n  if (typeof window === \"undefined\") {\n    return 1;\n  }\n  const ratio = Number(window.devicePixelRatio);\n  if (!Number.isFinite(ratio) || ratio <= 0) {\n    return 1;\n  }\n  return ratio;\n};\n\nconst calculateLaneMetricsImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  if (!canvas) {\n    return;\n  }\n\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / Math.max(this.canvasDpr, 1);\n  const baseHeight = Math.max(MIN_FONT_SIZE_PX, Math.floor(effectiveHeight * 0.05));\n  this.laneHeight = baseHeight * 1.2;\n  const availableLanes = Math.floor(effectiveHeight / Math.max(this.laneHeight, 1));\n  if (this._settings.useFixedLaneCount) {\n    const desired = Number.isFinite(this._settings.fixedLaneCount)\n      ? Math.floor(this._settings.fixedLaneCount)\n      : DEFAULT_LANE_COUNT;\n    const clamped = Math.max(MIN_LANE_COUNT, Math.min(availableLanes, desired));\n    this.laneCount = clamped;\n  } else {\n    this.laneCount = Math.max(MIN_LANE_COUNT, availableLanes);\n  }\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n};\n\nconst setupResizeHandlingImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  this.cleanupResizeHandling();\n\n  if (this._settings.useContainerResizeObserver && this.isResizeObserverAvailable) {\n    const target = this.resolveResizeObserverTarget(videoElement);\n    const observer = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { width, height } = entry.contentRect;\n        if (width > 0 && height > 0) {\n          this.resize(width, height);\n        } else {\n          this.resize();\n        }\n      }\n    });\n    observer.observe(target);\n    this.resizeObserver = observer;\n    this.resizeObserverTarget = target;\n  } else if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\") {\n    const onResize = (): void => {\n      this.resize();\n    };\n    window.addEventListener(\"resize\", onResize);\n    this.addCleanup(() => window.removeEventListener(\"resize\", onResize));\n  } else {\n    this.log.debug(\n      \"Resize handling is disabled because neither ResizeObserver nor window APIs are available.\",\n    );\n  }\n};\n\nconst cleanupResizeHandlingImpl = function (this: CommentRenderer): void {\n  if (this.resizeObserver && this.resizeObserverTarget) {\n    this.resizeObserver.unobserve(this.resizeObserverTarget);\n  }\n  this.resizeObserver?.disconnect();\n  this.resizeObserver = null;\n  this.resizeObserverTarget = null;\n};\n\nexport const registerResizeMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.resize = resizeImpl;\n  ctor.prototype.resolveDevicePixelRatio = resolveDevicePixelRatioImpl;\n  ctor.prototype.calculateLaneMetrics = calculateLaneMetricsImpl;\n  ctor.prototype.setupResizeHandling = setupResizeHandlingImpl;\n  ctor.prototype.cleanupResizeHandling = cleanupResizeHandlingImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nconst setupFullscreenHandlingImpl = function (this: CommentRenderer): void {\n  if (\n    typeof document === \"undefined\" ||\n    typeof document.addEventListener !== \"function\" ||\n    typeof document.removeEventListener !== \"function\"\n  ) {\n    return;\n  }\n\n  const onFullscreenChange = (): void => {\n    void this.handleFullscreenChange();\n  };\n\n  const events = [\n    \"fullscreenchange\",\n    \"webkitfullscreenchange\",\n    \"mozfullscreenchange\",\n    \"MSFullscreenChange\",\n  ];\n\n  events.forEach((eventName) => {\n    document.addEventListener(eventName, onFullscreenChange);\n    this.addCleanup(() => document.removeEventListener(eventName, onFullscreenChange));\n  });\n\n  void this.handleFullscreenChange();\n};\n\nconst resolveResizeObserverTargetImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): Element {\n  const fullscreenContainer = this.resolveFullscreenContainer(videoElement);\n  if (fullscreenContainer) {\n    return fullscreenContainer;\n  }\n  return videoElement.parentElement ?? videoElement;\n};\n\nconst handleFullscreenChangeImpl = async function (this: CommentRenderer): Promise<void> {\n  const canvas = this.canvas;\n  const video = this.videoElement;\n  if (!canvas || !video) {\n    return;\n  }\n\n  const baseContainer = this.containerElement ?? video.parentElement ?? null;\n  const fullscreenElement = this.getFullscreenElement();\n  const nextContainer = this.resolveActiveOverlayContainer(video, baseContainer, fullscreenElement);\n\n  if (!(nextContainer instanceof HTMLElement)) {\n    return;\n  }\n\n  if (canvas.parentElement !== nextContainer) {\n    this.ensureContainerPositioning(nextContainer);\n    nextContainer.appendChild(canvas);\n  } else {\n    this.ensureContainerPositioning(nextContainer);\n  }\n\n  const fullscreenContainer =\n    fullscreenElement instanceof HTMLElement && fullscreenElement.contains(video)\n      ? fullscreenElement\n      : null;\n  const isFullscreenNow = fullscreenContainer !== null;\n  if (this.fullscreenActive !== isFullscreenNow) {\n    this.fullscreenActive = isFullscreenNow;\n    this.setupResizeHandling(video);\n  }\n\n  canvas.style.position = \"absolute\";\n  canvas.style.top = \"0\";\n  canvas.style.left = \"0\";\n\n  this.resize();\n};\n\nconst resolveFullscreenContainerImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): HTMLElement | null {\n  const fullscreenElement = this.getFullscreenElement();\n  if (!(fullscreenElement instanceof HTMLElement)) {\n    return null;\n  }\n  if (fullscreenElement === videoElement) {\n    return fullscreenElement;\n  }\n  if (fullscreenElement.contains(videoElement)) {\n    return fullscreenElement;\n  }\n  return null;\n};\n\nconst resolveActiveOverlayContainerImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n  baseContainer: HTMLElement | null,\n  fullscreenElement: Element | null,\n): HTMLElement | null {\n  if (fullscreenElement instanceof HTMLElement && fullscreenElement.contains(videoElement)) {\n    if (fullscreenElement instanceof HTMLVideoElement) {\n      if (baseContainer instanceof HTMLElement) {\n        return baseContainer;\n      }\n      return fullscreenElement;\n    }\n    return fullscreenElement;\n  }\n  return baseContainer ?? null;\n};\n\nconst getFullscreenElementImpl = function (this: CommentRenderer): Element | null {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const doc = document as Document & {\n    webkitFullscreenElement?: Element | null;\n    msFullscreenElement?: Element | null;\n    mozFullScreenElement?: Element | null;\n  };\n  return (\n    document.fullscreenElement ??\n    doc.webkitFullscreenElement ??\n    doc.mozFullScreenElement ??\n    doc.msFullscreenElement ??\n    null\n  );\n};\n\nexport const registerFullscreenMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupFullscreenHandling = setupFullscreenHandlingImpl;\n  ctor.prototype.resolveResizeObserverTarget = resolveResizeObserverTargetImpl;\n  ctor.prototype.handleFullscreenChange = handleFullscreenChangeImpl;\n  ctor.prototype.resolveFullscreenContainer = resolveFullscreenContainerImpl;\n  ctor.prototype.resolveActiveOverlayContainer = resolveActiveOverlayContainerImpl;\n  ctor.prototype.getFullscreenElement = getFullscreenElementImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nconst addCleanupImpl = function (this: CommentRenderer, task: () => void): void {\n  this.cleanupTasks.push(task);\n};\n\nconst runCleanupTasksImpl = function (this: CommentRenderer): void {\n  while (this.cleanupTasks.length > 0) {\n    const task = this.cleanupTasks.pop();\n    try {\n      task?.();\n    } catch (error) {\n      this.log.error(\"CommentRenderer.cleanupTask\", error as Error);\n    }\n  }\n};\n\nexport const registerCleanupMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.addCleanup = addCleanupImpl;\n  ctor.prototype.runCleanupTasks = runCleanupTasksImpl;\n};\n","import { cloneDefaultSettings } from \"@/config/default-settings\";\nimport type {\n  RendererSettings,\n  CommentRendererEventHooks,\n  CommentDependencies,\n  CommentPrepareOptions,\n  TimeSource,\n} from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport { createDefaultTimeSource } from \"@/comment/time-source\";\nimport { createLogger } from \"@/shared/logger\";\nimport type { Logger } from \"@/shared/types\";\nimport { configureDebugLogging } from \"@/shared/debug\";\nimport {\n  createBrowserCanvasFactory,\n  createDefaultAnimationFrameProvider,\n  isRendererSettings,\n  normalizeSettings,\n} from \"@/shared/settings\";\nexport { createDefaultAnimationFrameProvider } from \"@/shared/settings\";\nimport type {\n  AnimationFrameProvider,\n  CommentRendererConfig,\n  CommentRendererInitializeOptions,\n  LaneReservation,\n  StaticLaneReservation,\n  VideoFrameCallbackMetadataLike,\n} from \"@/shared/types\";\nimport { DEFAULT_LANE_COUNT } from \"@/shared/constants\";\nimport { rebuildNgMatchersImpl, registerCommentCollectionMethods } from \"@/renderer/comments\";\nimport { registerFinalPhaseMethods } from \"@/renderer/final-phase\";\nimport { registerPlaybackHelpers } from \"@/renderer/playback\";\nimport { registerActivationMethods } from \"@/renderer/activation\";\nimport { registerLanePruneMethods } from \"@/renderer/lanes-prune\";\nimport { registerLaneStaticMethods } from \"@/renderer/lanes-static\";\nimport { registerLaneActivationMethods } from \"@/renderer/lanes-activation\";\nimport { registerLaneReservationMethods } from \"@/renderer/lanes-reservations\";\nimport { registerRenderMethods } from \"@/renderer/render\";\nimport { registerTimingMethods } from \"@/renderer/timing\";\nimport { registerLifecycleCoreMethods } from \"@/renderer/lifecycle-core\";\nimport { registerLifecycleVideoMethods } from \"@/renderer/lifecycle-video-events\";\nimport { registerVisibilityMethods } from \"@/renderer/visibility\";\nimport { registerResizeMethods } from \"@/renderer/resize\";\nimport { registerFullscreenMethods } from \"@/renderer/fullscreen\";\nimport { registerCleanupMethods } from \"@/renderer/cleanup\";\n\nexport type { CommentRendererConfig, CommentRendererInitializeOptions, AnimationFrameProvider };\n\nexport class CommentRenderer {\n  public _settings: RendererSettings;\n  public readonly comments: Comment[] = [];\n  public readonly activeComments = new Set<Comment>();\n  public readonly reservedLanes = new Map<number, LaneReservation[]>();\n  public readonly topStaticLaneReservations: StaticLaneReservation[] = [];\n  public readonly bottomStaticLaneReservations: StaticLaneReservation[] = [];\n  public readonly log: Logger;\n  public readonly timeSource: TimeSource;\n  public readonly animationFrameProvider: AnimationFrameProvider;\n  public readonly createCanvasElement: () => HTMLCanvasElement;\n  public readonly commentDependencies: CommentDependencies;\n  public settingsVersion = 0;\n  public normalizedNgWords: string[] = [];\n  public compiledNgRegexps: RegExp[] = [];\n  public canvas: HTMLCanvasElement | null = null;\n  public ctx: CanvasRenderingContext2D | null = null;\n  public videoElement: HTMLVideoElement | null = null;\n  public containerElement: HTMLElement | null = null;\n  public fullscreenActive = false;\n  public laneCount = DEFAULT_LANE_COUNT;\n  public laneHeight = 0;\n  public displayWidth = 0;\n  public displayHeight = 0;\n  public canvasDpr = 1;\n  public currentTime = 0;\n  public duration = 0;\n  public playbackRate = 1;\n  public isPlaying = true;\n  public isStalled = false;\n  public lastDrawTime = 0;\n  public finalPhaseActive = false;\n  public finalPhaseStartTime: number | null = null;\n  public finalPhaseScheduleDirty = false;\n  public playbackHasBegun = false;\n  public skipDrawingForCurrentFrame = false;\n  public pendingInitialSync = false;\n  public readonly finalPhaseVposOverrides = new Map<Comment, number>();\n  public frameId: ReturnType<typeof setTimeout> | null = null;\n  public videoFrameHandle: number | null = null;\n  public resizeObserver: ResizeObserver | null = null;\n  public resizeObserverTarget: Element | null = null;\n  public readonly isResizeObserverAvailable = typeof ResizeObserver !== \"undefined\";\n  public readonly cleanupTasks: Array<() => void> = [];\n  public commentSequence = 0;\n  public epochId = 0;\n  public readonly eventHooks: CommentRendererEventHooks;\n  public lastSnapshotEmitTime = 0;\n  public readonly snapshotEmitThrottleMs = 1000;\n  public lastPlayResumeTime = 0;\n  public readonly playResumeSeekIgnoreDurationMs = 500;\n  public lastVideoSource: string | null = null;\n\n  declare public initialize: (options: HTMLVideoElement | CommentRendererInitializeOptions) => void;\n  declare public destroy: () => void;\n  declare public destroyCanvasOnly: () => void;\n  declare public resolveContainer: (\n    explicit: HTMLElement | null | undefined,\n    video: HTMLVideoElement,\n  ) => HTMLElement;\n  declare public ensureContainerPositioning: (container: HTMLElement) => void;\n  declare public resize: (width?: number, height?: number) => void;\n  declare public resolveDevicePixelRatio: () => number;\n  declare public calculateLaneMetrics: () => void;\n  declare public setupResizeHandling: (videoElement: HTMLVideoElement) => void;\n  declare public cleanupResizeHandling: () => void;\n  declare public setupVideoEventListeners: (videoElement: HTMLVideoElement) => void;\n  declare public handleVideoMetadataLoaded: (videoElement: HTMLVideoElement) => void;\n  declare public handleVideoStalled: () => void;\n  declare public handleVideoCanPlay: () => void;\n  declare public handleVideoSourceChange: (videoElement?: HTMLVideoElement | null) => void;\n  declare public syncVideoState: (videoElement: HTMLVideoElement) => void;\n  declare public resetCommentActivity: () => void;\n  declare public setupVideoChangeDetection: (\n    video: HTMLVideoElement,\n    container: HTMLElement,\n  ) => void;\n  declare public extractVideoElement: (node: Node) => HTMLVideoElement | null;\n  declare public setupVisibilityHandling: () => void;\n  declare public handleVisibilityRestore: () => void;\n  declare public setupFullscreenHandling: () => void;\n  declare public resolveResizeObserverTarget: (videoElement: HTMLVideoElement) => Element;\n  declare public handleFullscreenChange: () => Promise<void>;\n  declare public resolveFullscreenContainer: (videoElement: HTMLVideoElement) => HTMLElement | null;\n  declare public resolveActiveOverlayContainer: (\n    videoElement: HTMLVideoElement,\n    baseContainer: HTMLElement | null,\n    fullscreenElement: Element | null,\n  ) => HTMLElement | null;\n  declare public getFullscreenElement: () => Element | null;\n  declare public addCleanup: (task: () => void) => void;\n  declare public runCleanupTasks: () => void;\n  public rebuildNgMatchers(): void {\n    rebuildNgMatchersImpl.call(this);\n  }\n  declare public isNGComment: (text: string) => boolean;\n  declare public addComments: (\n    entries: ReadonlyArray<{ text: string; vposMs: number; commands?: string[] }>,\n  ) => Comment[];\n  declare public addComment: (text: string, vposMs: number, commands?: string[]) => Comment | null;\n  declare public clearComments: () => void;\n  declare public resetState: () => void;\n  declare public hardReset: () => void;\n  declare public resetFinalPhaseState: () => void;\n  declare public incrementEpoch: (\n    reason: \"source-change\" | \"metadata-loaded\" | \"manual-reset\",\n  ) => void;\n  declare public emitStateSnapshot: (label: string) => void;\n  declare public getEffectiveCommentVpos: (comment: Comment) => number;\n  declare public getFinalPhaseDisplayDuration: (comment: Comment) => number;\n  declare public resolveFinalPhaseVpos: (comment: Comment) => number;\n  declare public recomputeFinalPhaseTimeline: () => void;\n  declare public shouldSuppressRendering: () => boolean;\n  declare public updatePlaybackProgressState: () => void;\n  declare public updateComments: (frameTimeMs?: number) => void;\n  declare public buildPrepareOptions: (visibleWidth: number) => CommentPrepareOptions;\n  declare public findAvailableLane: (comment: Comment) => number;\n  declare public findFirstValidReservationIndex: (\n    reservations: LaneReservation[],\n    cutoffTime: number,\n  ) => number;\n  declare public pruneLaneReservations: (currentTime: number) => void;\n  declare public pruneStaticLaneReservations: (currentTime: number) => void;\n  declare public findCommentIndexAtOrAfter: (targetVposMs: number) => number;\n  declare public getCommentsInTimeWindow: (centerTimeMs: number, windowMs: number) => Comment[];\n  declare public getStaticReservations: (position: \"ue\" | \"shita\") => StaticLaneReservation[];\n  declare public getStaticLaneDepth: (position: \"ue\" | \"shita\") => number;\n  declare public getStaticLaneLimit: (position: \"ue\" | \"shita\") => number;\n  declare public getGlobalLaneIndexForBottom: (localIndex: number) => number;\n  declare public resolveStaticCommentOffset: (\n    position: \"ue\" | \"shita\",\n    lane: number,\n    displayHeight: number,\n    comment: Comment,\n  ) => number;\n  declare public getStaticReservedLaneSet: () => Set<number>;\n  declare public shouldActivateCommentAtTime: (\n    comment: Comment,\n    timeMs: number,\n    preview?: string,\n  ) => boolean;\n  declare public activateComment: (\n    comment: Comment,\n    context: CanvasRenderingContext2D,\n    displayWidth: number,\n    displayHeight: number,\n    options: CommentPrepareOptions,\n    referenceTime: number,\n  ) => void;\n  declare public assignStaticLane: (\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    displayHeight: number,\n    currentTime: number,\n  ) => number;\n  declare public reserveStaticLane: (\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    lane: number,\n    releaseTime: number,\n  ) => void;\n  declare public releaseStaticLane: (position: \"ue\" | \"shita\", lane: number) => void;\n  declare public getLanePriorityOrder: (currentTime: number) => number[];\n  declare public getLaneNextAvailableTime: (lane: number, currentTime: number) => number;\n  declare public createLaneReservation: (\n    comment: Comment,\n    referenceTime: number,\n  ) => LaneReservation;\n  declare public isLaneAvailable: (\n    lane: number,\n    candidate: LaneReservation,\n    currentTime: number,\n  ) => boolean;\n  declare public storeLaneReservation: (lane: number, reservation: LaneReservation) => void;\n  declare public areReservationsConflicting: (a: LaneReservation, b: LaneReservation) => boolean;\n  declare public computeForwardGap: (\n    from: LaneReservation,\n    to: LaneReservation,\n    time: number,\n  ) => number;\n  declare public getBufferedEdges: (\n    reservation: LaneReservation,\n    time: number,\n  ) => { left: number; right: number };\n  declare public solveLeftRightEqualityTime: (\n    left: LaneReservation,\n    right: LaneReservation,\n  ) => number | null;\n  declare public draw: () => void;\n  declare public performInitialSync: (frameTimeMs?: number) => void;\n  declare public processFrame: (frameTimeMs?: number) => void;\n  declare public handleAnimationFrame: () => void;\n  declare public handleVideoFrame: (\n    now: DOMHighResTimeStamp,\n    metadata: VideoFrameCallbackMetadataLike,\n  ) => void;\n  declare public shouldUseVideoFrameCallback: () => boolean;\n  declare public scheduleNextFrame: () => void;\n  declare public cancelAnimationFrameRequest: () => void;\n  declare public cancelVideoFrameCallback: () => void;\n  declare public startAnimation: () => void;\n  declare public stopAnimation: () => void;\n  declare public onSeek: () => void;\n\n  constructor(settings: RendererSettings | null, config?: CommentRendererConfig);\n  constructor(config?: CommentRendererConfig);\n  constructor(\n    settingsOrConfig: RendererSettings | CommentRendererConfig | null = null,\n    maybeConfig: CommentRendererConfig | undefined = undefined,\n  ) {\n    let baseSettings: RendererSettings;\n    let config: CommentRendererConfig;\n\n    if (isRendererSettings(settingsOrConfig)) {\n      baseSettings = normalizeSettings({ ...(settingsOrConfig as RendererSettings) });\n      config = maybeConfig ?? {};\n    } else {\n      const configCandidate = settingsOrConfig ?? maybeConfig ?? {};\n      config =\n        typeof configCandidate === \"object\" ? (configCandidate as CommentRendererConfig) : {};\n      baseSettings = normalizeSettings(cloneDefaultSettings());\n    }\n\n    this._settings = normalizeSettings(baseSettings);\n    this.timeSource = config.timeSource ?? createDefaultTimeSource();\n    this.animationFrameProvider =\n      config.animationFrameProvider ?? createDefaultAnimationFrameProvider(this.timeSource);\n    this.createCanvasElement = config.createCanvasElement ?? createBrowserCanvasFactory();\n    this.commentDependencies = {\n      timeSource: this.timeSource,\n      settingsVersion: this.settingsVersion,\n    };\n    this.log = createLogger(config.loggerNamespace ?? \"CommentRenderer\");\n    this.eventHooks = config.eventHooks ?? {};\n\n    this.handleAnimationFrame = this.handleAnimationFrame.bind(this);\n    this.handleVideoFrame = this.handleVideoFrame.bind(this);\n\n    this.rebuildNgMatchers();\n\n    if (config.debug) {\n      configureDebugLogging(config.debug);\n    }\n  }\n\n  get settings(): RendererSettings {\n    return this._settings;\n  }\n\n  set settings(value: RendererSettings) {\n    this._settings = normalizeSettings(value);\n    this.settingsVersion += 1;\n    this.commentDependencies.settingsVersion = this.settingsVersion;\n    this.rebuildNgMatchers();\n  }\n\n  getVideoElement(): HTMLVideoElement | null {\n    return this.videoElement;\n  }\n\n  getCurrentVideoSource(): string | null {\n    const video = this.videoElement;\n    if (!video) {\n      return null;\n    }\n    if (typeof video.currentSrc === \"string\" && video.currentSrc.length > 0) {\n      return video.currentSrc;\n    }\n    const attribute = video.getAttribute(\"src\");\n    if (attribute && attribute.length > 0) {\n      return attribute;\n    }\n    const sourceElement = video.querySelector(\"source[src]\") as HTMLSourceElement | null;\n    if (sourceElement && typeof sourceElement.src === \"string\") {\n      return sourceElement.src;\n    }\n    return null;\n  }\n\n  getCommentsSnapshot(): Comment[] {\n    return [...this.comments];\n  }\n}\n\nregisterCommentCollectionMethods(CommentRenderer);\nregisterFinalPhaseMethods(CommentRenderer);\nregisterPlaybackHelpers(CommentRenderer);\nregisterActivationMethods(CommentRenderer);\nregisterLanePruneMethods(CommentRenderer);\nregisterLaneStaticMethods(CommentRenderer);\nregisterLaneActivationMethods(CommentRenderer);\nregisterLaneReservationMethods(CommentRenderer);\nregisterRenderMethods(CommentRenderer);\nregisterTimingMethods(CommentRenderer);\nregisterLifecycleCoreMethods(CommentRenderer);\nregisterLifecycleVideoMethods(CommentRenderer);\nregisterVisibilityMethods(CommentRenderer);\nregisterResizeMethods(CommentRenderer);\nregisterFullscreenMethods(CommentRenderer);\nregisterCleanupMethods(CommentRenderer);\n"],"names":["COMMENT_SIZE_SCALE","FONT_FAMILY_MAP","COLOR_COMMAND_MAP","HEX_COLOR_REGEX","COMMAND_PREFIX_STRIP_REGEX","COMMAND_SUFFIX_STRIP_REGEX","normalizeCommandToken","value","trimmed","normalizeHexColor","command","parseNumericCommandValue","withoutPx","parsed","parseLineHeightValue","numeric","clampLetterSpacing","clampLineHeight","isLayoutCommand","isSizeCommand","isFontCommand","isColorCommand","parseCommentCommands","commands","context","layout","size","font","colorOverride","opacityMultiplier","opacityOverride","isInvisible","letterSpacing","lineHeight","rawCommand","normalizedToken","normalized","lower","separatorIndex","numericValue","clampedOpacityMultiplier","resolvedColor","resolvedOpacityOverride","HEX_COLOR_PATTERN","expandHex","fragment","parseHexComponent","component","clampOpacity","resolveFillStyleWithOpacity","color","opacity","match","body","red","green","blue","alpha","combinedAlpha","createPerformanceTimeSource","createDefaultTimeSource","toMilliseconds","seconds","sanitizeVposMs","MAX_VISIBLE_DURATION_MS","MIN_VISIBLE_DURATION_MS","MAX_COMMENT_WIDTH_RATIO","COLLISION_BUFFER_RATIO","BASE_COLLISION_BUFFER_PX","ENTRY_BUFFER_PX","RESERVATION_TIME_MARGIN_MS","FINAL_PHASE_THRESHOLD_MS","FINAL_PHASE_MIN_GAP_MS","FINAL_PHASE_MAX_GAP_MS","FINAL_PHASE_ORDER_EPSILON_MS","FINAL_PHASE_MIN_WINDOW_MS","STATIC_VISIBLE_DURATION_MS","ACTIVE_WINDOW_MS","VIRTUAL_CANVAS_EXTENSION_PX","MIN_LANE_COUNT","DEFAULT_LANE_COUNT","MIN_FONT_SIZE_PX","EDGE_EPSILON","SEEK_DIRECTION_EPSILON_MS","STATIC_COMMENT_VERTICAL_PADDING_RATIO","STATIC_COMMENT_MIN_VERTICAL_PADDING_PX","STATIC_COMMENT_SIDE_MARGIN_PX","MIN_STATIC_FONT_SIZE_PX","LEVEL_PRIORITY","fallbackEmitter","level","namespace","args","consoleArgs","createLogger","options","emitter","threshold","emit","logLevel","messages","commentLogger","textMeasurementCaches","getTextMeasurementCache","ctx","cache","measureTextWidth","text","cacheKey","cached","width","ensureLines","rawLines","clampFontSize","updateTextMetrics","comment","maxLineWidth","effectiveLetterSpacing","line","baseWidth","extraSpacing","totalWidth","computedLineHeightPx","additionalHeight","prepareComment","visibleWidth","canvasHeight","safeVisibleWidth","baseFontSize","scaledFontSize","isStaticTopOrBottom","maxStaticWidth","minimumFontSize","shrinkFactor","initialShrink","iteration","currentShrink","proposedSize","margin","centeredX","maxStart","clampedX","maxReservationWidth","bufferFromWidth","entryBuffer","direction","startLeft","exitLeft","trailingBoundary","trailingEdgeAtStart","widthRatio","hasFixedDuration","visibleDurationMs","clampedRatio","adjustedDuration","visibleDistance","safeVisibleDuration","pixelsPerMs","pixelsPerFrame","travelDistance","preCollisionDistance","safePixelsPerMs","reservationBase","error","logger","DEFAULT_MAX_LOGS_PER_CATEGORY","state","categoryCounters","normalizeLimit","limit","rounded","configureDebugLogging","resetDebugCounters","isDebugLoggingEnabled","shouldEmitLog","category","currentCount","debugLog","payload","formatCommentPreview","maxLength","dumpRendererState","label","snapshot","logEpochChange","previousEpochId","newEpochId","reason","cacheStats","reportCacheStats","now","total","hitRate","avgCharsPerComment","totalOutlineCalls","totalFillCalls","isOffscreenCanvasSupported","getOutlineOffsets","fontSize","outlineThickness","offsets","diagonal","createSegmentDrawer","targetCtx","measurementCtx","statsTarget","baseDrawX","baselineY","mode","offsetX","leadingSpaces","leadingSpaceCount","leadingSpaceOffset","effectiveDrawX","trimmedLine","recordDraw","cursorX","index","char","advance","generateTextureCacheKey","createTextureCanvas","hasLetterSpacing","isMultiLine","padding","textureWidth","textureHeight","offscreen","offscreenCtx","effectiveOpacity","drawX","linesToRender","lineAdvance","baselineStart","drawSegment","outlineOffsets","drawOutline","outlineAlpha","offsetY","baseline","drawFill","fillStyle","baseShadowOffset","baseShadowBlur","layer","effectiveShadowAlpha","resolvedFillStyle","drawWithFallback","interpolatedX","drawComment","currentCacheKey","cachedTexture","created","texture","resolveScrollDirection","input","getDirectionSign","Comment","vposMs","settings","dependencies","parsedCommands","playbackRate","isPaused","currentTime","deltaTime","settingsVersion","defaultColor","candidate","defaultOpacity","scaled","atTimeMs","currentTimeMs","resolved","NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS","BASE_SETTINGS","DEFAULT_RENDERER_SETTINGS","cloneDefaultSettings","COMMENT_OVERLAY_VERSION","calculateStaticCommentVerticalPadding","normalizeSettings","rawDuration","normalizedDuration","createDefaultAnimationFrameProvider","timeSource","callback","handle","createBrowserCanvasFactory","isRendererSettings","addCommentsImpl","entries","addedComments","entry","preview","normalizedVposMs","a","b","vposMsDiff","addCommentImpl","clearCommentsImpl","effectiveDpr","height","resetStateImpl","rebuildNgMatchersImpl","ngWords","word","sourcePatterns","isNgCommentImpl","regexp","registerCommentCollectionMethods","ctor","hardResetImpl","canvas","effectiveWidth","effectiveHeight","resetFinalPhaseStateImpl","incrementEpochImpl","info","emitStateSnapshotImpl","getEffectiveCommentVposImpl","getFinalPhaseDisplayDurationImpl","durations","resolveFinalPhaseVposImpl","override","fallback","recomputeFinalPhaseTimelineImpl","windowStart","durationMs","windowEnd","candidates","diff","baseGap","boundedGap","gap","nextStart","durationNeeded","availableLatestStart","assigned","epsilon","spacing","registerFinalPhaseMethods","shouldSuppressRenderingImpl","updatePlaybackProgressStateImpl","registerPlaybackHelpers","updateCommentsImpl","frameTimeMs","video","referenceTime","prepareOptions","isNearEnd","activeWindowComments","debugActive","staticPosition","buildPrepareOptionsImpl","overrideDuration","maxVisibleDurationMs","minVisibleDurationMs","findAvailableLaneImpl","laneCandidates","newReservation","lane","fallbackLane","registerActivationMethods","findFirstValidReservationIndexImpl","reservations","cutoffTime","left","right","mid","reservation","pruneLaneReservationsImpl","firstValidIndex","pruneStaticLaneReservationsImpl","filterValid","topFiltered","bottomFiltered","registerLanePruneMethods","findCommentIndexAtOrAfterImpl","targetVposMs","getCommentsInTimeWindowImpl","centerTimeMs","windowMs","startTime","endTime","startIndex","result","i","getStaticReservationsImpl","position","getStaticLaneDepthImpl","getStaticLaneLimitImpl","otherPosition","otherDepth","available","getGlobalLaneIndexForBottomImpl","localIndex","resolveStaticCommentOffsetImpl","displayHeight","commentHeight","baseY","minY","maxY","adjustedY","getStaticReservedLaneSetImpl","reserved","registerLaneStaticMethods","shouldActivateCommentAtTimeImpl","timeMs","effectiveVpos","activateCommentImpl","displayWidth","elapsedMs","displacement","videoDuration","finalPhaseWindowEnd","totalTravelDistance","projectedTravelMs","remainingTime","allowedTravel","startX","laneIndex","laneHeight","laneY","verticalOffset","displayEnd","assignStaticLaneImpl","laneCount","laneIndices","_","yOffset","yStart","yEnd","earliestRelease","reserveStaticLaneImpl","releaseTime","releaseStaticLaneImpl","r","registerLaneActivationMethods","getLanePriorityOrderImpl","sorted","nextA","nextB","staticReserved","preferred","blocked","getLaneNextAvailableTimeImpl","validIndex","createLaneReservationImpl","speed","effectiveStart","baseStartTime","totalEndTime","isLaneAvailableImpl","storeLaneReservationImpl","updated","areReservationsConflictingImpl","overlapStart","overlapEnd","evaluationTimes","forwardIntersection","backwardIntersection","time","forwardGap","backwardGap","computeForwardGapImpl","from","to","fromEdges","toEdges","getBufferedEdgesImpl","elapsed","rawLeft","solveLeftRightEqualityTimeImpl","leftSign","rightSign","denominator","registerLaneReservationMethods","drawImpl","activeComments","aVpos","bVpos","performInitialSyncImpl","absoluteTime","registerRenderMethods","processFrameImpl","handleAnimationFrameImpl","pendingId","handleVideoFrameImpl","_now","metadata","mediaTime","shouldUseVideoFrameCallbackImpl","scheduleNextFrameImpl","request","cancelAnimationFrameRequestImpl","cancelVideoFrameCallbackImpl","startAnimationImpl","stopAnimationImpl","onSeekImpl","nextTime","timeDelta","isSignificantSeek","registerTimingMethods","resolveContainerImpl","explicit","ensureContainerPositioningImpl","container","initializeImpl","containerCandidate","parent","destroyImpl","destroyCanvasOnlyImpl","registerLifecycleCoreMethods","setupVideoEventListenersImpl","videoElement","onPlay","onPause","onSeeking","onSeeked","onRateChange","onLoadedMetadata","onDurationChange","onEmptied","onWaiting","onCanPlay","onPlaying","handleVideoMetadataLoadedImpl","handleVideoStalledImpl","handleVideoCanPlayImpl","handleVideoSourceChangeImpl","target","currentSource","syncVideoStateImpl","resetCommentActivityImpl","setupVideoChangeDetectionImpl","videoObserver","mutations","mutation","targetNode","previous","current","node","containerObserver","nextVideo","removedVideo","extractVideoElementImpl","registerLifecycleVideoMethods","setupVisibilityHandlingImpl","enforceVisibilityState","handleVisibilityRestoreImpl","registerVisibilityMethods","resizeImpl","rect","currentDpr","fallbackWidth","fallbackHeight","measuredWidth","measuredHeight","cssWidth","cssHeight","previousDisplayWidth","previousDisplayHeight","nextDpr","pixelWidth","pixelHeight","scaleX","scaleY","resolveDevicePixelRatioImpl","ratio","calculateLaneMetricsImpl","baseHeight","availableLanes","desired","clamped","setupResizeHandlingImpl","observer","onResize","cleanupResizeHandlingImpl","registerResizeMethods","setupFullscreenHandlingImpl","onFullscreenChange","eventName","resolveResizeObserverTargetImpl","fullscreenContainer","handleFullscreenChangeImpl","baseContainer","fullscreenElement","nextContainer","isFullscreenNow","resolveFullscreenContainerImpl","resolveActiveOverlayContainerImpl","getFullscreenElementImpl","doc","registerFullscreenMethods","addCleanupImpl","task","runCleanupTasksImpl","registerCleanupMethods","CommentRenderer","settingsOrConfig","maybeConfig","baseSettings","config","configCandidate","attribute","sourceElement"],"mappings":"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"}