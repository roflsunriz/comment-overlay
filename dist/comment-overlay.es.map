{"version":3,"file":"comment-overlay.es","sources":["../src/shared/logger.ts","../src/core/comment-commands.ts","../src/core/comment.ts","../src/config/default-settings.ts","../src/core/comment-renderer.ts"],"sourcesContent":["export type LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nexport interface Logger {\n  debug: (...messages: unknown[]) => void;\n  info: (...messages: unknown[]) => void;\n  warn: (...messages: unknown[]) => void;\n  error: (...messages: unknown[]) => void;\n}\n\nexport interface LoggerOptions {\n  level?: LogLevel;\n  emitter?: (level: LogLevel, namespace: string, args: unknown[]) => void;\n}\n\nconst LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nconst fallbackEmitter = (level: LogLevel, namespace: string, args: unknown[]): void => {\n  const prefix = `[${namespace}]`;\n  const consoleArgs: unknown[] = [prefix, ...args];\n  switch (level) {\n    case \"debug\":\n      console.debug(...consoleArgs);\n      break;\n    case \"info\":\n      console.info(...consoleArgs);\n      break;\n    case \"warn\":\n      console.warn(...consoleArgs);\n      break;\n    case \"error\":\n      console.error(...consoleArgs);\n      break;\n    default:\n      console.log(...consoleArgs);\n  }\n};\n\nexport const createLogger = (namespace: string, options: LoggerOptions = {}): Logger => {\n  const { level = \"info\", emitter = fallbackEmitter } = options;\n  const threshold = LEVEL_PRIORITY[level];\n\n  const emit = (logLevel: LogLevel, args: unknown[]): void => {\n    if (LEVEL_PRIORITY[logLevel] < threshold) {\n      return;\n    }\n    emitter(logLevel, namespace, args);\n  };\n\n  return {\n    debug: (...messages: unknown[]) => emit(\"debug\", messages),\n    info: (...messages: unknown[]) => emit(\"info\", messages),\n    warn: (...messages: unknown[]) => emit(\"warn\", messages),\n    error: (...messages: unknown[]) => emit(\"error\", messages),\n  };\n};\n","import {\n  type CommentColorCommand,\n  type CommentCommandParseContext,\n  type CommentCommandParseResult,\n  type CommentFontCommand,\n  type CommentHexColorCommand,\n  type CommentLayoutCommand,\n  type CommentSizeCommand,\n} from \"../types/comment\";\n\nconst COMMENT_SIZE_SCALE: Record<CommentSizeCommand, number> = {\n  small: 0.8,\n  medium: 1,\n  big: 1.4,\n};\n\nconst FONT_FAMILY_MAP: Record<CommentFontCommand, string> = {\n  defont:\n    'system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Hiragino Kaku Gothic ProN\", \"Hiragino Sans\", \"Noto Sans JP\", \"Yu Gothic UI\", sans-serif',\n  gothic:\n    '\"Noto Sans JP\", \"Yu Gothic\", \"Yu Gothic Medium\", \"Hiragino Kaku Gothic ProN\", \"Meiryo\", \"Segoe UI\", sans-serif',\n  mincho:\n    '\"Noto Serif JP\", \"Yu Mincho\", \"Hiragino Mincho ProN\", \"MS Mincho\", \"Times New Roman\", serif',\n};\n\nconst COLOR_COMMAND_MAP: Record<CommentColorCommand, string> = {\n  white: \"#FFFFFF\",\n  red: \"#FF0000\",\n  pink: \"#FF8080\",\n  orange: \"#FF9900\",\n  yellow: \"#FFFF00\",\n  green: \"#00FF00\",\n  cyan: \"#00FFFF\",\n  blue: \"#0000FF\",\n  purple: \"#C000FF\",\n  black: \"#000000\",\n  white2: \"#CC9\",\n  red2: \"#C03\",\n  pink2: \"#F3C\",\n  orange2: \"#F60\",\n  yellow2: \"#990\",\n  green2: \"#0C6\",\n  cyan2: \"#0CC\",\n  blue2: \"#39F\",\n  purple2: \"#63C\",\n  black2: \"#666\",\n};\n\nconst HEX_COLOR_REGEX = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;\n\nconst COMMAND_PREFIX_STRIP_REGEX = /^[,.:;]+/;\nconst COMMAND_SUFFIX_STRIP_REGEX = /[,.:;]+$/;\n\nconst normalizeCommandToken = (value: string): string => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return \"\";\n  }\n  if (HEX_COLOR_REGEX.test(trimmed)) {\n    return trimmed;\n  }\n  const withoutPrefix = trimmed.replace(COMMAND_PREFIX_STRIP_REGEX, \"\");\n  const withoutSuffix = withoutPrefix.replace(COMMAND_SUFFIX_STRIP_REGEX, \"\");\n  return withoutSuffix;\n};\n\nconst normalizeHexColor = (command: CommentHexColorCommand): string | null => {\n  if (!HEX_COLOR_REGEX.test(command)) {\n    return null;\n  }\n  return command.toUpperCase();\n};\n\nconst isLayoutCommand = (command: string): command is CommentLayoutCommand =>\n  command === \"naka\" || command === \"ue\" || command === \"shita\";\n\nconst isSizeCommand = (command: string): command is CommentSizeCommand =>\n  command === \"small\" || command === \"medium\" || command === \"big\";\n\nconst isFontCommand = (command: string): command is CommentFontCommand =>\n  command === \"defont\" || command === \"gothic\" || command === \"mincho\";\n\nconst isColorCommand = (command: string): command is CommentColorCommand =>\n  command in COLOR_COMMAND_MAP;\n\nexport const parseCommentCommands = (\n  commands: readonly string[],\n  context: CommentCommandParseContext,\n): CommentCommandParseResult => {\n  let layout: CommentLayoutCommand = \"naka\";\n  let size: CommentSizeCommand = \"medium\";\n  let font: CommentFontCommand = \"defont\";\n  let colorOverride: string | null = null;\n  let opacityMultiplier = 1;\n  let opacityOverride: number | null = null;\n  let isInvisible = false;\n\n  for (const rawCommand of commands) {\n    const normalizedToken = normalizeCommandToken(typeof rawCommand === \"string\" ? rawCommand : \"\");\n    if (!normalizedToken) {\n      continue;\n    }\n\n    if (HEX_COLOR_REGEX.test(normalizedToken)) {\n      const normalized = normalizeHexColor(normalizedToken as CommentHexColorCommand);\n      if (normalized) {\n        colorOverride = normalized;\n        continue;\n      }\n    }\n\n    const lower = normalizedToken.toLowerCase();\n\n    if (isLayoutCommand(lower)) {\n      layout = lower;\n      continue;\n    }\n\n    if (isSizeCommand(lower)) {\n      size = lower;\n      continue;\n    }\n\n    if (isFontCommand(lower)) {\n      font = lower;\n      continue;\n    }\n\n    if (isColorCommand(lower)) {\n      colorOverride = COLOR_COMMAND_MAP[lower].toUpperCase();\n      continue;\n    }\n\n    if (lower === \"_live\") {\n      opacityOverride = 0.5;\n      continue;\n    }\n\n    if (lower === \"invisible\") {\n      opacityMultiplier = 0;\n      isInvisible = true;\n    }\n  }\n\n  const clampedOpacityMultiplier = Math.max(0, Math.min(1, opacityMultiplier));\n  const resolvedColor = (colorOverride ?? context.defaultColor).toUpperCase();\n  const resolvedOpacityOverride =\n    typeof opacityOverride === \"number\" ? Math.max(0, Math.min(1, opacityOverride)) : null;\n\n  return {\n    layout,\n    size,\n    sizeScale: COMMENT_SIZE_SCALE[size],\n    font,\n    fontFamily: FONT_FAMILY_MAP[font],\n    resolvedColor,\n    colorOverride,\n    opacityMultiplier: clampedOpacityMultiplier,\n    opacityOverride: resolvedOpacityOverride,\n    isInvisible,\n  };\n};\n","import type { RendererSettings } from \"../shared/types\";\nimport { createLogger } from \"../shared/logger\";\nimport { parseCommentCommands } from \"./comment-commands\";\nimport type { CommentLayoutCommand } from \"../types/comment\";\n\nconst logger = createLogger(\"CommentEngine:Comment\");\n\nexport const STATIC_VISIBLE_DURATION_MS = 4_000;\n\nexport interface TimeSource {\n  now(): number;\n}\n\nconst createPerformanceTimeSource = (): TimeSource => ({\n  now: () => {\n    if (typeof performance !== \"undefined\" && typeof performance.now === \"function\") {\n      return performance.now();\n    }\n    return Date.now();\n  },\n});\n\nexport const createDefaultTimeSource = (): TimeSource => createPerformanceTimeSource();\n\nexport interface CommentDependencies {\n  timeSource?: TimeSource;\n}\n\nexport interface CommentPrepareOptions {\n  visibleWidth: number;\n  virtualExtension: number;\n  maxVisibleDurationMs: number;\n  minVisibleDurationMs: number;\n  maxWidthRatio: number;\n  bufferRatio: number;\n  baseBufferPx: number;\n  entryBufferPx: number;\n}\n\nexport class Comment {\n  readonly text: string;\n  readonly vpos: number;\n  readonly commands: string[];\n  readonly layout: CommentLayoutCommand;\n  readonly isScrolling: boolean;\n  readonly sizeScale: number;\n  readonly opacityMultiplier: number;\n  readonly opacityOverride: number | null;\n  readonly colorOverride: string | null;\n  readonly isInvisible: boolean;\n\n  x = 0;\n  y = 0;\n  width = 0;\n  height = 0;\n  baseSpeed = 0;\n  speed = 0;\n  lane = -1;\n  color: string;\n  fontSize = 0;\n  fontFamily: string;\n  opacity: number;\n  activationTimeMs: number | null = null;\n  staticExpiryTimeMs: number | null = null;\n  isActive = false;\n  hasShown = false;\n  isPaused = false;\n  lastUpdateTime = 0;\n  reservationWidth = 0;\n  bufferWidth = 0;\n  visibleDurationMs = 0;\n  totalDurationMs = 0;\n  preCollisionDurationMs = 0;\n  speedPixelsPerMs = 0;\n  virtualStartX = 0;\n  private readonly timeSource: TimeSource;\n\n  constructor(\n    text: string,\n    vpos: number,\n    commands: string[] | undefined,\n    settings: RendererSettings,\n    dependencies: CommentDependencies = {},\n  ) {\n    if (typeof text !== \"string\") {\n      throw new Error(\"Comment text must be a string\");\n    }\n    if (!Number.isFinite(vpos) || vpos < 0) {\n      throw new Error(\"Comment vpos must be a non-negative number\");\n    }\n\n    this.text = text;\n    this.vpos = vpos;\n    this.commands = Array.isArray(commands) ? [...commands] : [];\n\n    const parsedCommands = parseCommentCommands(this.commands, {\n      defaultColor: settings.commentColor,\n    });\n\n    this.layout = parsedCommands.layout;\n    this.isScrolling = this.layout === \"naka\";\n    this.sizeScale = parsedCommands.sizeScale;\n    this.opacityMultiplier = parsedCommands.opacityMultiplier;\n    this.opacityOverride = parsedCommands.opacityOverride;\n    this.colorOverride = parsedCommands.colorOverride;\n    this.isInvisible = parsedCommands.isInvisible;\n    this.fontFamily = parsedCommands.fontFamily;\n    this.color = parsedCommands.resolvedColor;\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n\n    this.timeSource = dependencies.timeSource ?? createDefaultTimeSource();\n    this.syncWithSettings(settings);\n  }\n\n  prepare(\n    ctx: CanvasRenderingContext2D,\n    visibleWidth: number,\n    canvasHeight: number,\n    options: CommentPrepareOptions,\n  ): void {\n    try {\n      if (!ctx) {\n        throw new Error(\"Canvas context is required\");\n      }\n      if (!Number.isFinite(visibleWidth) || !Number.isFinite(canvasHeight)) {\n        throw new Error(\"Canvas dimensions must be numbers\");\n      }\n      if (!options) {\n        throw new Error(\"Prepare options are required\");\n      }\n\n      const safeVisibleWidth = Math.max(visibleWidth, 1);\n      const baseFontSize = Math.max(24, Math.floor(canvasHeight * 0.05));\n      const scaledFontSize = Math.max(24, Math.floor(baseFontSize * this.sizeScale));\n      this.fontSize = scaledFontSize;\n      ctx.font = `${this.fontSize}px ${this.fontFamily}`;\n      this.width = ctx.measureText(this.text).width;\n      this.height = this.fontSize;\n\n      if (!this.isScrolling) {\n        this.bufferWidth = 0;\n        const centeredX = Math.max((safeVisibleWidth - this.width) / 2, 0);\n        this.virtualStartX = centeredX;\n        this.x = centeredX;\n        this.baseSpeed = 0;\n        this.speed = 0;\n        this.speedPixelsPerMs = 0;\n        this.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n        this.preCollisionDurationMs = STATIC_VISIBLE_DURATION_MS;\n        this.totalDurationMs = STATIC_VISIBLE_DURATION_MS;\n        this.reservationWidth = this.width;\n        this.staticExpiryTimeMs = this.vpos + STATIC_VISIBLE_DURATION_MS;\n        this.lastUpdateTime = this.timeSource.now();\n        this.isPaused = false;\n        return;\n      }\n\n      this.staticExpiryTimeMs = null;\n      const maxReservationWidth = ctx.measureText(\"??\".repeat(150)).width;\n\n      const bufferFromWidth = this.width * Math.max(options.bufferRatio, 0);\n      this.bufferWidth = Math.max(options.baseBufferPx, bufferFromWidth);\n      const entryBuffer = Math.max(options.entryBufferPx, this.bufferWidth);\n\n      this.virtualStartX = safeVisibleWidth + options.virtualExtension;\n      this.x = this.virtualStartX;\n\n      const widthRatio = this.width / safeVisibleWidth;\n      let visibleDurationMs = options.maxVisibleDurationMs;\n      if (widthRatio > 1) {\n        const clampedRatio = Math.min(widthRatio, options.maxWidthRatio);\n        const adjustedDuration = options.maxVisibleDurationMs / Math.max(clampedRatio, 1);\n        visibleDurationMs = Math.max(options.minVisibleDurationMs, Math.floor(adjustedDuration));\n      }\n\n      const visibleDistance = safeVisibleWidth + this.width + this.bufferWidth + entryBuffer;\n      const safeVisibleDuration = Math.max(visibleDurationMs, 1);\n      const pixelsPerMs = visibleDistance / safeVisibleDuration;\n      const pixelsPerFrame = (pixelsPerMs * 1000) / 60;\n      this.baseSpeed = pixelsPerFrame;\n      this.speed = this.baseSpeed;\n      this.speedPixelsPerMs = pixelsPerMs;\n\n      const travelDistance = this.virtualStartX + this.width + this.bufferWidth + entryBuffer;\n      const preCollisionBoundary = safeVisibleWidth + entryBuffer;\n      const startRight = this.virtualStartX + this.width + this.bufferWidth;\n      const safePixelsPerMs = Math.max(pixelsPerMs, Number.EPSILON);\n      const preCollisionDistance = Math.max(0, startRight - preCollisionBoundary);\n\n      this.visibleDurationMs = visibleDurationMs;\n      this.preCollisionDurationMs = Math.max(0, Math.ceil(preCollisionDistance / safePixelsPerMs));\n      this.totalDurationMs = Math.max(\n        this.preCollisionDurationMs,\n        Math.ceil(travelDistance / safePixelsPerMs),\n      );\n\n      const reservationBase = this.width + this.bufferWidth + entryBuffer;\n      this.reservationWidth = Math.min(maxReservationWidth, reservationBase);\n      this.lastUpdateTime = this.timeSource.now();\n      this.isPaused = false;\n    } catch (error) {\n      logger.error(\"Comment.prepare\", error as Error, {\n        text: this.text,\n        visibleWidth,\n        canvasHeight,\n        hasContext: Boolean(ctx),\n      });\n      throw error;\n    }\n  }\n\n  update(playbackRate = 1.0, isPaused = false): void {\n    try {\n      if (!this.isActive) {\n        this.isPaused = isPaused;\n        return;\n      }\n\n      const currentTime = this.timeSource.now();\n\n      if (!this.isScrolling) {\n        this.isPaused = isPaused;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      if (isPaused) {\n        this.isPaused = true;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      const deltaTime = (currentTime - this.lastUpdateTime) / (1000 / 60);\n      this.speed = this.baseSpeed * playbackRate;\n      this.x -= this.speed * deltaTime;\n      if (this.x < -this.width) {\n        this.isActive = false;\n      }\n      this.lastUpdateTime = currentTime;\n      this.isPaused = false;\n    } catch (error) {\n      logger.error(\"Comment.update\", error as Error, {\n        text: this.text,\n        playbackRate,\n        isPaused,\n        isActive: this.isActive,\n      });\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D, interpolatedX: number | null = null): void {\n    try {\n      if (!this.isActive || !ctx) {\n        return;\n      }\n\n      ctx.save();\n      ctx.globalAlpha = this.opacity;\n      ctx.font = `${this.fontSize}px ${this.fontFamily}`;\n\n      const drawX = interpolatedX ?? this.x;\n      const drawY = this.y + this.fontSize;\n\n      ctx.strokeStyle = \"#000000\";\n      ctx.lineWidth = Math.max(3, this.fontSize / 8);\n      ctx.lineJoin = \"round\";\n      ctx.strokeText(this.text, drawX, drawY);\n\n      const baseShadowOffset = Math.max(1, this.fontSize * 0.04);\n      const baseShadowBlur = this.fontSize * 0.18;\n      type ShadowLayer = Readonly<{\n        offsetXMultiplier: number;\n        offsetYMultiplier: number;\n        blurMultiplier: number;\n        alpha: number;\n        rgb: string;\n      }>;\n      const shadowLayers: ReadonlyArray<ShadowLayer> = [\n        {\n          offsetXMultiplier: 0.9,\n          offsetYMultiplier: 1.1,\n          blurMultiplier: 0.55,\n          alpha: 0.52,\n          rgb: \"20, 28, 40\",\n        },\n        {\n          offsetXMultiplier: 2.4,\n          offsetYMultiplier: 2.7,\n          blurMultiplier: 1.45,\n          alpha: 0.32,\n          rgb: \"0, 0, 0\",\n        },\n        {\n          offsetXMultiplier: -0.7,\n          offsetYMultiplier: -0.6,\n          blurMultiplier: 0.4,\n          alpha: 0.42,\n          rgb: \"255, 255, 255\",\n        },\n      ];\n\n      shadowLayers.forEach((layer) => {\n        const effectiveShadowAlpha = Math.max(0, Math.min(1, layer.alpha * this.opacity));\n        ctx.shadowColor = `rgba(${layer.rgb}, ${effectiveShadowAlpha})`;\n        ctx.shadowBlur = baseShadowBlur * layer.blurMultiplier;\n        ctx.shadowOffsetX = baseShadowOffset * layer.offsetXMultiplier;\n        ctx.shadowOffsetY = baseShadowOffset * layer.offsetYMultiplier;\n        ctx.fillStyle = this.color;\n        ctx.fillText(this.text, drawX, drawY);\n      });\n\n      ctx.shadowColor = \"transparent\";\n      ctx.shadowBlur = 0;\n      ctx.shadowOffsetX = 0;\n      ctx.shadowOffsetY = 0;\n\n      ctx.fillStyle = this.color;\n      ctx.fillText(this.text, drawX, drawY);\n\n      ctx.restore();\n    } catch (error) {\n      logger.error(\"Comment.draw\", error as Error, {\n        text: this.text,\n        isActive: this.isActive,\n        hasContext: Boolean(ctx),\n        interpolatedX,\n      });\n    }\n  }\n\n  syncWithSettings(settings: RendererSettings): void {\n    this.color = this.getEffectiveColor(settings.commentColor);\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n  }\n\n  getEffectiveColor(defaultColor: string): string {\n    const candidate = this.colorOverride ?? defaultColor;\n    if (typeof candidate !== \"string\" || candidate.length === 0) {\n      return defaultColor;\n    }\n    return candidate.toUpperCase();\n  }\n\n  getEffectiveOpacity(defaultOpacity: number): number {\n    if (typeof this.opacityOverride === \"number\") {\n      return Math.max(0, Math.min(1, this.opacityOverride));\n    }\n    const scaled = defaultOpacity * this.opacityMultiplier;\n    if (!Number.isFinite(scaled)) {\n      return 0;\n    }\n    return Math.max(0, Math.min(1, scaled));\n  }\n\n  markActivated(atTimeMs: number): void {\n    this.activationTimeMs = atTimeMs;\n  }\n\n  clearActivation(): void {\n    this.activationTimeMs = null;\n    if (!this.isScrolling) {\n      this.staticExpiryTimeMs = null;\n    }\n  }\n\n  hasStaticExpired(currentTimeMs: number): boolean {\n    if (this.isScrolling) {\n      return false;\n    }\n    if (this.staticExpiryTimeMs === null) {\n      return false;\n    }\n    return currentTimeMs >= this.staticExpiryTimeMs;\n  }\n}\n","import type { RendererSettings } from \"../shared/types\";\n\ntype ReadonlySettings = {\n  readonly [K in keyof RendererSettings]: RendererSettings[K] extends\n    | string\n    | number\n    | boolean\n    | null\n    | undefined\n    ? RendererSettings[K]\n    : ReadonlyArray<string>;\n};\n\nconst BASE_SETTINGS: RendererSettings = {\n  commentColor: \"#FFFFFF\",\n  commentOpacity: 0.75,\n  isCommentVisible: true,\n  useContainerResizeObserver: true,\n  ngWords: [],\n  ngRegexps: [],\n};\n\nexport const DEFAULT_RENDERER_SETTINGS: ReadonlySettings = BASE_SETTINGS;\n\nexport const cloneDefaultSettings = (): RendererSettings => ({\n  ...BASE_SETTINGS,\n  ngWords: [...BASE_SETTINGS.ngWords],\n  ngRegexps: [...BASE_SETTINGS.ngRegexps],\n});\n\nexport const RENDERER_VERSION = \"v1.0.0\";\n","import { cloneDefaultSettings } from \"../config/default-settings\";\nimport type { RendererSettings } from \"../shared/types\";\nimport {\n  Comment,\n  type CommentDependencies,\n  type CommentPrepareOptions,\n  type TimeSource,\n  createDefaultTimeSource,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"./comment\";\nimport { createLogger, type Logger } from \"../shared/logger\";\n\nexport interface CommentRendererConfig {\n  loggerNamespace?: string;\n  timeSource?: TimeSource;\n  animationFrameProvider?: AnimationFrameProvider;\n  createCanvasElement?: () => HTMLCanvasElement;\n}\n\nexport interface CommentRendererInitializeOptions {\n  video: HTMLVideoElement;\n  container?: HTMLElement | null;\n}\n\nexport interface AnimationFrameProvider {\n  request(callback: FrameRequestCallback): ReturnType<typeof setTimeout>;\n  cancel(handle: ReturnType<typeof setTimeout>): void;\n}\n\ninterface LaneReservation {\n  comment: Comment;\n  startTime: number;\n  endTime: number;\n  totalEndTime: number;\n  startLeft: number;\n  width: number;\n  speed: number;\n  buffer: number;\n}\n\nconst toMilliseconds = (seconds: number): number => seconds * 1000;\nconst FINAL_PHASE_THRESHOLD_MS = 10_000;\nconst ACTIVE_WINDOW_MS = 2_000;\nconst VIRTUAL_CANVAS_EXTENSION_PX = 1_000;\nconst MAX_VISIBLE_DURATION_MS = 4_000;\nconst MIN_VISIBLE_DURATION_MS = 1_800;\nconst MAX_COMMENT_WIDTH_RATIO = 3;\nconst COLLISION_BUFFER_RATIO = 0.25;\nconst BASE_COLLISION_BUFFER_PX = 32;\nconst ENTRY_BUFFER_PX = 48;\nconst RESERVATION_TIME_MARGIN_MS = 120;\nconst MIN_LANE_COUNT = 1;\nconst DEFAULT_LANE_COUNT = 12;\nconst MIN_FONT_SIZE_PX = 24;\nconst EDGE_EPSILON = 1e-3;\nconst SEEK_DIRECTION_EPSILON_MS = 50;\n\nexport const createDefaultAnimationFrameProvider = (\n  timeSource: TimeSource,\n): AnimationFrameProvider => {\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.requestAnimationFrame === \"function\" &&\n    typeof window.cancelAnimationFrame === \"function\"\n  ) {\n    return {\n      request: (callback) => window.requestAnimationFrame(callback),\n      cancel: (handle) => window.cancelAnimationFrame(handle),\n    };\n  }\n  return {\n    request: (callback) => {\n      const timeoutId = globalThis.setTimeout(() => {\n        callback(timeSource.now());\n      }, 16);\n      return timeoutId;\n    },\n    cancel: (handle) => {\n      globalThis.clearTimeout(handle);\n    },\n  };\n};\n\nconst createBrowserCanvasFactory = (): (() => HTMLCanvasElement) => {\n  if (typeof document === \"undefined\") {\n    return () => {\n      throw new Error(\n        \"Document is not available. Provide a custom createCanvasElement implementation.\",\n      );\n    };\n  }\n  return () => document.createElement(\"canvas\");\n};\n\nconst isRendererSettings = (input: unknown): input is RendererSettings => {\n  if (!input || typeof input !== \"object\") {\n    return false;\n  }\n  const candidate = input as Record<string, unknown>;\n  return (\n    typeof candidate.commentColor === \"string\" &&\n    typeof candidate.commentOpacity === \"number\" &&\n    typeof candidate.isCommentVisible === \"boolean\"\n  );\n};\n\nexport class CommentRenderer {\n  private _settings: RendererSettings;\n  private readonly comments: Comment[] = [];\n  private readonly reservedLanes = new Map<number, LaneReservation[]>();\n  private readonly topStaticLaneReservations = new Map<number, number>();\n  private readonly bottomStaticLaneReservations = new Map<number, number>();\n  private readonly log: Logger;\n  private readonly timeSource: TimeSource;\n  private readonly animationFrameProvider: AnimationFrameProvider;\n  private readonly createCanvasElement: () => HTMLCanvasElement;\n  private readonly commentDependencies: CommentDependencies;\n  private canvas: HTMLCanvasElement | null = null;\n  private ctx: CanvasRenderingContext2D | null = null;\n  private videoElement: HTMLVideoElement | null = null;\n  private containerElement: HTMLElement | null = null;\n  private laneCount = DEFAULT_LANE_COUNT;\n  private laneHeight = 0;\n  private currentTime = 0;\n  private duration = 0;\n  private playbackRate = 1;\n  private isPlaying = true;\n  private lastDrawTime = 0;\n  private finalPhaseActive = false;\n  private frameId: ReturnType<typeof setTimeout> | null = null;\n  private resizeObserver: ResizeObserver | null = null;\n  private resizeObserverTarget: Element | null = null;\n  private readonly isResizeObserverAvailable = typeof ResizeObserver !== \"undefined\";\n  private readonly cleanupTasks: Array<() => void> = [];\n\n  constructor(settings: RendererSettings | null, config?: CommentRendererConfig);\n  constructor(config?: CommentRendererConfig);\n  constructor(\n    settingsOrConfig: RendererSettings | CommentRendererConfig | null = null,\n    maybeConfig: CommentRendererConfig | undefined = undefined,\n  ) {\n    let baseSettings: RendererSettings;\n    let config: CommentRendererConfig;\n\n    if (isRendererSettings(settingsOrConfig)) {\n      baseSettings = { ...settingsOrConfig };\n      config = maybeConfig ?? {};\n    } else {\n      const configCandidate = settingsOrConfig ?? maybeConfig ?? {};\n      config =\n        typeof configCandidate === \"object\" ? (configCandidate as CommentRendererConfig) : {};\n      baseSettings = cloneDefaultSettings();\n    }\n\n    this.timeSource = config.timeSource ?? createDefaultTimeSource();\n    this.animationFrameProvider =\n      config.animationFrameProvider ?? createDefaultAnimationFrameProvider(this.timeSource);\n    this.createCanvasElement = config.createCanvasElement ?? createBrowserCanvasFactory();\n    this.commentDependencies = { timeSource: this.timeSource };\n    this._settings = { ...baseSettings };\n    this.log = createLogger(config.loggerNamespace ?? \"CommentRenderer\");\n  }\n\n  get settings(): RendererSettings {\n    return this._settings;\n  }\n\n  set settings(value: RendererSettings) {\n    this._settings = { ...value };\n  }\n\n  private resolveContainer(\n    explicit: HTMLElement | null | undefined,\n    video: HTMLVideoElement,\n  ): HTMLElement {\n    if (explicit) {\n      return explicit;\n    }\n    if (video.parentElement) {\n      return video.parentElement;\n    }\n    if (typeof document !== \"undefined\" && document.body) {\n      return document.body;\n    }\n    throw new Error(\n      \"Cannot resolve container element. Provide container explicitly when DOM is unavailable.\",\n    );\n  }\n\n  private ensureContainerPositioning(container: HTMLElement): void {\n    if (typeof getComputedStyle === \"function\") {\n      const style = getComputedStyle(container);\n      if (style.position === \"static\") {\n        container.style.position = \"relative\";\n      }\n      return;\n    }\n    if (!container.style.position) {\n      container.style.position = \"relative\";\n    }\n  }\n\n  initialize(options: HTMLVideoElement | CommentRendererInitializeOptions): void {\n    try {\n      this.destroyCanvasOnly();\n\n      const video = options instanceof HTMLVideoElement ? options : options.video;\n      const containerCandidate =\n        options instanceof HTMLVideoElement\n          ? options.parentElement\n          : (options.container ?? options.video.parentElement);\n      const container = this.resolveContainer(containerCandidate ?? null, video);\n\n      this.videoElement = video;\n      this.containerElement = container;\n      this.duration = Number.isFinite(video.duration) ? toMilliseconds(video.duration) : 0;\n      this.currentTime = toMilliseconds(video.currentTime);\n      this.playbackRate = video.playbackRate;\n      this.isPlaying = !video.paused;\n      this.lastDrawTime = this.timeSource.now();\n\n      const canvas = this.createCanvasElement();\n      const context = canvas.getContext(\"2d\");\n      if (!context) {\n        throw new Error(\"Failed to acquire 2D canvas context\");\n      }\n\n      canvas.style.position = \"absolute\";\n      canvas.style.top = \"0\";\n      canvas.style.left = \"0\";\n      canvas.style.pointerEvents = \"none\";\n      canvas.style.zIndex = \"1000\";\n\n      const parent = this.containerElement;\n      if (parent instanceof HTMLElement) {\n        this.ensureContainerPositioning(parent);\n        parent.appendChild(canvas);\n      }\n\n      this.canvas = canvas;\n      this.ctx = context;\n\n      this.resize();\n      this.calculateLaneMetrics();\n      this.setupVideoEventListeners(video);\n      this.setupResizeHandling(video);\n      this.setupVideoChangeDetection(video, container);\n      this.startAnimation();\n    } catch (error) {\n      this.log.error(\"CommentRenderer.initialize\", error as Error);\n      throw error;\n    }\n  }\n\n  addComment(text: string, vpos: number, commands: string[] = []): Comment | null {\n    if (this.isNGComment(text)) {\n      return null;\n    }\n    const duplicate = this.comments.some(\n      (comment) => comment.text === text && comment.vpos === vpos,\n    );\n    if (duplicate) {\n      return null;\n    }\n\n    const comment = new Comment(text, vpos, commands, this._settings, this.commentDependencies);\n    this.comments.push(comment);\n    this.comments.sort((a, b) => a.vpos - b.vpos);\n    return comment;\n  }\n\n  clearComments(): void {\n    this.comments.length = 0;\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.clear();\n    this.bottomStaticLaneReservations.clear();\n    if (this.ctx && this.canvas) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  resetState(): void {\n    this.clearComments();\n    this.currentTime = 0;\n    this.finalPhaseActive = false;\n  }\n\n  destroy(): void {\n    this.stopAnimation();\n    this.cleanupResizeHandling();\n    this.runCleanupTasks();\n\n    if (this.canvas) {\n      this.canvas.remove();\n    }\n    this.canvas = null;\n    this.ctx = null;\n    this.videoElement = null;\n    this.containerElement = null;\n    this.comments.length = 0;\n    this.reservedLanes.clear();\n    this.finalPhaseActive = false;\n  }\n\n  updateSettings(newSettings: RendererSettings): void {\n    const previousUseContainer = this._settings.useContainerResizeObserver;\n    this.settings = newSettings;\n\n    this.comments.forEach((comment) => {\n      comment.syncWithSettings(this._settings);\n    });\n\n    if (!this._settings.isCommentVisible && this.ctx && this.canvas) {\n      this.comments.forEach((comment) => {\n        comment.isActive = false;\n        comment.clearActivation();\n      });\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      this.reservedLanes.clear();\n      this.topStaticLaneReservations.clear();\n      this.bottomStaticLaneReservations.clear();\n    }\n\n    if (previousUseContainer !== this._settings.useContainerResizeObserver && this.videoElement) {\n      this.setupResizeHandling(this.videoElement);\n    }\n  }\n\n  getVideoElement(): HTMLVideoElement | null {\n    return this.videoElement;\n  }\n\n  getCurrentVideoSource(): string | null {\n    const video = this.videoElement;\n    if (!video) {\n      return null;\n    }\n    if (typeof video.currentSrc === \"string\" && video.currentSrc.length > 0) {\n      return video.currentSrc;\n    }\n    const attribute = video.getAttribute(\"src\");\n    if (attribute && attribute.length > 0) {\n      return attribute;\n    }\n    const sourceElement = video.querySelector(\"source[src]\") as HTMLSourceElement | null;\n    if (sourceElement && typeof sourceElement.src === \"string\") {\n      return sourceElement.src;\n    }\n    return null;\n  }\n\n  getCommentsSnapshot(): Comment[] {\n    return [...this.comments];\n  }\n\n  isNGComment(text: string): boolean {\n    try {\n      if (typeof text !== \"string\") {\n        return true;\n      }\n\n      if (Array.isArray(this._settings.ngWords)) {\n        const containsNgWord = this._settings.ngWords.some(\n          (word) => typeof word === \"string\" && word.length > 0 && text.includes(word),\n        );\n        if (containsNgWord) {\n          return true;\n        }\n      }\n\n      if (Array.isArray(this._settings.ngRegexps)) {\n        return this._settings.ngRegexps.some((pattern) => {\n          if (typeof pattern !== \"string\" || pattern.length === 0) {\n            return false;\n          }\n          try {\n            return new RegExp(pattern).test(text);\n          } catch (regexError) {\n            this.log.error(\"CommentRenderer.isNGComment.regex\", regexError as Error, {\n              pattern,\n              text,\n            });\n            return false;\n          }\n        });\n      }\n\n      return false;\n    } catch (error) {\n      this.log.error(\"CommentRenderer.isNGComment\", error as Error, { text });\n      return true;\n    }\n  }\n\n  resize(width?: number, height?: number): void {\n    const video = this.videoElement;\n    const canvas = this.canvas;\n    if (!video || !canvas) {\n      return;\n    }\n\n    const rect = video.getBoundingClientRect();\n    const measuredWidth = width ?? rect.width ?? canvas.width;\n    const measuredHeight = height ?? rect.height ?? canvas.height;\n\n    if (\n      !Number.isFinite(measuredWidth) ||\n      !Number.isFinite(measuredHeight) ||\n      measuredWidth <= 0 ||\n      measuredHeight <= 0\n    ) {\n      return;\n    }\n\n    const nextWidth = Math.max(1, Math.floor(measuredWidth));\n    const nextHeight = Math.max(1, Math.floor(measuredHeight));\n\n    if (!Number.isFinite(nextWidth) || !Number.isFinite(nextHeight)) {\n      return;\n    }\n\n    const previousWidth = canvas.width || nextWidth;\n    const previousHeight = canvas.height || nextHeight;\n\n    if (previousWidth === nextWidth && previousHeight === nextHeight) {\n      return;\n    }\n\n    canvas.width = nextWidth;\n    canvas.height = nextHeight;\n    canvas.style.width = `${nextWidth}px`;\n    canvas.style.height = `${nextHeight}px`;\n\n    const scaleX = previousWidth > 0 ? nextWidth / previousWidth : 1;\n    const scaleY = previousHeight > 0 ? nextHeight / previousHeight : 1;\n\n    if (scaleX !== 1 || scaleY !== 1) {\n      this.comments.forEach((comment) => {\n        if (comment.isActive) {\n          comment.x *= scaleX;\n          comment.y *= scaleY;\n          comment.baseSpeed *= scaleX;\n          comment.speed *= scaleX;\n          comment.fontSize = Math.max(MIN_FONT_SIZE_PX, Math.floor(nextHeight * 0.05));\n        }\n      });\n    }\n\n    this.calculateLaneMetrics();\n  }\n\n  private destroyCanvasOnly(): void {\n    this.stopAnimation();\n    this.cleanupResizeHandling();\n    this.runCleanupTasks();\n    if (this.canvas) {\n      this.canvas.remove();\n    }\n    this.canvas = null;\n    this.ctx = null;\n  }\n\n  private calculateLaneMetrics(): void {\n    const canvas = this.canvas;\n    if (!canvas) {\n      return;\n    }\n\n    const baseHeight = Math.max(MIN_FONT_SIZE_PX, Math.floor(canvas.height * 0.05));\n    this.laneHeight = baseHeight * 1.2;\n    const availableLanes = Math.floor(canvas.height / Math.max(this.laneHeight, 1));\n    this.laneCount = Math.max(MIN_LANE_COUNT, availableLanes);\n    this.topStaticLaneReservations.clear();\n    this.bottomStaticLaneReservations.clear();\n  }\n\n  private updateComments(): void {\n    const video = this.videoElement;\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (!video || !canvas || !context) {\n      return;\n    }\n\n    this.currentTime = toMilliseconds(video.currentTime);\n    this.playbackRate = video.playbackRate;\n    this.isPlaying = !video.paused;\n    const prepareOptions = this.buildPrepareOptions(canvas.width);\n\n    const isNearEnd =\n      this.duration > 0 && this.duration - this.currentTime <= FINAL_PHASE_THRESHOLD_MS;\n\n    if (isNearEnd && !this.finalPhaseActive) {\n      this.finalPhaseActive = true;\n      context.clearRect(0, 0, canvas.width, canvas.height);\n      this.comments.forEach((comment) => {\n        comment.isActive = false;\n        comment.clearActivation();\n      });\n      this.reservedLanes.clear();\n      this.topStaticLaneReservations.clear();\n      this.bottomStaticLaneReservations.clear();\n    }\n\n    if (!isNearEnd && this.finalPhaseActive) {\n      this.finalPhaseActive = false;\n    }\n\n    this.pruneStaticLaneReservations(this.currentTime);\n\n    for (const comment of this.comments) {\n      if (this.isNGComment(comment.text)) {\n        continue;\n      }\n      if (comment.isInvisible) {\n        comment.isActive = false;\n        comment.hasShown = true;\n        comment.clearActivation();\n        continue;\n      }\n\n      comment.syncWithSettings(this._settings);\n\n      if (this.shouldActivateCommentAtTime(comment, this.currentTime)) {\n        this.activateComment(\n          comment,\n          context,\n          canvas.width,\n          canvas.height,\n          prepareOptions,\n          this.currentTime,\n        );\n      }\n\n      if (comment.isActive) {\n        if (comment.layout !== \"naka\" && comment.hasStaticExpired(this.currentTime)) {\n          const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n          this.releaseStaticLane(staticPosition, comment.lane);\n          comment.isActive = false;\n          comment.clearActivation();\n          continue;\n        }\n\n        if (\n          comment.layout === \"naka\" &&\n          comment.vpos > this.currentTime + SEEK_DIRECTION_EPSILON_MS\n        ) {\n          comment.x = comment.virtualStartX;\n          comment.lastUpdateTime = this.timeSource.now();\n          continue;\n        }\n\n        comment.hasShown = true;\n        comment.update(this.playbackRate, !this.isPlaying);\n        if (!comment.isScrolling && comment.hasStaticExpired(this.currentTime)) {\n          const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n          this.releaseStaticLane(staticPosition, comment.lane);\n          comment.isActive = false;\n          comment.clearActivation();\n        }\n      }\n    }\n\n    for (const comment of this.comments) {\n      if (comment.isActive && comment.isScrolling && comment.x < -comment.width) {\n        comment.isActive = false;\n        comment.clearActivation();\n      }\n    }\n  }\n\n  private buildPrepareOptions(visibleWidth: number): CommentPrepareOptions {\n    return {\n      visibleWidth,\n      virtualExtension: VIRTUAL_CANVAS_EXTENSION_PX,\n      maxVisibleDurationMs: MAX_VISIBLE_DURATION_MS,\n      minVisibleDurationMs: MIN_VISIBLE_DURATION_MS,\n      maxWidthRatio: MAX_COMMENT_WIDTH_RATIO,\n      bufferRatio: COLLISION_BUFFER_RATIO,\n      baseBufferPx: BASE_COLLISION_BUFFER_PX,\n      entryBufferPx: ENTRY_BUFFER_PX,\n    };\n  }\n\n  private findAvailableLane(comment: Comment): number {\n    const currentTime = this.currentTime;\n    this.pruneLaneReservations(currentTime);\n    this.pruneStaticLaneReservations(currentTime);\n    const laneCandidates = this.getLanePriorityOrder(currentTime);\n    const newReservation = this.createLaneReservation(comment, currentTime);\n\n    for (const lane of laneCandidates) {\n      if (this.isLaneAvailable(lane, newReservation, currentTime)) {\n        this.storeLaneReservation(lane, newReservation);\n        return lane;\n      }\n    }\n\n    const fallbackLane = laneCandidates[0] ?? 0;\n    this.storeLaneReservation(fallbackLane, newReservation);\n    return fallbackLane;\n  }\n\n  private pruneLaneReservations(currentTime: number): void {\n    for (const [lane, reservations] of this.reservedLanes.entries()) {\n      const filtered = reservations.filter(\n        (reservation) => reservation.totalEndTime + RESERVATION_TIME_MARGIN_MS > currentTime,\n      );\n      if (filtered.length > 0) {\n        this.reservedLanes.set(lane, filtered);\n      } else {\n        this.reservedLanes.delete(lane);\n      }\n    }\n  }\n\n  private pruneStaticLaneReservations(currentTime: number): void {\n    for (const [lane, releaseTime] of this.topStaticLaneReservations.entries()) {\n      if (releaseTime <= currentTime) {\n        this.topStaticLaneReservations.delete(lane);\n      }\n    }\n    for (const [lane, releaseTime] of this.bottomStaticLaneReservations.entries()) {\n      if (releaseTime <= currentTime) {\n        this.bottomStaticLaneReservations.delete(lane);\n      }\n    }\n  }\n\n  private getStaticLaneMap(position: \"ue\" | \"shita\"): Map<number, number> {\n    return position === \"ue\" ? this.topStaticLaneReservations : this.bottomStaticLaneReservations;\n  }\n\n  private getStaticReservedLaneSet(): Set<number> {\n    const reserved = new Set<number>();\n    for (const lane of this.topStaticLaneReservations.keys()) {\n      reserved.add(lane);\n    }\n    for (const lane of this.bottomStaticLaneReservations.keys()) {\n      reserved.add(lane);\n    }\n    return reserved;\n  }\n\n  private shouldActivateCommentAtTime(comment: Comment, timeMs: number): boolean {\n    if (comment.isInvisible || comment.isActive) {\n      return false;\n    }\n    if (comment.vpos > timeMs + SEEK_DIRECTION_EPSILON_MS) {\n      return false;\n    }\n    if (comment.vpos < timeMs - ACTIVE_WINDOW_MS) {\n      return false;\n    }\n    return true;\n  }\n\n  private activateComment(\n    comment: Comment,\n    context: CanvasRenderingContext2D,\n    canvasWidth: number,\n    canvasHeight: number,\n    options: CommentPrepareOptions,\n    referenceTime: number,\n  ): void {\n    comment.prepare(context, canvasWidth, canvasHeight, options);\n\n    if (comment.layout === \"naka\") {\n      const elapsedMs = Math.max(0, referenceTime - comment.vpos);\n      const displacement = comment.speedPixelsPerMs * elapsedMs;\n      const projectedX = comment.virtualStartX - displacement;\n\n      if (projectedX <= -comment.width) {\n        comment.isActive = false;\n        comment.hasShown = true;\n        comment.clearActivation();\n        comment.lane = -1;\n        return;\n      }\n\n      comment.lane = this.findAvailableLane(comment);\n      comment.y = comment.lane * this.laneHeight;\n      comment.x = projectedX;\n      comment.isActive = true;\n      comment.hasShown = true;\n      comment.isPaused = !this.isPlaying;\n      comment.markActivated(referenceTime);\n      comment.lastUpdateTime = this.timeSource.now();\n      return;\n    }\n\n    const displayEnd = comment.vpos + STATIC_VISIBLE_DURATION_MS;\n    if (referenceTime > displayEnd) {\n      comment.isActive = false;\n      comment.hasShown = true;\n      comment.clearActivation();\n      comment.lane = -1;\n      return;\n    }\n\n    const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n    const laneIndex = this.assignStaticLane(staticPosition);\n    comment.lane = laneIndex;\n    comment.y = laneIndex * this.laneHeight;\n    comment.x = comment.virtualStartX;\n    comment.isActive = true;\n    comment.hasShown = true;\n    comment.isPaused = !this.isPlaying;\n    comment.markActivated(referenceTime);\n    comment.lastUpdateTime = this.timeSource.now();\n    comment.staticExpiryTimeMs = displayEnd;\n    this.reserveStaticLane(staticPosition, laneIndex, displayEnd);\n  }\n\n  private assignStaticLane(position: \"ue\" | \"shita\"): number {\n    const laneMap = this.getStaticLaneMap(position);\n    const laneIndices = Array.from({ length: this.laneCount }, (_, index) => index);\n    if (position === \"shita\") {\n      laneIndices.reverse();\n    }\n    for (const lane of laneIndices) {\n      if (!laneMap.has(lane)) {\n        return lane;\n      }\n    }\n    let fallbackLane = laneIndices[0] ?? 0;\n    let earliestRelease = Number.POSITIVE_INFINITY;\n    for (const [lane, releaseTime] of laneMap.entries()) {\n      if (releaseTime < earliestRelease) {\n        earliestRelease = releaseTime;\n        fallbackLane = lane;\n      }\n    }\n    return fallbackLane;\n  }\n\n  private reserveStaticLane(position: \"ue\" | \"shita\", lane: number, releaseTime: number): void {\n    const laneMap = this.getStaticLaneMap(position);\n    laneMap.set(lane, releaseTime);\n  }\n\n  private releaseStaticLane(position: \"ue\" | \"shita\", lane: number): void {\n    if (lane < 0) {\n      return;\n    }\n    const laneMap = this.getStaticLaneMap(position);\n    laneMap.delete(lane);\n  }\n\n  private getLanePriorityOrder(currentTime: number): number[] {\n    const indices = Array.from({ length: this.laneCount }, (_, index) => index);\n    const sorted = indices.sort((a, b) => {\n      const nextA = this.getLaneNextAvailableTime(a, currentTime);\n      const nextB = this.getLaneNextAvailableTime(b, currentTime);\n      if (Math.abs(nextA - nextB) <= EDGE_EPSILON) {\n        return a - b;\n      }\n      return nextA - nextB;\n    });\n    const staticReserved = this.getStaticReservedLaneSet();\n    if (staticReserved.size === 0) {\n      return sorted;\n    }\n    const preferred = sorted.filter((lane) => !staticReserved.has(lane));\n    if (preferred.length === 0) {\n      return sorted;\n    }\n    const blocked = sorted.filter((lane) => staticReserved.has(lane));\n    return [...preferred, ...blocked];\n  }\n\n  private getLaneNextAvailableTime(lane: number, currentTime: number): number {\n    const reservations = this.reservedLanes.get(lane);\n    if (!reservations || reservations.length === 0) {\n      return currentTime;\n    }\n    let nextTime = currentTime;\n    for (const reservation of reservations) {\n      nextTime = Math.max(nextTime, reservation.endTime);\n    }\n    return nextTime;\n  }\n\n  private createLaneReservation(comment: Comment, startTime: number): LaneReservation {\n    const speed = Math.max(comment.speedPixelsPerMs, EDGE_EPSILON);\n    const endTime = startTime + comment.preCollisionDurationMs + RESERVATION_TIME_MARGIN_MS;\n    const totalEndTime = startTime + comment.totalDurationMs + RESERVATION_TIME_MARGIN_MS;\n    return {\n      comment,\n      startTime,\n      endTime: Math.max(startTime, endTime),\n      totalEndTime: Math.max(startTime, totalEndTime),\n      startLeft: comment.virtualStartX,\n      width: comment.width,\n      speed,\n      buffer: comment.bufferWidth,\n    };\n  }\n\n  private isLaneAvailable(lane: number, candidate: LaneReservation, currentTime: number): boolean {\n    const reservations = this.reservedLanes.get(lane);\n    if (!reservations || reservations.length === 0) {\n      return true;\n    }\n    for (const reservation of reservations) {\n      if (reservation.totalEndTime + RESERVATION_TIME_MARGIN_MS <= currentTime) {\n        continue;\n      }\n      if (this.areReservationsConflicting(reservation, candidate)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private storeLaneReservation(lane: number, reservation: LaneReservation): void {\n    const existing = this.reservedLanes.get(lane) ?? [];\n    const updated = [...existing, reservation].sort((a, b) => a.endTime - b.endTime);\n    this.reservedLanes.set(lane, updated);\n  }\n\n  private areReservationsConflicting(a: LaneReservation, b: LaneReservation): boolean {\n    const overlapStart = Math.max(a.startTime, b.startTime);\n    const overlapEnd = Math.min(a.endTime, b.endTime);\n    if (overlapStart >= overlapEnd) {\n      return false;\n    }\n\n    const evaluationTimes = new Set<number>([\n      overlapStart,\n      overlapEnd,\n      overlapStart + (overlapEnd - overlapStart) / 2,\n    ]);\n\n    const forwardIntersection = this.solveLeftRightEqualityTime(a, b);\n    if (\n      forwardIntersection !== null &&\n      forwardIntersection >= overlapStart - EDGE_EPSILON &&\n      forwardIntersection <= overlapEnd + EDGE_EPSILON\n    ) {\n      evaluationTimes.add(forwardIntersection);\n    }\n\n    const backwardIntersection = this.solveLeftRightEqualityTime(b, a);\n    if (\n      backwardIntersection !== null &&\n      backwardIntersection >= overlapStart - EDGE_EPSILON &&\n      backwardIntersection <= overlapEnd + EDGE_EPSILON\n    ) {\n      evaluationTimes.add(backwardIntersection);\n    }\n\n    for (const time of evaluationTimes) {\n      if (time < overlapStart - EDGE_EPSILON || time > overlapEnd + EDGE_EPSILON) {\n        continue;\n      }\n      const forwardGap = this.computeForwardGap(a, b, time);\n      const backwardGap = this.computeForwardGap(b, a, time);\n      if (forwardGap <= EDGE_EPSILON && backwardGap <= EDGE_EPSILON) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private computeForwardGap(from: LaneReservation, to: LaneReservation, time: number): number {\n    const fromEdges = this.getBufferedEdges(from, time);\n    const toEdges = this.getBufferedEdges(to, time);\n    return fromEdges.left - toEdges.right;\n  }\n\n  private getBufferedEdges(\n    reservation: LaneReservation,\n    time: number,\n  ): { left: number; right: number } {\n    const elapsed = Math.max(0, time - reservation.startTime);\n    const displacement = reservation.speed * elapsed;\n    const rawLeft = reservation.startLeft - displacement;\n    const left = rawLeft - reservation.buffer;\n    const right = rawLeft + reservation.width + reservation.buffer;\n    return { left, right };\n  }\n\n  private solveLeftRightEqualityTime(left: LaneReservation, right: LaneReservation): number | null {\n    const denominator = right.speed - left.speed;\n    if (Math.abs(denominator) < EDGE_EPSILON) {\n      return null;\n    }\n    const numerator =\n      right.startLeft +\n      right.speed * right.startTime +\n      right.width +\n      right.buffer -\n      left.startLeft -\n      left.speed * left.startTime +\n      left.buffer;\n    const time = numerator / denominator;\n    if (!Number.isFinite(time)) {\n      return null;\n    }\n    return time;\n  }\n\n  private draw(): void {\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (!canvas || !context) {\n      return;\n    }\n\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    const activeComments = this.comments.filter((comment) => comment.isActive);\n    const now = this.timeSource.now();\n\n    if (this._settings.isCommentVisible) {\n      const deltaTime = (now - this.lastDrawTime) / (1000 / 60);\n      activeComments.forEach((comment) => {\n        const interpolatedX = comment.x - comment.speed * deltaTime;\n        comment.draw(context, interpolatedX);\n      });\n    }\n\n    this.lastDrawTime = now;\n  }\n\n  private readonly updateFrame = (): void => {\n    if (!this.videoElement) {\n      return;\n    }\n    if (!this._settings.isCommentVisible) {\n      this.frameId = this.animationFrameProvider.request(this.updateFrame);\n      return;\n    }\n    this.updateComments();\n    this.draw();\n    this.frameId = this.animationFrameProvider.request(this.updateFrame);\n  };\n\n  private startAnimation(): void {\n    this.stopAnimation();\n    this.frameId = this.animationFrameProvider.request(this.updateFrame);\n  }\n\n  private stopAnimation(): void {\n    if (this.frameId !== null) {\n      this.animationFrameProvider.cancel(this.frameId);\n      this.frameId = null;\n    }\n  }\n\n  private onSeek(): void {\n    const canvas = this.canvas;\n    const context = this.ctx;\n    const video = this.videoElement;\n    if (!canvas || !context || !video) {\n      return;\n    }\n\n    const nextTime = toMilliseconds(video.currentTime);\n\n    this.finalPhaseActive = false;\n    this.currentTime = nextTime;\n\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.clear();\n    this.bottomStaticLaneReservations.clear();\n    const prepareOptions = this.buildPrepareOptions(canvas.width);\n\n    this.comments.forEach((comment) => {\n      if (this.isNGComment(comment.text)) {\n        comment.isActive = false;\n        comment.clearActivation();\n        return;\n      }\n\n      if (comment.isInvisible) {\n        comment.isActive = false;\n        comment.hasShown = true;\n        comment.clearActivation();\n        return;\n      }\n\n      comment.syncWithSettings(this._settings);\n      comment.isActive = false;\n      comment.lane = -1;\n      comment.clearActivation();\n\n      if (this.shouldActivateCommentAtTime(comment, this.currentTime)) {\n        this.activateComment(\n          comment,\n          context,\n          canvas.width,\n          canvas.height,\n          prepareOptions,\n          this.currentTime,\n        );\n        return;\n      }\n\n      if (comment.vpos < this.currentTime - ACTIVE_WINDOW_MS) {\n        comment.hasShown = true;\n      } else {\n        comment.hasShown = false;\n      }\n    });\n  }\n\n  private setupVideoEventListeners(videoElement: HTMLVideoElement): void {\n    try {\n      const onPlay = (): void => {\n        this.isPlaying = true;\n        const now = this.timeSource.now();\n        this.lastDrawTime = now;\n        this.comments.forEach((comment) => {\n          comment.lastUpdateTime = now;\n          comment.isPaused = false;\n        });\n      };\n      const onPause = (): void => {\n        this.isPlaying = false;\n        const now = this.timeSource.now();\n        this.comments.forEach((comment) => {\n          comment.lastUpdateTime = now;\n          comment.isPaused = true;\n        });\n      };\n      const onSeeking = (): void => {\n        this.onSeek();\n      };\n      const onSeeked = (): void => {\n        this.onSeek();\n      };\n      const onRateChange = (): void => {\n        this.playbackRate = videoElement.playbackRate;\n        const now = this.timeSource.now();\n        this.comments.forEach((comment) => {\n          comment.lastUpdateTime = now;\n        });\n      };\n      const onLoadedMetadata = (): void => {\n        this.handleVideoMetadataLoaded(videoElement);\n      };\n      const onDurationChange = (): void => {\n        this.duration = Number.isFinite(videoElement.duration)\n          ? toMilliseconds(videoElement.duration)\n          : 0;\n      };\n      const onEmptied = (): void => {\n        this.handleVideoSourceChange();\n      };\n\n      videoElement.addEventListener(\"play\", onPlay);\n      videoElement.addEventListener(\"pause\", onPause);\n      videoElement.addEventListener(\"seeking\", onSeeking);\n      videoElement.addEventListener(\"seeked\", onSeeked);\n      videoElement.addEventListener(\"ratechange\", onRateChange);\n      videoElement.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n      videoElement.addEventListener(\"durationchange\", onDurationChange);\n      videoElement.addEventListener(\"emptied\", onEmptied);\n\n      this.addCleanup(() => videoElement.removeEventListener(\"play\", onPlay));\n      this.addCleanup(() => videoElement.removeEventListener(\"pause\", onPause));\n      this.addCleanup(() => videoElement.removeEventListener(\"seeking\", onSeeking));\n      this.addCleanup(() => videoElement.removeEventListener(\"seeked\", onSeeked));\n      this.addCleanup(() => videoElement.removeEventListener(\"ratechange\", onRateChange));\n      this.addCleanup(() => videoElement.removeEventListener(\"loadedmetadata\", onLoadedMetadata));\n      this.addCleanup(() => videoElement.removeEventListener(\"durationchange\", onDurationChange));\n      this.addCleanup(() => videoElement.removeEventListener(\"emptied\", onEmptied));\n    } catch (error) {\n      this.log.error(\"CommentRenderer.setupVideoEventListeners\", error as Error);\n      throw error;\n    }\n  }\n\n  private handleVideoMetadataLoaded(videoElement: HTMLVideoElement): void {\n    this.handleVideoSourceChange(videoElement);\n    this.resize();\n    this.calculateLaneMetrics();\n    this.onSeek();\n  }\n\n  private handleVideoSourceChange(videoElement?: HTMLVideoElement | null): void {\n    const target = videoElement ?? this.videoElement;\n    if (!target) {\n      this.isPlaying = false;\n      this.finalPhaseActive = false;\n      this.resetCommentActivity();\n      return;\n    }\n    this.syncVideoState(target);\n    this.finalPhaseActive = false;\n    this.resetCommentActivity();\n  }\n\n  private syncVideoState(videoElement: HTMLVideoElement): void {\n    this.duration = Number.isFinite(videoElement.duration)\n      ? toMilliseconds(videoElement.duration)\n      : 0;\n    this.currentTime = toMilliseconds(videoElement.currentTime);\n    this.playbackRate = videoElement.playbackRate;\n    this.isPlaying = !videoElement.paused;\n    this.lastDrawTime = this.timeSource.now();\n  }\n\n  private resetCommentActivity(): void {\n    const now = this.timeSource.now();\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (canvas && context) {\n      context.clearRect(0, 0, canvas.width, canvas.height);\n    }\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.clear();\n    this.bottomStaticLaneReservations.clear();\n    this.comments.forEach((comment) => {\n      comment.isActive = false;\n      comment.isPaused = !this.isPlaying;\n      comment.hasShown = false;\n      comment.lane = -1;\n      comment.x = comment.virtualStartX;\n      comment.speed = comment.baseSpeed;\n      comment.lastUpdateTime = now;\n      comment.clearActivation();\n    });\n  }\n\n  private setupVideoChangeDetection(videoElement: HTMLVideoElement, container: HTMLElement): void {\n    if (typeof MutationObserver === \"undefined\") {\n      this.log.debug(\n        \"MutationObserver is not available in this environment. Video change detection is disabled.\",\n      );\n      return;\n    }\n\n    const videoObserver = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === \"attributes\" && mutation.attributeName === \"src\") {\n          const targetNode = mutation.target;\n          let previous: string | null = null;\n          let current: string | null = null;\n          if (targetNode instanceof HTMLVideoElement || targetNode instanceof HTMLSourceElement) {\n            previous = typeof mutation.oldValue === \"string\" ? mutation.oldValue : null;\n            current = targetNode.getAttribute(\"src\");\n          }\n          if (previous === current) {\n            continue;\n          }\n          this.handleVideoSourceChange(videoElement);\n          return;\n        }\n        if (mutation.type === \"childList\") {\n          for (const node of mutation.addedNodes) {\n            if (node instanceof HTMLSourceElement) {\n              this.handleVideoSourceChange(videoElement);\n              return;\n            }\n          }\n          for (const node of mutation.removedNodes) {\n            if (node instanceof HTMLSourceElement) {\n              this.handleVideoSourceChange(videoElement);\n              return;\n            }\n          }\n        }\n      }\n    });\n\n    videoObserver.observe(videoElement, {\n      attributes: true,\n      attributeFilter: [\"src\"],\n      attributeOldValue: true,\n      childList: true,\n      subtree: true,\n    });\n    this.addCleanup(() => videoObserver.disconnect());\n\n    const containerObserver = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type !== \"childList\") {\n          continue;\n        }\n        for (const node of mutation.addedNodes) {\n          const nextVideo = this.extractVideoElement(node);\n          if (nextVideo && nextVideo !== this.videoElement) {\n            this.initialize(nextVideo);\n            return;\n          }\n        }\n        for (const node of mutation.removedNodes) {\n          if (node === this.videoElement) {\n            this.videoElement = null;\n            this.handleVideoSourceChange(null);\n            return;\n          }\n          if (node instanceof Element) {\n            const removedVideo = node.querySelector(\"video\");\n            if (removedVideo && removedVideo === this.videoElement) {\n              this.videoElement = null;\n              this.handleVideoSourceChange(null);\n              return;\n            }\n          }\n        }\n      }\n    });\n\n    containerObserver.observe(container, { childList: true, subtree: true });\n    this.addCleanup(() => containerObserver.disconnect());\n  }\n\n  private extractVideoElement(node: Node): HTMLVideoElement | null {\n    if (node instanceof HTMLVideoElement) {\n      return node;\n    }\n    if (node instanceof Element) {\n      const candidate = node.querySelector(\"video\");\n      if (candidate instanceof HTMLVideoElement) {\n        return candidate;\n      }\n    }\n    return null;\n  }\n\n  private setupResizeHandling(videoElement: HTMLVideoElement): void {\n    this.cleanupResizeHandling();\n\n    if (this._settings.useContainerResizeObserver && this.isResizeObserverAvailable) {\n      const target = videoElement.parentElement ?? videoElement;\n      const observer = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          const { width, height } = entry.contentRect;\n          if (width > 0 && height > 0) {\n            this.resize(width, height);\n          } else {\n            this.resize();\n          }\n        }\n      });\n      observer.observe(target);\n      this.resizeObserver = observer;\n      this.resizeObserverTarget = target;\n    } else if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\") {\n      const onResize = (): void => {\n        this.resize();\n      };\n      window.addEventListener(\"resize\", onResize);\n      this.addCleanup(() => window.removeEventListener(\"resize\", onResize));\n    } else {\n      this.log.debug(\n        \"Resize handling is disabled because neither ResizeObserver nor window APIs are available.\",\n      );\n    }\n  }\n\n  private cleanupResizeHandling(): void {\n    if (this.resizeObserver && this.resizeObserverTarget) {\n      this.resizeObserver.unobserve(this.resizeObserverTarget);\n    }\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n    this.resizeObserverTarget = null;\n  }\n\n  private addCleanup(task: () => void): void {\n    this.cleanupTasks.push(task);\n  }\n\n  private runCleanupTasks(): void {\n    while (this.cleanupTasks.length > 0) {\n      const task = this.cleanupTasks.pop();\n      try {\n        task?.();\n      } catch (error) {\n        this.log.error(\"CommentRenderer.cleanupTask\", error as Error);\n      }\n    }\n  }\n}\n"],"names":["LEVEL_PRIORITY","fallbackEmitter","level","namespace","args","consoleArgs","createLogger","options","emitter","threshold","emit","logLevel","messages","COMMENT_SIZE_SCALE","FONT_FAMILY_MAP","COLOR_COMMAND_MAP","HEX_COLOR_REGEX","COMMAND_PREFIX_STRIP_REGEX","COMMAND_SUFFIX_STRIP_REGEX","normalizeCommandToken","value","trimmed","normalizeHexColor","command","isLayoutCommand","isSizeCommand","isFontCommand","isColorCommand","parseCommentCommands","commands","context","layout","size","font","colorOverride","opacityMultiplier","opacityOverride","isInvisible","rawCommand","normalizedToken","normalized","lower","clampedOpacityMultiplier","resolvedColor","resolvedOpacityOverride","logger","STATIC_VISIBLE_DURATION_MS","createPerformanceTimeSource","createDefaultTimeSource","Comment","text","vpos","settings","dependencies","parsedCommands","ctx","visibleWidth","canvasHeight","safeVisibleWidth","baseFontSize","scaledFontSize","centeredX","maxReservationWidth","bufferFromWidth","entryBuffer","widthRatio","visibleDurationMs","clampedRatio","adjustedDuration","visibleDistance","safeVisibleDuration","pixelsPerMs","pixelsPerFrame","travelDistance","preCollisionBoundary","startRight","safePixelsPerMs","preCollisionDistance","reservationBase","error","playbackRate","isPaused","currentTime","deltaTime","interpolatedX","drawX","drawY","baseShadowOffset","baseShadowBlur","layer","effectiveShadowAlpha","defaultColor","candidate","defaultOpacity","scaled","atTimeMs","currentTimeMs","BASE_SETTINGS","DEFAULT_RENDERER_SETTINGS","cloneDefaultSettings","RENDERER_VERSION","toMilliseconds","seconds","FINAL_PHASE_THRESHOLD_MS","ACTIVE_WINDOW_MS","VIRTUAL_CANVAS_EXTENSION_PX","MAX_VISIBLE_DURATION_MS","MIN_VISIBLE_DURATION_MS","MAX_COMMENT_WIDTH_RATIO","COLLISION_BUFFER_RATIO","BASE_COLLISION_BUFFER_PX","ENTRY_BUFFER_PX","RESERVATION_TIME_MARGIN_MS","MIN_LANE_COUNT","DEFAULT_LANE_COUNT","MIN_FONT_SIZE_PX","EDGE_EPSILON","SEEK_DIRECTION_EPSILON_MS","createDefaultAnimationFrameProvider","timeSource","callback","handle","createBrowserCanvasFactory","isRendererSettings","input","CommentRenderer","settingsOrConfig","maybeConfig","baseSettings","config","configCandidate","explicit","video","container","containerCandidate","canvas","parent","comment","a","b","newSettings","previousUseContainer","attribute","sourceElement","word","pattern","regexError","width","height","rect","measuredWidth","measuredHeight","nextWidth","nextHeight","previousWidth","previousHeight","scaleX","scaleY","baseHeight","availableLanes","prepareOptions","isNearEnd","staticPosition","laneCandidates","newReservation","lane","fallbackLane","reservations","filtered","reservation","releaseTime","position","reserved","timeMs","canvasWidth","referenceTime","elapsedMs","displacement","projectedX","displayEnd","laneIndex","laneMap","laneIndices","_","index","earliestRelease","sorted","nextA","nextB","staticReserved","preferred","blocked","nextTime","startTime","speed","endTime","totalEndTime","updated","overlapStart","overlapEnd","evaluationTimes","forwardIntersection","backwardIntersection","time","forwardGap","backwardGap","from","to","fromEdges","toEdges","elapsed","rawLeft","left","right","denominator","activeComments","now","videoElement","onPlay","onPause","onSeeking","onSeeked","onRateChange","onLoadedMetadata","onDurationChange","onEmptied","target","videoObserver","mutations","mutation","targetNode","previous","current","node","containerObserver","nextVideo","removedVideo","observer","entries","entry","onResize","task"],"mappings":"AAcA,MAAMA,IAA2C;AAAA,EAC/C,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AACT,GAEMC,IAAkB,CAACC,GAAiBC,GAAmBC,MAA0B;AAErF,QAAMC,IAAyB,CADhB,IAAIF,CAAS,KACY,GAAGC,CAAI;AAC/C,UAAQF,GAAA;AAAA,IACN,KAAK;AACH,cAAQ,MAAM,GAAGG,CAAW;AAC5B;AAAA,IACF,KAAK;AACH,cAAQ,KAAK,GAAGA,CAAW;AAC3B;AAAA,IACF,KAAK;AACH,cAAQ,KAAK,GAAGA,CAAW;AAC3B;AAAA,IACF,KAAK;AACH,cAAQ,MAAM,GAAGA,CAAW;AAC5B;AAAA,IACF;AACE,cAAQ,IAAI,GAAGA,CAAW;AAAA,EAAA;AAEhC,GAEaC,IAAe,CAACH,GAAmBI,IAAyB,OAAe;AACtF,QAAM,EAAE,OAAAL,IAAQ,QAAQ,SAAAM,IAAUP,MAAoBM,GAChDE,IAAYT,EAAeE,CAAK,GAEhCQ,IAAO,CAACC,GAAoBP,MAA0B;AAC1D,IAAIJ,EAAeW,CAAQ,IAAIF,KAG/BD,EAAQG,GAAUR,GAAWC,CAAI;AAAA,EACnC;AAEA,SAAO;AAAA,IACL,OAAO,IAAIQ,MAAwBF,EAAK,SAASE,CAAQ;AAAA,IACzD,MAAM,IAAIA,MAAwBF,EAAK,QAAQE,CAAQ;AAAA,IACvD,MAAM,IAAIA,MAAwBF,EAAK,QAAQE,CAAQ;AAAA,IACvD,OAAO,IAAIA,MAAwBF,EAAK,SAASE,CAAQ;AAAA,EAAA;AAE7D,GCjDMC,IAAyD;AAAA,EAC7D,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,KAAK;AACP,GAEMC,IAAsD;AAAA,EAC1D,QACE;AAAA,EACF,QACE;AAAA,EACF,QACE;AACJ,GAEMC,IAAyD;AAAA,EAC7D,OAAO;AAAA,EACP,KAAK;AAAA,EACL,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,SAAS;AAAA,EACT,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,OAAO;AAAA,EACP,SAAS;AAAA,EACT,QAAQ;AACV,GAEMC,IAAkB,yDAElBC,IAA6B,YAC7BC,IAA6B,YAE7BC,IAAwB,CAACC,MAA0B;AACvD,QAAMC,IAAUD,EAAM,KAAA;AACtB,SAAKC,IAGDL,EAAgB,KAAKK,CAAO,IACvBA,IAEaA,EAAQ,QAAQJ,GAA4B,EAAE,EAChC,QAAQC,GAA4B,EAAE,IANjE;AAQX,GAEMI,IAAoB,CAACC,MACpBP,EAAgB,KAAKO,CAAO,IAG1BA,EAAQ,YAAA,IAFN,MAKLC,IAAkB,CAACD,MACvBA,MAAY,UAAUA,MAAY,QAAQA,MAAY,SAElDE,IAAgB,CAACF,MACrBA,MAAY,WAAWA,MAAY,YAAYA,MAAY,OAEvDG,IAAgB,CAACH,MACrBA,MAAY,YAAYA,MAAY,YAAYA,MAAY,UAExDI,IAAiB,CAACJ,MACtBA,KAAWR,GAEAa,IAAuB,CAClCC,GACAC,MAC8B;AAC9B,MAAIC,IAA+B,QAC/BC,IAA2B,UAC3BC,IAA2B,UAC3BC,IAA+B,MAC/BC,IAAoB,GACpBC,IAAiC,MACjCC,IAAc;AAElB,aAAWC,KAAcT,GAAU;AACjC,UAAMU,IAAkBpB,EAAsB,OAAOmB,KAAe,WAAWA,IAAa,EAAE;AAC9F,QAAI,CAACC;AACH;AAGF,QAAIvB,EAAgB,KAAKuB,CAAe,GAAG;AACzC,YAAMC,IAAalB,EAAkBiB,CAAyC;AAC9E,UAAIC,GAAY;AACd,QAAAN,IAAgBM;AAChB;AAAA,MACF;AAAA,IACF;AAEA,UAAMC,IAAQF,EAAgB,YAAA;AAE9B,QAAIf,EAAgBiB,CAAK,GAAG;AAC1B,MAAAV,IAASU;AACT;AAAA,IACF;AAEA,QAAIhB,EAAcgB,CAAK,GAAG;AACxB,MAAAT,IAAOS;AACP;AAAA,IACF;AAEA,QAAIf,EAAce,CAAK,GAAG;AACxB,MAAAR,IAAOQ;AACP;AAAA,IACF;AAEA,QAAId,EAAec,CAAK,GAAG;AACzB,MAAAP,IAAgBnB,EAAkB0B,CAAK,EAAE,YAAA;AACzC;AAAA,IACF;AAEA,QAAIA,MAAU,SAAS;AACrB,MAAAL,IAAkB;AAClB;AAAA,IACF;AAEA,IAAIK,MAAU,gBACZN,IAAoB,GACpBE,IAAc;AAAA,EAElB;AAEA,QAAMK,IAA2B,KAAK,IAAI,GAAG,KAAK,IAAI,GAAGP,CAAiB,CAAC,GACrEQ,KAAiBT,KAAiBJ,EAAQ,cAAc,YAAA,GACxDc,IACJ,OAAOR,KAAoB,WAAW,KAAK,IAAI,GAAG,KAAK,IAAI,GAAGA,CAAe,CAAC,IAAI;AAEpF,SAAO;AAAA,IACL,QAAAL;AAAA,IACA,MAAAC;AAAA,IACA,WAAWnB,EAAmBmB,CAAI;AAAA,IAClC,MAAAC;AAAA,IACA,YAAYnB,EAAgBmB,CAAI;AAAA,IAChC,eAAAU;AAAA,IACA,eAAAT;AAAA,IACA,mBAAmBQ;AAAA,IACnB,iBAAiBE;AAAA,IACjB,aAAAP;AAAA,EAAA;AAEJ,GC5JMQ,IAASvC,EAAa,uBAAuB,GAEtCwC,IAA6B,KAMpCC,IAA8B,OAAmB;AAAA,EACrD,KAAK,MACC,OAAO,cAAgB,OAAe,OAAO,YAAY,OAAQ,aAC5D,YAAY,IAAA,IAEd,KAAK,IAAA;AAEhB,IAEaC,IAA0B,MAAkBD,EAAA;AAiBlD,MAAME,EAAQ;AAAA,EACV;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAET,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,OAAO;AAAA,EACP;AAAA,EACA,WAAW;AAAA,EACX;AAAA,EACA;AAAA,EACA,mBAAkC;AAAA,EAClC,qBAAoC;AAAA,EACpC,WAAW;AAAA,EACX,WAAW;AAAA,EACX,WAAW;AAAA,EACX,iBAAiB;AAAA,EACjB,mBAAmB;AAAA,EACnB,cAAc;AAAA,EACd,oBAAoB;AAAA,EACpB,kBAAkB;AAAA,EAClB,yBAAyB;AAAA,EACzB,mBAAmB;AAAA,EACnB,gBAAgB;AAAA,EACC;AAAA,EAEjB,YACEC,GACAC,GACAtB,GACAuB,GACAC,IAAoC,IACpC;AACA,QAAI,OAAOH,KAAS;AAClB,YAAM,IAAI,MAAM,+BAA+B;AAEjD,QAAI,CAAC,OAAO,SAASC,CAAI,KAAKA,IAAO;AACnC,YAAM,IAAI,MAAM,4CAA4C;AAG9D,SAAK,OAAOD,GACZ,KAAK,OAAOC,GACZ,KAAK,WAAW,MAAM,QAAQtB,CAAQ,IAAI,CAAC,GAAGA,CAAQ,IAAI,CAAA;AAE1D,UAAMyB,IAAiB1B,EAAqB,KAAK,UAAU;AAAA,MACzD,cAAcwB,EAAS;AAAA,IAAA,CACxB;AAED,SAAK,SAASE,EAAe,QAC7B,KAAK,cAAc,KAAK,WAAW,QACnC,KAAK,YAAYA,EAAe,WAChC,KAAK,oBAAoBA,EAAe,mBACxC,KAAK,kBAAkBA,EAAe,iBACtC,KAAK,gBAAgBA,EAAe,eACpC,KAAK,cAAcA,EAAe,aAClC,KAAK,aAAaA,EAAe,YACjC,KAAK,QAAQA,EAAe,eAC5B,KAAK,UAAU,KAAK,oBAAoBF,EAAS,cAAc,GAE/D,KAAK,aAAaC,EAAa,cAAcL,EAAA,GAC7C,KAAK,iBAAiBI,CAAQ;AAAA,EAChC;AAAA,EAEA,QACEG,GACAC,GACAC,GACAlD,GACM;AACN,QAAI;AACF,UAAI,CAACgD;AACH,cAAM,IAAI,MAAM,4BAA4B;AAE9C,UAAI,CAAC,OAAO,SAASC,CAAY,KAAK,CAAC,OAAO,SAASC,CAAY;AACjE,cAAM,IAAI,MAAM,mCAAmC;AAErD,UAAI,CAAClD;AACH,cAAM,IAAI,MAAM,8BAA8B;AAGhD,YAAMmD,IAAmB,KAAK,IAAIF,GAAc,CAAC,GAC3CG,IAAe,KAAK,IAAI,IAAI,KAAK,MAAMF,IAAe,IAAI,CAAC,GAC3DG,IAAiB,KAAK,IAAI,IAAI,KAAK,MAAMD,IAAe,KAAK,SAAS,CAAC;AAM7E,UALA,KAAK,WAAWC,GAChBL,EAAI,OAAO,GAAG,KAAK,QAAQ,MAAM,KAAK,UAAU,IAChD,KAAK,QAAQA,EAAI,YAAY,KAAK,IAAI,EAAE,OACxC,KAAK,SAAS,KAAK,UAEf,CAAC,KAAK,aAAa;AACrB,aAAK,cAAc;AACnB,cAAMM,IAAY,KAAK,KAAKH,IAAmB,KAAK,SAAS,GAAG,CAAC;AACjE,aAAK,gBAAgBG,GACrB,KAAK,IAAIA,GACT,KAAK,YAAY,GACjB,KAAK,QAAQ,GACb,KAAK,mBAAmB,GACxB,KAAK,oBAAoBf,GACzB,KAAK,yBAAyBA,GAC9B,KAAK,kBAAkBA,GACvB,KAAK,mBAAmB,KAAK,OAC7B,KAAK,qBAAqB,KAAK,OAAOA,GACtC,KAAK,iBAAiB,KAAK,WAAW,IAAA,GACtC,KAAK,WAAW;AAChB;AAAA,MACF;AAEA,WAAK,qBAAqB;AAC1B,YAAMgB,IAAsBP,EAAI,YAAY,KAAK,OAAO,GAAG,CAAC,EAAE,OAExDQ,IAAkB,KAAK,QAAQ,KAAK,IAAIxD,EAAQ,aAAa,CAAC;AACpE,WAAK,cAAc,KAAK,IAAIA,EAAQ,cAAcwD,CAAe;AACjE,YAAMC,IAAc,KAAK,IAAIzD,EAAQ,eAAe,KAAK,WAAW;AAEpE,WAAK,gBAAgBmD,IAAmBnD,EAAQ,kBAChD,KAAK,IAAI,KAAK;AAEd,YAAM0D,IAAa,KAAK,QAAQP;AAChC,UAAIQ,IAAoB3D,EAAQ;AAChC,UAAI0D,IAAa,GAAG;AAClB,cAAME,IAAe,KAAK,IAAIF,GAAY1D,EAAQ,aAAa,GACzD6D,IAAmB7D,EAAQ,uBAAuB,KAAK,IAAI4D,GAAc,CAAC;AAChF,QAAAD,IAAoB,KAAK,IAAI3D,EAAQ,sBAAsB,KAAK,MAAM6D,CAAgB,CAAC;AAAA,MACzF;AAEA,YAAMC,IAAkBX,IAAmB,KAAK,QAAQ,KAAK,cAAcM,GACrEM,IAAsB,KAAK,IAAIJ,GAAmB,CAAC,GACnDK,IAAcF,IAAkBC,GAChCE,IAAkBD,IAAc,MAAQ;AAC9C,WAAK,YAAYC,GACjB,KAAK,QAAQ,KAAK,WAClB,KAAK,mBAAmBD;AAExB,YAAME,IAAiB,KAAK,gBAAgB,KAAK,QAAQ,KAAK,cAAcT,GACtEU,IAAuBhB,IAAmBM,GAC1CW,IAAa,KAAK,gBAAgB,KAAK,QAAQ,KAAK,aACpDC,IAAkB,KAAK,IAAIL,GAAa,OAAO,OAAO,GACtDM,IAAuB,KAAK,IAAI,GAAGF,IAAaD,CAAoB;AAE1E,WAAK,oBAAoBR,GACzB,KAAK,yBAAyB,KAAK,IAAI,GAAG,KAAK,KAAKW,IAAuBD,CAAe,CAAC,GAC3F,KAAK,kBAAkB,KAAK;AAAA,QAC1B,KAAK;AAAA,QACL,KAAK,KAAKH,IAAiBG,CAAe;AAAA,MAAA;AAG5C,YAAME,IAAkB,KAAK,QAAQ,KAAK,cAAcd;AACxD,WAAK,mBAAmB,KAAK,IAAIF,GAAqBgB,CAAe,GACrE,KAAK,iBAAiB,KAAK,WAAW,IAAA,GACtC,KAAK,WAAW;AAAA,IAClB,SAASC,GAAO;AACd,YAAAlC,EAAO,MAAM,mBAAmBkC,GAAgB;AAAA,QAC9C,MAAM,KAAK;AAAA,QACX,cAAAvB;AAAA,QACA,cAAAC;AAAA,QACA,YAAY,EAAQF;AAAA,MAAG,CACxB,GACKwB;AAAA,IACR;AAAA,EACF;AAAA,EAEA,OAAOC,IAAe,GAAKC,IAAW,IAAa;AACjD,QAAI;AACF,UAAI,CAAC,KAAK,UAAU;AAClB,aAAK,WAAWA;AAChB;AAAA,MACF;AAEA,YAAMC,IAAc,KAAK,WAAW,IAAA;AAEpC,UAAI,CAAC,KAAK,aAAa;AACrB,aAAK,WAAWD,GAChB,KAAK,iBAAiBC;AACtB;AAAA,MACF;AAEA,UAAID,GAAU;AACZ,aAAK,WAAW,IAChB,KAAK,iBAAiBC;AACtB;AAAA,MACF;AAEA,YAAMC,KAAaD,IAAc,KAAK,mBAAmB,MAAO;AAChE,WAAK,QAAQ,KAAK,YAAYF,GAC9B,KAAK,KAAK,KAAK,QAAQG,GACnB,KAAK,IAAI,CAAC,KAAK,UACjB,KAAK,WAAW,KAElB,KAAK,iBAAiBD,GACtB,KAAK,WAAW;AAAA,IAClB,SAASH,GAAO;AACd,MAAAlC,EAAO,MAAM,kBAAkBkC,GAAgB;AAAA,QAC7C,MAAM,KAAK;AAAA,QACX,cAAAC;AAAA,QACA,UAAAC;AAAA,QACA,UAAU,KAAK;AAAA,MAAA,CAChB;AAAA,IACH;AAAA,EACF;AAAA,EAEA,KAAK1B,GAA+B6B,IAA+B,MAAY;AAC7E,QAAI;AACF,UAAI,CAAC,KAAK,YAAY,CAAC7B;AACrB;AAGF,MAAAA,EAAI,KAAA,GACJA,EAAI,cAAc,KAAK,SACvBA,EAAI,OAAO,GAAG,KAAK,QAAQ,MAAM,KAAK,UAAU;AAEhD,YAAM8B,IAAQD,KAAiB,KAAK,GAC9BE,IAAQ,KAAK,IAAI,KAAK;AAE5B,MAAA/B,EAAI,cAAc,WAClBA,EAAI,YAAY,KAAK,IAAI,GAAG,KAAK,WAAW,CAAC,GAC7CA,EAAI,WAAW,SACfA,EAAI,WAAW,KAAK,MAAM8B,GAAOC,CAAK;AAEtC,YAAMC,IAAmB,KAAK,IAAI,GAAG,KAAK,WAAW,IAAI,GACnDC,IAAiB,KAAK,WAAW;AAgCvC,MAxBiD;AAAA,QAC/C;AAAA,UACE,mBAAmB;AAAA,UACnB,mBAAmB;AAAA,UACnB,gBAAgB;AAAA,UAChB,OAAO;AAAA,UACP,KAAK;AAAA,QAAA;AAAA,QAEP;AAAA,UACE,mBAAmB;AAAA,UACnB,mBAAmB;AAAA,UACnB,gBAAgB;AAAA,UAChB,OAAO;AAAA,UACP,KAAK;AAAA,QAAA;AAAA,QAEP;AAAA,UACE,mBAAmB;AAAA,UACnB,mBAAmB;AAAA,UACnB,gBAAgB;AAAA,UAChB,OAAO;AAAA,UACP,KAAK;AAAA,QAAA;AAAA,MACP,EAGW,QAAQ,CAACC,MAAU;AAC9B,cAAMC,IAAuB,KAAK,IAAI,GAAG,KAAK,IAAI,GAAGD,EAAM,QAAQ,KAAK,OAAO,CAAC;AAChF,QAAAlC,EAAI,cAAc,QAAQkC,EAAM,GAAG,KAAKC,CAAoB,KAC5DnC,EAAI,aAAaiC,IAAiBC,EAAM,gBACxClC,EAAI,gBAAgBgC,IAAmBE,EAAM,mBAC7ClC,EAAI,gBAAgBgC,IAAmBE,EAAM,mBAC7ClC,EAAI,YAAY,KAAK,OACrBA,EAAI,SAAS,KAAK,MAAM8B,GAAOC,CAAK;AAAA,MACtC,CAAC,GAED/B,EAAI,cAAc,eAClBA,EAAI,aAAa,GACjBA,EAAI,gBAAgB,GACpBA,EAAI,gBAAgB,GAEpBA,EAAI,YAAY,KAAK,OACrBA,EAAI,SAAS,KAAK,MAAM8B,GAAOC,CAAK,GAEpC/B,EAAI,QAAA;AAAA,IACN,SAASwB,GAAO;AACd,MAAAlC,EAAO,MAAM,gBAAgBkC,GAAgB;AAAA,QAC3C,MAAM,KAAK;AAAA,QACX,UAAU,KAAK;AAAA,QACf,YAAY,EAAQxB;AAAA,QACpB,eAAA6B;AAAA,MAAA,CACD;AAAA,IACH;AAAA,EACF;AAAA,EAEA,iBAAiBhC,GAAkC;AACjD,SAAK,QAAQ,KAAK,kBAAkBA,EAAS,YAAY,GACzD,KAAK,UAAU,KAAK,oBAAoBA,EAAS,cAAc;AAAA,EACjE;AAAA,EAEA,kBAAkBuC,GAA8B;AAC9C,UAAMC,IAAY,KAAK,iBAAiBD;AACxC,WAAI,OAAOC,KAAc,YAAYA,EAAU,WAAW,IACjDD,IAEFC,EAAU,YAAA;AAAA,EACnB;AAAA,EAEA,oBAAoBC,GAAgC;AAClD,QAAI,OAAO,KAAK,mBAAoB;AAClC,aAAO,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,KAAK,eAAe,CAAC;AAEtD,UAAMC,IAASD,IAAiB,KAAK;AACrC,WAAK,OAAO,SAASC,CAAM,IAGpB,KAAK,IAAI,GAAG,KAAK,IAAI,GAAGA,CAAM,CAAC,IAF7B;AAAA,EAGX;AAAA,EAEA,cAAcC,GAAwB;AACpC,SAAK,mBAAmBA;AAAA,EAC1B;AAAA,EAEA,kBAAwB;AACtB,SAAK,mBAAmB,MACnB,KAAK,gBACR,KAAK,qBAAqB;AAAA,EAE9B;AAAA,EAEA,iBAAiBC,GAAgC;AAI/C,WAHI,KAAK,eAGL,KAAK,uBAAuB,OACvB,KAEFA,KAAiB,KAAK;AAAA,EAC/B;AACF;ACzWA,MAAMC,IAAkC;AAAA,EACtC,cAAc;AAAA,EACd,gBAAgB;AAAA,EAChB,kBAAkB;AAAA,EAClB,4BAA4B;AAAA,EAC5B,SAAS,CAAA;AAAA,EACT,WAAW,CAAA;AACb,GAEaC,KAA8CD,GAE9CE,IAAuB,OAAyB;AAAA,EAC3D,GAAGF;AAAA,EACH,SAAS,CAAC,GAAGA,EAAc,OAAO;AAAA,EAClC,WAAW,CAAC,GAAGA,EAAc,SAAS;AACxC,IAEaG,KAAmB,UCU1BC,IAAiB,CAACC,MAA4BA,IAAU,KACxDC,KAA2B,KAC3BC,IAAmB,KACnBC,KAA8B,KAC9BC,KAA0B,KAC1BC,KAA0B,MAC1BC,KAA0B,GAC1BC,KAAyB,MACzBC,KAA2B,IAC3BC,KAAkB,IAClBC,IAA6B,KAC7BC,KAAiB,GACjBC,KAAqB,IACrBC,IAAmB,IACnBC,IAAe,MACfC,IAA4B,IAErBC,KAAsC,CACjDC,MAGE,OAAO,SAAW,OAClB,OAAO,OAAO,yBAA0B,cACxC,OAAO,OAAO,wBAAyB,aAEhC;AAAA,EACL,SAAS,CAACC,MAAa,OAAO,sBAAsBA,CAAQ;AAAA,EAC5D,QAAQ,CAACC,MAAW,OAAO,qBAAqBA,CAAM;AAAA,IAGnD;AAAA,EACL,SAAS,CAACD,MACU,WAAW,WAAW,MAAM;AAC5C,IAAAA,EAASD,EAAW,KAAK;AAAA,EAC3B,GAAG,EAAE;AAAA,EAGP,QAAQ,CAACE,MAAW;AAClB,eAAW,aAAaA,CAAM;AAAA,EAChC;AAAA,GAIEC,KAA6B,MAC7B,OAAO,WAAa,MACf,MAAM;AACX,QAAM,IAAI;AAAA,IACR;AAAA,EAAA;AAEJ,IAEK,MAAM,SAAS,cAAc,QAAQ,GAGxCC,KAAqB,CAACC,MAA8C;AACxE,MAAI,CAACA,KAAS,OAAOA,KAAU;AAC7B,WAAO;AAET,QAAMhC,IAAYgC;AAClB,SACE,OAAOhC,EAAU,gBAAiB,YAClC,OAAOA,EAAU,kBAAmB,YACpC,OAAOA,EAAU,oBAAqB;AAE1C;AAEO,MAAMiC,GAAgB;AAAA,EACnB;AAAA,EACS,WAAsB,CAAA;AAAA,EACtB,oCAAoB,IAAA;AAAA,EACpB,gDAAgC,IAAA;AAAA,EAChC,mDAAmC,IAAA;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACT,SAAmC;AAAA,EACnC,MAAuC;AAAA,EACvC,eAAwC;AAAA,EACxC,mBAAuC;AAAA,EACvC,YAAYX;AAAA,EACZ,aAAa;AAAA,EACb,cAAc;AAAA,EACd,WAAW;AAAA,EACX,eAAe;AAAA,EACf,YAAY;AAAA,EACZ,eAAe;AAAA,EACf,mBAAmB;AAAA,EACnB,UAAgD;AAAA,EAChD,iBAAwC;AAAA,EACxC,uBAAuC;AAAA,EAC9B,4BAA4B,OAAO,iBAAmB;AAAA,EACtD,eAAkC,CAAA;AAAA,EAInD,YACEY,IAAoE,MACpEC,IAAiD,QACjD;AACA,QAAIC,GACAC;AAEJ,QAAIN,GAAmBG,CAAgB;AACrC,MAAAE,IAAe,EAAE,GAAGF,EAAA,GACpBG,IAASF,KAAe,CAAA;AAAA,SACnB;AACL,YAAMG,IAAkBJ,KAAoBC,KAAe,CAAA;AAC3D,MAAAE,IACE,OAAOC,KAAoB,WAAYA,IAA4C,CAAA,GACrFF,IAAe7B,EAAA;AAAA,IACjB;AAEA,SAAK,aAAa8B,EAAO,cAAcjF,EAAA,GACvC,KAAK,yBACHiF,EAAO,0BAA0BX,GAAoC,KAAK,UAAU,GACtF,KAAK,sBAAsBW,EAAO,uBAAuBP,GAAA,GACzD,KAAK,sBAAsB,EAAE,YAAY,KAAK,WAAA,GAC9C,KAAK,YAAY,EAAE,GAAGM,EAAA,GACtB,KAAK,MAAM1H,EAAa2H,EAAO,mBAAmB,iBAAiB;AAAA,EACrE;AAAA,EAEA,IAAI,WAA6B;AAC/B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,SAAS7G,GAAyB;AACpC,SAAK,YAAY,EAAE,GAAGA,EAAA;AAAA,EACxB;AAAA,EAEQ,iBACN+G,GACAC,GACa;AACb,QAAID;AACF,aAAOA;AAET,QAAIC,EAAM;AACR,aAAOA,EAAM;AAEf,QAAI,OAAO,WAAa,OAAe,SAAS;AAC9C,aAAO,SAAS;AAElB,UAAM,IAAI;AAAA,MACR;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEQ,2BAA2BC,GAA8B;AAC/D,QAAI,OAAO,oBAAqB,YAAY;AAE1C,MADc,iBAAiBA,CAAS,EAC9B,aAAa,aACrBA,EAAU,MAAM,WAAW;AAE7B;AAAA,IACF;AACA,IAAKA,EAAU,MAAM,aACnBA,EAAU,MAAM,WAAW;AAAA,EAE/B;AAAA,EAEA,WAAW9H,GAAoE;AAC7E,QAAI;AACF,WAAK,kBAAA;AAEL,YAAM6H,IAAQ7H,aAAmB,mBAAmBA,IAAUA,EAAQ,OAChE+H,IACJ/H,aAAmB,mBACfA,EAAQ,gBACPA,EAAQ,aAAaA,EAAQ,MAAM,eACpC8H,IAAY,KAAK,iBAAiBC,KAAsB,MAAMF,CAAK;AAEzE,WAAK,eAAeA,GACpB,KAAK,mBAAmBC,GACxB,KAAK,WAAW,OAAO,SAASD,EAAM,QAAQ,IAAI/B,EAAe+B,EAAM,QAAQ,IAAI,GACnF,KAAK,cAAc/B,EAAe+B,EAAM,WAAW,GACnD,KAAK,eAAeA,EAAM,cAC1B,KAAK,YAAY,CAACA,EAAM,QACxB,KAAK,eAAe,KAAK,WAAW,IAAA;AAEpC,YAAMG,IAAS,KAAK,oBAAA,GACdzG,IAAUyG,EAAO,WAAW,IAAI;AACtC,UAAI,CAACzG;AACH,cAAM,IAAI,MAAM,qCAAqC;AAGvD,MAAAyG,EAAO,MAAM,WAAW,YACxBA,EAAO,MAAM,MAAM,KACnBA,EAAO,MAAM,OAAO,KACpBA,EAAO,MAAM,gBAAgB,QAC7BA,EAAO,MAAM,SAAS;AAEtB,YAAMC,IAAS,KAAK;AACpB,MAAIA,aAAkB,gBACpB,KAAK,2BAA2BA,CAAM,GACtCA,EAAO,YAAYD,CAAM,IAG3B,KAAK,SAASA,GACd,KAAK,MAAMzG,GAEX,KAAK,OAAA,GACL,KAAK,qBAAA,GACL,KAAK,yBAAyBsG,CAAK,GACnC,KAAK,oBAAoBA,CAAK,GAC9B,KAAK,0BAA0BA,GAAOC,CAAS,GAC/C,KAAK,eAAA;AAAA,IACP,SAAStD,GAAO;AACd,iBAAK,IAAI,MAAM,8BAA8BA,CAAc,GACrDA;AAAA,IACR;AAAA,EACF;AAAA,EAEA,WAAW7B,GAAcC,GAActB,IAAqB,CAAA,GAAoB;AAO9E,QANI,KAAK,YAAYqB,CAAI,KAGP,KAAK,SAAS;AAAA,MAC9B,CAACuF,MAAYA,EAAQ,SAASvF,KAAQuF,EAAQ,SAAStF;AAAA,IAAA;AAGvD,aAAO;AAGT,UAAMsF,IAAU,IAAIxF,EAAQC,GAAMC,GAAMtB,GAAU,KAAK,WAAW,KAAK,mBAAmB;AAC1F,gBAAK,SAAS,KAAK4G,CAAO,GAC1B,KAAK,SAAS,KAAK,CAACC,GAAGC,MAAMD,EAAE,OAAOC,EAAE,IAAI,GACrCF;AAAA,EACT;AAAA,EAEA,gBAAsB;AACpB,SAAK,SAAS,SAAS,GACvB,KAAK,cAAc,MAAA,GACnB,KAAK,0BAA0B,MAAA,GAC/B,KAAK,6BAA6B,MAAA,GAC9B,KAAK,OAAO,KAAK,UACnB,KAAK,IAAI,UAAU,GAAG,GAAG,KAAK,OAAO,OAAO,KAAK,OAAO,MAAM;AAAA,EAElE;AAAA,EAEA,aAAmB;AACjB,SAAK,cAAA,GACL,KAAK,cAAc,GACnB,KAAK,mBAAmB;AAAA,EAC1B;AAAA,EAEA,UAAgB;AACd,SAAK,cAAA,GACL,KAAK,sBAAA,GACL,KAAK,gBAAA,GAED,KAAK,UACP,KAAK,OAAO,OAAA,GAEd,KAAK,SAAS,MACd,KAAK,MAAM,MACX,KAAK,eAAe,MACpB,KAAK,mBAAmB,MACxB,KAAK,SAAS,SAAS,GACvB,KAAK,cAAc,MAAA,GACnB,KAAK,mBAAmB;AAAA,EAC1B;AAAA,EAEA,eAAeG,GAAqC;AAClD,UAAMC,IAAuB,KAAK,UAAU;AAC5C,SAAK,WAAWD,GAEhB,KAAK,SAAS,QAAQ,CAACH,MAAY;AACjC,MAAAA,EAAQ,iBAAiB,KAAK,SAAS;AAAA,IACzC,CAAC,GAEG,CAAC,KAAK,UAAU,oBAAoB,KAAK,OAAO,KAAK,WACvD,KAAK,SAAS,QAAQ,CAACA,MAAY;AACjC,MAAAA,EAAQ,WAAW,IACnBA,EAAQ,gBAAA;AAAA,IACV,CAAC,GACD,KAAK,IAAI,UAAU,GAAG,GAAG,KAAK,OAAO,OAAO,KAAK,OAAO,MAAM,GAC9D,KAAK,cAAc,MAAA,GACnB,KAAK,0BAA0B,MAAA,GAC/B,KAAK,6BAA6B,MAAA,IAGhCI,MAAyB,KAAK,UAAU,8BAA8B,KAAK,gBAC7E,KAAK,oBAAoB,KAAK,YAAY;AAAA,EAE9C;AAAA,EAEA,kBAA2C;AACzC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,wBAAuC;AACrC,UAAMT,IAAQ,KAAK;AACnB,QAAI,CAACA;AACH,aAAO;AAET,QAAI,OAAOA,EAAM,cAAe,YAAYA,EAAM,WAAW,SAAS;AACpE,aAAOA,EAAM;AAEf,UAAMU,IAAYV,EAAM,aAAa,KAAK;AAC1C,QAAIU,KAAaA,EAAU,SAAS;AAClC,aAAOA;AAET,UAAMC,IAAgBX,EAAM,cAAc,aAAa;AACvD,WAAIW,KAAiB,OAAOA,EAAc,OAAQ,WACzCA,EAAc,MAEhB;AAAA,EACT;AAAA,EAEA,sBAAiC;AAC/B,WAAO,CAAC,GAAG,KAAK,QAAQ;AAAA,EAC1B;AAAA,EAEA,YAAY7F,GAAuB;AACjC,QAAI;AAKF,aAJI,OAAOA,KAAS,YAIhB,MAAM,QAAQ,KAAK,UAAU,OAAO,KACf,KAAK,UAAU,QAAQ;AAAA,QAC5C,CAAC8F,MAAS,OAAOA,KAAS,YAAYA,EAAK,SAAS,KAAK9F,EAAK,SAAS8F,CAAI;AAAA,MAAA,IAGpE,KAIP,MAAM,QAAQ,KAAK,UAAU,SAAS,IACjC,KAAK,UAAU,UAAU,KAAK,CAACC,MAAY;AAChD,YAAI,OAAOA,KAAY,YAAYA,EAAQ,WAAW;AACpD,iBAAO;AAET,YAAI;AACF,iBAAO,IAAI,OAAOA,CAAO,EAAE,KAAK/F,CAAI;AAAA,QACtC,SAASgG,GAAY;AACnB,sBAAK,IAAI,MAAM,qCAAqCA,GAAqB;AAAA,YACvE,SAAAD;AAAA,YACA,MAAA/F;AAAA,UAAA,CACD,GACM;AAAA,QACT;AAAA,MACF,CAAC,IAGI;AAAA,IACT,SAAS6B,GAAO;AACd,kBAAK,IAAI,MAAM,+BAA+BA,GAAgB,EAAE,MAAA7B,GAAM,GAC/D;AAAA,IACT;AAAA,EACF;AAAA,EAEA,OAAOiG,GAAgBC,GAAuB;AAC5C,UAAMhB,IAAQ,KAAK,cACbG,IAAS,KAAK;AACpB,QAAI,CAACH,KAAS,CAACG;AACb;AAGF,UAAMc,IAAOjB,EAAM,sBAAA,GACbkB,IAAgBH,KAASE,EAAK,SAASd,EAAO,OAC9CgB,IAAiBH,KAAUC,EAAK,UAAUd,EAAO;AAEvD,QACE,CAAC,OAAO,SAASe,CAAa,KAC9B,CAAC,OAAO,SAASC,CAAc,KAC/BD,KAAiB,KACjBC,KAAkB;AAElB;AAGF,UAAMC,IAAY,KAAK,IAAI,GAAG,KAAK,MAAMF,CAAa,CAAC,GACjDG,IAAa,KAAK,IAAI,GAAG,KAAK,MAAMF,CAAc,CAAC;AAEzD,QAAI,CAAC,OAAO,SAASC,CAAS,KAAK,CAAC,OAAO,SAASC,CAAU;AAC5D;AAGF,UAAMC,IAAgBnB,EAAO,SAASiB,GAChCG,IAAiBpB,EAAO,UAAUkB;AAExC,QAAIC,MAAkBF,KAAaG,MAAmBF;AACpD;AAGF,IAAAlB,EAAO,QAAQiB,GACfjB,EAAO,SAASkB,GAChBlB,EAAO,MAAM,QAAQ,GAAGiB,CAAS,MACjCjB,EAAO,MAAM,SAAS,GAAGkB,CAAU;AAEnC,UAAMG,IAASF,IAAgB,IAAIF,IAAYE,IAAgB,GACzDG,IAASF,IAAiB,IAAIF,IAAaE,IAAiB;AAElE,KAAIC,MAAW,KAAKC,MAAW,MAC7B,KAAK,SAAS,QAAQ,CAACpB,MAAY;AACjC,MAAIA,EAAQ,aACVA,EAAQ,KAAKmB,GACbnB,EAAQ,KAAKoB,GACbpB,EAAQ,aAAamB,GACrBnB,EAAQ,SAASmB,GACjBnB,EAAQ,WAAW,KAAK,IAAItB,GAAkB,KAAK,MAAMsC,IAAa,IAAI,CAAC;AAAA,IAE/E,CAAC,GAGH,KAAK,qBAAA;AAAA,EACP;AAAA,EAEQ,oBAA0B;AAChC,SAAK,cAAA,GACL,KAAK,sBAAA,GACL,KAAK,gBAAA,GACD,KAAK,UACP,KAAK,OAAO,OAAA,GAEd,KAAK,SAAS,MACd,KAAK,MAAM;AAAA,EACb;AAAA,EAEQ,uBAA6B;AACnC,UAAMlB,IAAS,KAAK;AACpB,QAAI,CAACA;AACH;AAGF,UAAMuB,IAAa,KAAK,IAAI3C,GAAkB,KAAK,MAAMoB,EAAO,SAAS,IAAI,CAAC;AAC9E,SAAK,aAAauB,IAAa;AAC/B,UAAMC,IAAiB,KAAK,MAAMxB,EAAO,SAAS,KAAK,IAAI,KAAK,YAAY,CAAC,CAAC;AAC9E,SAAK,YAAY,KAAK,IAAItB,IAAgB8C,CAAc,GACxD,KAAK,0BAA0B,MAAA,GAC/B,KAAK,6BAA6B,MAAA;AAAA,EACpC;AAAA,EAEQ,iBAAuB;AAC7B,UAAM3B,IAAQ,KAAK,cACbG,IAAS,KAAK,QACdzG,IAAU,KAAK;AACrB,QAAI,CAACsG,KAAS,CAACG,KAAU,CAACzG;AACxB;AAGF,SAAK,cAAcuE,EAAe+B,EAAM,WAAW,GACnD,KAAK,eAAeA,EAAM,cAC1B,KAAK,YAAY,CAACA,EAAM;AACxB,UAAM4B,IAAiB,KAAK,oBAAoBzB,EAAO,KAAK,GAEtD0B,IACJ,KAAK,WAAW,KAAK,KAAK,WAAW,KAAK,eAAe1D;AAE3D,IAAI0D,KAAa,CAAC,KAAK,qBACrB,KAAK,mBAAmB,IACxBnI,EAAQ,UAAU,GAAG,GAAGyG,EAAO,OAAOA,EAAO,MAAM,GACnD,KAAK,SAAS,QAAQ,CAACE,MAAY;AACjC,MAAAA,EAAQ,WAAW,IACnBA,EAAQ,gBAAA;AAAA,IACV,CAAC,GACD,KAAK,cAAc,MAAA,GACnB,KAAK,0BAA0B,MAAA,GAC/B,KAAK,6BAA6B,MAAA,IAGhC,CAACwB,KAAa,KAAK,qBACrB,KAAK,mBAAmB,KAG1B,KAAK,4BAA4B,KAAK,WAAW;AAEjD,eAAWxB,KAAW,KAAK;AACzB,UAAI,MAAK,YAAYA,EAAQ,IAAI,GAGjC;AAAA,YAAIA,EAAQ,aAAa;AACvB,UAAAA,EAAQ,WAAW,IACnBA,EAAQ,WAAW,IACnBA,EAAQ,gBAAA;AACR;AAAA,QACF;AAeA,YAbAA,EAAQ,iBAAiB,KAAK,SAAS,GAEnC,KAAK,4BAA4BA,GAAS,KAAK,WAAW,KAC5D,KAAK;AAAA,UACHA;AAAA,UACA3G;AAAA,UACAyG,EAAO;AAAA,UACPA,EAAO;AAAA,UACPyB;AAAA,UACA,KAAK;AAAA,QAAA,GAILvB,EAAQ,UAAU;AACpB,cAAIA,EAAQ,WAAW,UAAUA,EAAQ,iBAAiB,KAAK,WAAW,GAAG;AAC3E,kBAAMyB,IAAiBzB,EAAQ,WAAW,OAAO,OAAO;AACxD,iBAAK,kBAAkByB,GAAgBzB,EAAQ,IAAI,GACnDA,EAAQ,WAAW,IACnBA,EAAQ,gBAAA;AACR;AAAA,UACF;AAEA,cACEA,EAAQ,WAAW,UACnBA,EAAQ,OAAO,KAAK,cAAcpB,GAClC;AACA,YAAAoB,EAAQ,IAAIA,EAAQ,eACpBA,EAAQ,iBAAiB,KAAK,WAAW,IAAA;AACzC;AAAA,UACF;AAIA,cAFAA,EAAQ,WAAW,IACnBA,EAAQ,OAAO,KAAK,cAAc,CAAC,KAAK,SAAS,GAC7C,CAACA,EAAQ,eAAeA,EAAQ,iBAAiB,KAAK,WAAW,GAAG;AACtE,kBAAMyB,IAAiBzB,EAAQ,WAAW,OAAO,OAAO;AACxD,iBAAK,kBAAkByB,GAAgBzB,EAAQ,IAAI,GACnDA,EAAQ,WAAW,IACnBA,EAAQ,gBAAA;AAAA,UACV;AAAA,QACF;AAAA;AAGF,eAAWA,KAAW,KAAK;AACzB,MAAIA,EAAQ,YAAYA,EAAQ,eAAeA,EAAQ,IAAI,CAACA,EAAQ,UAClEA,EAAQ,WAAW,IACnBA,EAAQ,gBAAA;AAAA,EAGd;AAAA,EAEQ,oBAAoBjF,GAA6C;AACvE,WAAO;AAAA,MACL,cAAAA;AAAA,MACA,kBAAkBiD;AAAA,MAClB,sBAAsBC;AAAA,MACtB,sBAAsBC;AAAA,MACtB,eAAeC;AAAA,MACf,aAAaC;AAAA,MACb,cAAcC;AAAA,MACd,eAAeC;AAAA,IAAA;AAAA,EAEnB;AAAA,EAEQ,kBAAkB0B,GAA0B;AAClD,UAAMvD,IAAc,KAAK;AACzB,SAAK,sBAAsBA,CAAW,GACtC,KAAK,4BAA4BA,CAAW;AAC5C,UAAMiF,IAAiB,KAAK,qBAAqBjF,CAAW,GACtDkF,IAAiB,KAAK,sBAAsB3B,GAASvD,CAAW;AAEtE,eAAWmF,KAAQF;AACjB,UAAI,KAAK,gBAAgBE,GAAMD,GAAgBlF,CAAW;AACxD,oBAAK,qBAAqBmF,GAAMD,CAAc,GACvCC;AAIX,UAAMC,IAAeH,EAAe,CAAC,KAAK;AAC1C,gBAAK,qBAAqBG,GAAcF,CAAc,GAC/CE;AAAA,EACT;AAAA,EAEQ,sBAAsBpF,GAA2B;AACvD,eAAW,CAACmF,GAAME,CAAY,KAAK,KAAK,cAAc,WAAW;AAC/D,YAAMC,IAAWD,EAAa;AAAA,QAC5B,CAACE,MAAgBA,EAAY,eAAezD,IAA6B9B;AAAA,MAAA;AAE3E,MAAIsF,EAAS,SAAS,IACpB,KAAK,cAAc,IAAIH,GAAMG,CAAQ,IAErC,KAAK,cAAc,OAAOH,CAAI;AAAA,IAElC;AAAA,EACF;AAAA,EAEQ,4BAA4BnF,GAA2B;AAC7D,eAAW,CAACmF,GAAMK,CAAW,KAAK,KAAK,0BAA0B;AAC/D,MAAIA,KAAexF,KACjB,KAAK,0BAA0B,OAAOmF,CAAI;AAG9C,eAAW,CAACA,GAAMK,CAAW,KAAK,KAAK,6BAA6B;AAClE,MAAIA,KAAexF,KACjB,KAAK,6BAA6B,OAAOmF,CAAI;AAAA,EAGnD;AAAA,EAEQ,iBAAiBM,GAA+C;AACtE,WAAOA,MAAa,OAAO,KAAK,4BAA4B,KAAK;AAAA,EACnE;AAAA,EAEQ,2BAAwC;AAC9C,UAAMC,wBAAe,IAAA;AACrB,eAAWP,KAAQ,KAAK,0BAA0B,KAAA;AAChD,MAAAO,EAAS,IAAIP,CAAI;AAEnB,eAAWA,KAAQ,KAAK,6BAA6B,KAAA;AACnD,MAAAO,EAAS,IAAIP,CAAI;AAEnB,WAAOO;AAAA,EACT;AAAA,EAEQ,4BAA4BnC,GAAkBoC,GAAyB;AAO7E,WANI,EAAApC,EAAQ,eAAeA,EAAQ,YAG/BA,EAAQ,OAAOoC,IAASxD,KAGxBoB,EAAQ,OAAOoC,IAASrE;AAAA,EAI9B;AAAA,EAEQ,gBACNiC,GACA3G,GACAgJ,GACArH,GACAlD,GACAwK,GACM;AAGN,QAFAtC,EAAQ,QAAQ3G,GAASgJ,GAAarH,GAAclD,CAAO,GAEvDkI,EAAQ,WAAW,QAAQ;AAC7B,YAAMuC,IAAY,KAAK,IAAI,GAAGD,IAAgBtC,EAAQ,IAAI,GACpDwC,IAAexC,EAAQ,mBAAmBuC,GAC1CE,IAAazC,EAAQ,gBAAgBwC;AAE3C,UAAIC,KAAc,CAACzC,EAAQ,OAAO;AAChC,QAAAA,EAAQ,WAAW,IACnBA,EAAQ,WAAW,IACnBA,EAAQ,gBAAA,GACRA,EAAQ,OAAO;AACf;AAAA,MACF;AAEA,MAAAA,EAAQ,OAAO,KAAK,kBAAkBA,CAAO,GAC7CA,EAAQ,IAAIA,EAAQ,OAAO,KAAK,YAChCA,EAAQ,IAAIyC,GACZzC,EAAQ,WAAW,IACnBA,EAAQ,WAAW,IACnBA,EAAQ,WAAW,CAAC,KAAK,WACzBA,EAAQ,cAAcsC,CAAa,GACnCtC,EAAQ,iBAAiB,KAAK,WAAW,IAAA;AACzC;AAAA,IACF;AAEA,UAAM0C,IAAa1C,EAAQ,OAAO3F;AAClC,QAAIiI,IAAgBI,GAAY;AAC9B,MAAA1C,EAAQ,WAAW,IACnBA,EAAQ,WAAW,IACnBA,EAAQ,gBAAA,GACRA,EAAQ,OAAO;AACf;AAAA,IACF;AAEA,UAAMyB,IAAiBzB,EAAQ,WAAW,OAAO,OAAO,SAClD2C,IAAY,KAAK,iBAAiBlB,CAAc;AACtD,IAAAzB,EAAQ,OAAO2C,GACf3C,EAAQ,IAAI2C,IAAY,KAAK,YAC7B3C,EAAQ,IAAIA,EAAQ,eACpBA,EAAQ,WAAW,IACnBA,EAAQ,WAAW,IACnBA,EAAQ,WAAW,CAAC,KAAK,WACzBA,EAAQ,cAAcsC,CAAa,GACnCtC,EAAQ,iBAAiB,KAAK,WAAW,IAAA,GACzCA,EAAQ,qBAAqB0C,GAC7B,KAAK,kBAAkBjB,GAAgBkB,GAAWD,CAAU;AAAA,EAC9D;AAAA,EAEQ,iBAAiBR,GAAkC;AACzD,UAAMU,IAAU,KAAK,iBAAiBV,CAAQ,GACxCW,IAAc,MAAM,KAAK,EAAE,QAAQ,KAAK,aAAa,CAACC,GAAGC,MAAUA,CAAK;AAC9E,IAAIb,MAAa,WACfW,EAAY,QAAA;AAEd,eAAWjB,KAAQiB;AACjB,UAAI,CAACD,EAAQ,IAAIhB,CAAI;AACnB,eAAOA;AAGX,QAAIC,IAAegB,EAAY,CAAC,KAAK,GACjCG,IAAkB,OAAO;AAC7B,eAAW,CAACpB,GAAMK,CAAW,KAAKW,EAAQ;AACxC,MAAIX,IAAce,MAChBA,IAAkBf,GAClBJ,IAAeD;AAGnB,WAAOC;AAAA,EACT;AAAA,EAEQ,kBAAkBK,GAA0BN,GAAcK,GAA2B;AAE3F,IADgB,KAAK,iBAAiBC,CAAQ,EACtC,IAAIN,GAAMK,CAAW;AAAA,EAC/B;AAAA,EAEQ,kBAAkBC,GAA0BN,GAAoB;AACtE,QAAIA,IAAO;AACT;AAGF,IADgB,KAAK,iBAAiBM,CAAQ,EACtC,OAAON,CAAI;AAAA,EACrB;AAAA,EAEQ,qBAAqBnF,GAA+B;AAE1D,UAAMwG,IADU,MAAM,KAAK,EAAE,QAAQ,KAAK,aAAa,CAACH,GAAGC,MAAUA,CAAK,EACnD,KAAK,CAAC9C,GAAGC,MAAM;AACpC,YAAMgD,IAAQ,KAAK,yBAAyBjD,GAAGxD,CAAW,GACpD0G,IAAQ,KAAK,yBAAyBjD,GAAGzD,CAAW;AAC1D,aAAI,KAAK,IAAIyG,IAAQC,CAAK,KAAKxE,IACtBsB,IAAIC,IAENgD,IAAQC;AAAA,IACjB,CAAC,GACKC,IAAiB,KAAK,yBAAA;AAC5B,QAAIA,EAAe,SAAS;AAC1B,aAAOH;AAET,UAAMI,IAAYJ,EAAO,OAAO,CAACrB,MAAS,CAACwB,EAAe,IAAIxB,CAAI,CAAC;AACnE,QAAIyB,EAAU,WAAW;AACvB,aAAOJ;AAET,UAAMK,IAAUL,EAAO,OAAO,CAACrB,MAASwB,EAAe,IAAIxB,CAAI,CAAC;AAChE,WAAO,CAAC,GAAGyB,GAAW,GAAGC,CAAO;AAAA,EAClC;AAAA,EAEQ,yBAAyB1B,GAAcnF,GAA6B;AAC1E,UAAMqF,IAAe,KAAK,cAAc,IAAIF,CAAI;AAChD,QAAI,CAACE,KAAgBA,EAAa,WAAW;AAC3C,aAAOrF;AAET,QAAI8G,IAAW9G;AACf,eAAWuF,KAAeF;AACxB,MAAAyB,IAAW,KAAK,IAAIA,GAAUvB,EAAY,OAAO;AAEnD,WAAOuB;AAAA,EACT;AAAA,EAEQ,sBAAsBvD,GAAkBwD,GAAoC;AAClF,UAAMC,IAAQ,KAAK,IAAIzD,EAAQ,kBAAkBrB,CAAY,GACvD+E,IAAUF,IAAYxD,EAAQ,yBAAyBzB,GACvDoF,IAAeH,IAAYxD,EAAQ,kBAAkBzB;AAC3D,WAAO;AAAA,MACL,SAAAyB;AAAA,MACA,WAAAwD;AAAA,MACA,SAAS,KAAK,IAAIA,GAAWE,CAAO;AAAA,MACpC,cAAc,KAAK,IAAIF,GAAWG,CAAY;AAAA,MAC9C,WAAW3D,EAAQ;AAAA,MACnB,OAAOA,EAAQ;AAAA,MACf,OAAAyD;AAAA,MACA,QAAQzD,EAAQ;AAAA,IAAA;AAAA,EAEpB;AAAA,EAEQ,gBAAgB4B,GAAczE,GAA4BV,GAA8B;AAC9F,UAAMqF,IAAe,KAAK,cAAc,IAAIF,CAAI;AAChD,QAAI,CAACE,KAAgBA,EAAa,WAAW;AAC3C,aAAO;AAET,eAAWE,KAAeF;AACxB,UAAI,EAAAE,EAAY,eAAezD,KAA8B9B,MAGzD,KAAK,2BAA2BuF,GAAa7E,CAAS;AACxD,eAAO;AAGX,WAAO;AAAA,EACT;AAAA,EAEQ,qBAAqByE,GAAcI,GAAoC;AAE7E,UAAM4B,IAAU,CAAC,GADA,KAAK,cAAc,IAAIhC,CAAI,KAAK,CAAA,GACnBI,CAAW,EAAE,KAAK,CAAC,GAAG9B,MAAM,EAAE,UAAUA,EAAE,OAAO;AAC/E,SAAK,cAAc,IAAI0B,GAAMgC,CAAO;AAAA,EACtC;AAAA,EAEQ,2BAA2B3D,GAAoBC,GAA6B;AAClF,UAAM2D,IAAe,KAAK,IAAI5D,EAAE,WAAWC,EAAE,SAAS,GAChD4D,IAAa,KAAK,IAAI7D,EAAE,SAASC,EAAE,OAAO;AAChD,QAAI2D,KAAgBC;AAClB,aAAO;AAGT,UAAMC,wBAAsB,IAAY;AAAA,MACtCF;AAAA,MACAC;AAAA,MACAD,KAAgBC,IAAaD,KAAgB;AAAA,IAAA,CAC9C,GAEKG,IAAsB,KAAK,2BAA2B/D,GAAGC,CAAC;AAChE,IACE8D,MAAwB,QACxBA,KAAuBH,IAAelF,KACtCqF,KAAuBF,IAAanF,KAEpCoF,EAAgB,IAAIC,CAAmB;AAGzC,UAAMC,IAAuB,KAAK,2BAA2B/D,GAAGD,CAAC;AACjE,IACEgE,MAAyB,QACzBA,KAAwBJ,IAAelF,KACvCsF,KAAwBH,IAAanF,KAErCoF,EAAgB,IAAIE,CAAoB;AAG1C,eAAWC,KAAQH,GAAiB;AAClC,UAAIG,IAAOL,IAAelF,KAAgBuF,IAAOJ,IAAanF;AAC5D;AAEF,YAAMwF,IAAa,KAAK,kBAAkBlE,GAAGC,GAAGgE,CAAI,GAC9CE,IAAc,KAAK,kBAAkBlE,GAAGD,GAAGiE,CAAI;AACrD,UAAIC,KAAcxF,KAAgByF,KAAezF;AAC/C,eAAO;AAAA,IAEX;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,kBAAkB0F,GAAuBC,GAAqBJ,GAAsB;AAC1F,UAAMK,IAAY,KAAK,iBAAiBF,GAAMH,CAAI,GAC5CM,IAAU,KAAK,iBAAiBF,GAAIJ,CAAI;AAC9C,WAAOK,EAAU,OAAOC,EAAQ;AAAA,EAClC;AAAA,EAEQ,iBACNxC,GACAkC,GACiC;AACjC,UAAMO,IAAU,KAAK,IAAI,GAAGP,IAAOlC,EAAY,SAAS,GAClDQ,IAAeR,EAAY,QAAQyC,GACnCC,IAAU1C,EAAY,YAAYQ,GAClCmC,IAAOD,IAAU1C,EAAY,QAC7B4C,IAAQF,IAAU1C,EAAY,QAAQA,EAAY;AACxD,WAAO,EAAE,MAAA2C,GAAM,OAAAC,EAAA;AAAA,EACjB;AAAA,EAEQ,2BAA2BD,GAAuBC,GAAuC;AAC/F,UAAMC,IAAcD,EAAM,QAAQD,EAAK;AACvC,QAAI,KAAK,IAAIE,CAAW,IAAIlG;AAC1B,aAAO;AAUT,UAAMuF,KAPJU,EAAM,YACNA,EAAM,QAAQA,EAAM,YACpBA,EAAM,QACNA,EAAM,SACND,EAAK,YACLA,EAAK,QAAQA,EAAK,YAClBA,EAAK,UACkBE;AACzB,WAAK,OAAO,SAASX,CAAI,IAGlBA,IAFE;AAAA,EAGX;AAAA,EAEQ,OAAa;AACnB,UAAMpE,IAAS,KAAK,QACdzG,IAAU,KAAK;AACrB,QAAI,CAACyG,KAAU,CAACzG;AACd;AAGF,IAAAA,EAAQ,UAAU,GAAG,GAAGyG,EAAO,OAAOA,EAAO,MAAM;AACnD,UAAMgF,IAAiB,KAAK,SAAS,OAAO,CAAC9E,MAAYA,EAAQ,QAAQ,GACnE+E,IAAM,KAAK,WAAW,IAAA;AAE5B,QAAI,KAAK,UAAU,kBAAkB;AACnC,YAAMrI,KAAaqI,IAAM,KAAK,gBAAiB;AAC/C,MAAAD,EAAe,QAAQ,CAAC9E,MAAY;AAClC,cAAMrD,IAAgBqD,EAAQ,IAAIA,EAAQ,QAAQtD;AAClD,QAAAsD,EAAQ,KAAK3G,GAASsD,CAAa;AAAA,MACrC,CAAC;AAAA,IACH;AAEA,SAAK,eAAeoI;AAAA,EACtB;AAAA,EAEiB,cAAc,MAAY;AACzC,QAAK,KAAK,cAGV;AAAA,UAAI,CAAC,KAAK,UAAU,kBAAkB;AACpC,aAAK,UAAU,KAAK,uBAAuB,QAAQ,KAAK,WAAW;AACnE;AAAA,MACF;AACA,WAAK,eAAA,GACL,KAAK,KAAA,GACL,KAAK,UAAU,KAAK,uBAAuB,QAAQ,KAAK,WAAW;AAAA;AAAA,EACrE;AAAA,EAEQ,iBAAuB;AAC7B,SAAK,cAAA,GACL,KAAK,UAAU,KAAK,uBAAuB,QAAQ,KAAK,WAAW;AAAA,EACrE;AAAA,EAEQ,gBAAsB;AAC5B,IAAI,KAAK,YAAY,SACnB,KAAK,uBAAuB,OAAO,KAAK,OAAO,GAC/C,KAAK,UAAU;AAAA,EAEnB;AAAA,EAEQ,SAAe;AACrB,UAAMjF,IAAS,KAAK,QACdzG,IAAU,KAAK,KACfsG,IAAQ,KAAK;AACnB,QAAI,CAACG,KAAU,CAACzG,KAAW,CAACsG;AAC1B;AAGF,UAAM4D,IAAW3F,EAAe+B,EAAM,WAAW;AAEjD,SAAK,mBAAmB,IACxB,KAAK,cAAc4D,GAEnB,KAAK,cAAc,MAAA,GACnB,KAAK,0BAA0B,MAAA,GAC/B,KAAK,6BAA6B,MAAA;AAClC,UAAMhC,IAAiB,KAAK,oBAAoBzB,EAAO,KAAK;AAE5D,SAAK,SAAS,QAAQ,CAACE,MAAY;AACjC,UAAI,KAAK,YAAYA,EAAQ,IAAI,GAAG;AAClC,QAAAA,EAAQ,WAAW,IACnBA,EAAQ,gBAAA;AACR;AAAA,MACF;AAEA,UAAIA,EAAQ,aAAa;AACvB,QAAAA,EAAQ,WAAW,IACnBA,EAAQ,WAAW,IACnBA,EAAQ,gBAAA;AACR;AAAA,MACF;AAOA,UALAA,EAAQ,iBAAiB,KAAK,SAAS,GACvCA,EAAQ,WAAW,IACnBA,EAAQ,OAAO,IACfA,EAAQ,gBAAA,GAEJ,KAAK,4BAA4BA,GAAS,KAAK,WAAW,GAAG;AAC/D,aAAK;AAAA,UACHA;AAAA,UACA3G;AAAA,UACAyG,EAAO;AAAA,UACPA,EAAO;AAAA,UACPyB;AAAA,UACA,KAAK;AAAA,QAAA;AAEP;AAAA,MACF;AAEA,MAAIvB,EAAQ,OAAO,KAAK,cAAcjC,IACpCiC,EAAQ,WAAW,KAEnBA,EAAQ,WAAW;AAAA,IAEvB,CAAC;AAAA,EACH;AAAA,EAEQ,yBAAyBgF,GAAsC;AACrE,QAAI;AACF,YAAMC,IAAS,MAAY;AACzB,aAAK,YAAY;AACjB,cAAMF,IAAM,KAAK,WAAW,IAAA;AAC5B,aAAK,eAAeA,GACpB,KAAK,SAAS,QAAQ,CAAC/E,MAAY;AACjC,UAAAA,EAAQ,iBAAiB+E,GACzB/E,EAAQ,WAAW;AAAA,QACrB,CAAC;AAAA,MACH,GACMkF,IAAU,MAAY;AAC1B,aAAK,YAAY;AACjB,cAAMH,IAAM,KAAK,WAAW,IAAA;AAC5B,aAAK,SAAS,QAAQ,CAAC/E,MAAY;AACjC,UAAAA,EAAQ,iBAAiB+E,GACzB/E,EAAQ,WAAW;AAAA,QACrB,CAAC;AAAA,MACH,GACMmF,IAAY,MAAY;AAC5B,aAAK,OAAA;AAAA,MACP,GACMC,IAAW,MAAY;AAC3B,aAAK,OAAA;AAAA,MACP,GACMC,IAAe,MAAY;AAC/B,aAAK,eAAeL,EAAa;AACjC,cAAMD,IAAM,KAAK,WAAW,IAAA;AAC5B,aAAK,SAAS,QAAQ,CAAC/E,MAAY;AACjC,UAAAA,EAAQ,iBAAiB+E;AAAA,QAC3B,CAAC;AAAA,MACH,GACMO,IAAmB,MAAY;AACnC,aAAK,0BAA0BN,CAAY;AAAA,MAC7C,GACMO,IAAmB,MAAY;AACnC,aAAK,WAAW,OAAO,SAASP,EAAa,QAAQ,IACjDpH,EAAeoH,EAAa,QAAQ,IACpC;AAAA,MACN,GACMQ,IAAY,MAAY;AAC5B,aAAK,wBAAA;AAAA,MACP;AAEA,MAAAR,EAAa,iBAAiB,QAAQC,CAAM,GAC5CD,EAAa,iBAAiB,SAASE,CAAO,GAC9CF,EAAa,iBAAiB,WAAWG,CAAS,GAClDH,EAAa,iBAAiB,UAAUI,CAAQ,GAChDJ,EAAa,iBAAiB,cAAcK,CAAY,GACxDL,EAAa,iBAAiB,kBAAkBM,CAAgB,GAChEN,EAAa,iBAAiB,kBAAkBO,CAAgB,GAChEP,EAAa,iBAAiB,WAAWQ,CAAS,GAElD,KAAK,WAAW,MAAMR,EAAa,oBAAoB,QAAQC,CAAM,CAAC,GACtE,KAAK,WAAW,MAAMD,EAAa,oBAAoB,SAASE,CAAO,CAAC,GACxE,KAAK,WAAW,MAAMF,EAAa,oBAAoB,WAAWG,CAAS,CAAC,GAC5E,KAAK,WAAW,MAAMH,EAAa,oBAAoB,UAAUI,CAAQ,CAAC,GAC1E,KAAK,WAAW,MAAMJ,EAAa,oBAAoB,cAAcK,CAAY,CAAC,GAClF,KAAK,WAAW,MAAML,EAAa,oBAAoB,kBAAkBM,CAAgB,CAAC,GAC1F,KAAK,WAAW,MAAMN,EAAa,oBAAoB,kBAAkBO,CAAgB,CAAC,GAC1F,KAAK,WAAW,MAAMP,EAAa,oBAAoB,WAAWQ,CAAS,CAAC;AAAA,IAC9E,SAASlJ,GAAO;AACd,iBAAK,IAAI,MAAM,4CAA4CA,CAAc,GACnEA;AAAA,IACR;AAAA,EACF;AAAA,EAEQ,0BAA0B0I,GAAsC;AACtE,SAAK,wBAAwBA,CAAY,GACzC,KAAK,OAAA,GACL,KAAK,qBAAA,GACL,KAAK,OAAA;AAAA,EACP;AAAA,EAEQ,wBAAwBA,GAA8C;AAC5E,UAAMS,IAAST,KAAgB,KAAK;AACpC,QAAI,CAACS,GAAQ;AACX,WAAK,YAAY,IACjB,KAAK,mBAAmB,IACxB,KAAK,qBAAA;AACL;AAAA,IACF;AACA,SAAK,eAAeA,CAAM,GAC1B,KAAK,mBAAmB,IACxB,KAAK,qBAAA;AAAA,EACP;AAAA,EAEQ,eAAeT,GAAsC;AAC3D,SAAK,WAAW,OAAO,SAASA,EAAa,QAAQ,IACjDpH,EAAeoH,EAAa,QAAQ,IACpC,GACJ,KAAK,cAAcpH,EAAeoH,EAAa,WAAW,GAC1D,KAAK,eAAeA,EAAa,cACjC,KAAK,YAAY,CAACA,EAAa,QAC/B,KAAK,eAAe,KAAK,WAAW,IAAA;AAAA,EACtC;AAAA,EAEQ,uBAA6B;AACnC,UAAMD,IAAM,KAAK,WAAW,IAAA,GACtBjF,IAAS,KAAK,QACdzG,IAAU,KAAK;AACrB,IAAIyG,KAAUzG,KACZA,EAAQ,UAAU,GAAG,GAAGyG,EAAO,OAAOA,EAAO,MAAM,GAErD,KAAK,cAAc,MAAA,GACnB,KAAK,0BAA0B,MAAA,GAC/B,KAAK,6BAA6B,MAAA,GAClC,KAAK,SAAS,QAAQ,CAACE,MAAY;AACjC,MAAAA,EAAQ,WAAW,IACnBA,EAAQ,WAAW,CAAC,KAAK,WACzBA,EAAQ,WAAW,IACnBA,EAAQ,OAAO,IACfA,EAAQ,IAAIA,EAAQ,eACpBA,EAAQ,QAAQA,EAAQ,WACxBA,EAAQ,iBAAiB+E,GACzB/E,EAAQ,gBAAA;AAAA,IACV,CAAC;AAAA,EACH;AAAA,EAEQ,0BAA0BgF,GAAgCpF,GAA8B;AAC9F,QAAI,OAAO,mBAAqB,KAAa;AAC3C,WAAK,IAAI;AAAA,QACP;AAAA,MAAA;AAEF;AAAA,IACF;AAEA,UAAM8F,IAAgB,IAAI,iBAAiB,CAACC,MAAc;AACxD,iBAAWC,KAAYD,GAAW;AAChC,YAAIC,EAAS,SAAS,gBAAgBA,EAAS,kBAAkB,OAAO;AACtE,gBAAMC,IAAaD,EAAS;AAC5B,cAAIE,IAA0B,MAC1BC,IAAyB;AAK7B,eAJIF,aAAsB,oBAAoBA,aAAsB,uBAClEC,IAAW,OAAOF,EAAS,YAAa,WAAWA,EAAS,WAAW,MACvEG,IAAUF,EAAW,aAAa,KAAK,IAErCC,MAAaC;AACf;AAEF,eAAK,wBAAwBf,CAAY;AACzC;AAAA,QACF;AACA,YAAIY,EAAS,SAAS,aAAa;AACjC,qBAAWI,KAAQJ,EAAS;AAC1B,gBAAII,aAAgB,mBAAmB;AACrC,mBAAK,wBAAwBhB,CAAY;AACzC;AAAA,YACF;AAEF,qBAAWgB,KAAQJ,EAAS;AAC1B,gBAAII,aAAgB,mBAAmB;AACrC,mBAAK,wBAAwBhB,CAAY;AACzC;AAAA,YACF;AAAA,QAEJ;AAAA,MACF;AAAA,IACF,CAAC;AAED,IAAAU,EAAc,QAAQV,GAAc;AAAA,MAClC,YAAY;AAAA,MACZ,iBAAiB,CAAC,KAAK;AAAA,MACvB,mBAAmB;AAAA,MACnB,WAAW;AAAA,MACX,SAAS;AAAA,IAAA,CACV,GACD,KAAK,WAAW,MAAMU,EAAc,WAAA,CAAY;AAEhD,UAAMO,IAAoB,IAAI,iBAAiB,CAACN,MAAc;AAC5D,iBAAWC,KAAYD;AACrB,YAAIC,EAAS,SAAS,aAGtB;AAAA,qBAAWI,KAAQJ,EAAS,YAAY;AACtC,kBAAMM,IAAY,KAAK,oBAAoBF,CAAI;AAC/C,gBAAIE,KAAaA,MAAc,KAAK,cAAc;AAChD,mBAAK,WAAWA,CAAS;AACzB;AAAA,YACF;AAAA,UACF;AACA,qBAAWF,KAAQJ,EAAS,cAAc;AACxC,gBAAII,MAAS,KAAK,cAAc;AAC9B,mBAAK,eAAe,MACpB,KAAK,wBAAwB,IAAI;AACjC;AAAA,YACF;AACA,gBAAIA,aAAgB,SAAS;AAC3B,oBAAMG,IAAeH,EAAK,cAAc,OAAO;AAC/C,kBAAIG,KAAgBA,MAAiB,KAAK,cAAc;AACtD,qBAAK,eAAe,MACpB,KAAK,wBAAwB,IAAI;AACjC;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA;AAAA,IAEJ,CAAC;AAED,IAAAF,EAAkB,QAAQrG,GAAW,EAAE,WAAW,IAAM,SAAS,IAAM,GACvE,KAAK,WAAW,MAAMqG,EAAkB,WAAA,CAAY;AAAA,EACtD;AAAA,EAEQ,oBAAoBD,GAAqC;AAC/D,QAAIA,aAAgB;AAClB,aAAOA;AAET,QAAIA,aAAgB,SAAS;AAC3B,YAAM7I,IAAY6I,EAAK,cAAc,OAAO;AAC5C,UAAI7I,aAAqB;AACvB,eAAOA;AAAA,IAEX;AACA,WAAO;AAAA,EACT;AAAA,EAEQ,oBAAoB6H,GAAsC;AAGhE,QAFA,KAAK,sBAAA,GAED,KAAK,UAAU,8BAA8B,KAAK,2BAA2B;AAC/E,YAAMS,IAAST,EAAa,iBAAiBA,GACvCoB,IAAW,IAAI,eAAe,CAACC,MAAY;AAC/C,mBAAWC,KAASD,GAAS;AAC3B,gBAAM,EAAE,OAAA3F,GAAO,QAAAC,EAAA,IAAW2F,EAAM;AAChC,UAAI5F,IAAQ,KAAKC,IAAS,IACxB,KAAK,OAAOD,GAAOC,CAAM,IAEzB,KAAK,OAAA;AAAA,QAET;AAAA,MACF,CAAC;AACD,MAAAyF,EAAS,QAAQX,CAAM,GACvB,KAAK,iBAAiBW,GACtB,KAAK,uBAAuBX;AAAA,IAC9B,WAAW,OAAO,SAAW,OAAe,OAAO,OAAO,oBAAqB,YAAY;AACzF,YAAMc,IAAW,MAAY;AAC3B,aAAK,OAAA;AAAA,MACP;AACA,aAAO,iBAAiB,UAAUA,CAAQ,GAC1C,KAAK,WAAW,MAAM,OAAO,oBAAoB,UAAUA,CAAQ,CAAC;AAAA,IACtE;AACE,WAAK,IAAI;AAAA,QACP;AAAA,MAAA;AAAA,EAGN;AAAA,EAEQ,wBAA8B;AACpC,IAAI,KAAK,kBAAkB,KAAK,wBAC9B,KAAK,eAAe,UAAU,KAAK,oBAAoB,GAEzD,KAAK,gBAAgB,WAAA,GACrB,KAAK,iBAAiB,MACtB,KAAK,uBAAuB;AAAA,EAC9B;AAAA,EAEQ,WAAWC,GAAwB;AACzC,SAAK,aAAa,KAAKA,CAAI;AAAA,EAC7B;AAAA,EAEQ,kBAAwB;AAC9B,WAAO,KAAK,aAAa,SAAS,KAAG;AACnC,YAAMA,IAAO,KAAK,aAAa,IAAA;AAC/B,UAAI;AACF,QAAAA,IAAA;AAAA,MACF,SAASlK,GAAO;AACd,aAAK,IAAI,MAAM,+BAA+BA,CAAc;AAAA,MAC9D;AAAA,IACF;AAAA,EACF;AACF;"}