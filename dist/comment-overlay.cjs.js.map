{"version":3,"file":"comment-overlay.cjs.js","sources":["../src/shared/logger.ts","../src/core/comment-commands.ts","../src/shared/debug.ts","../src/core/comment.ts","../src/config/default-settings.ts","../src/core/comment-renderer.ts"],"sourcesContent":["export type LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nexport interface Logger {\n  debug: (...messages: unknown[]) => void;\n  info: (...messages: unknown[]) => void;\n  warn: (...messages: unknown[]) => void;\n  error: (...messages: unknown[]) => void;\n}\n\nexport interface LoggerOptions {\n  level?: LogLevel;\n  emitter?: (level: LogLevel, namespace: string, args: unknown[]) => void;\n}\n\nconst LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nconst fallbackEmitter = (level: LogLevel, namespace: string, args: unknown[]): void => {\n  const prefix = `[${namespace}]`;\n  const consoleArgs: unknown[] = [prefix, ...args];\n  switch (level) {\n    case \"debug\":\n      console.debug(...consoleArgs);\n      break;\n    case \"info\":\n      console.info(...consoleArgs);\n      break;\n    case \"warn\":\n      console.warn(...consoleArgs);\n      break;\n    case \"error\":\n      console.error(...consoleArgs);\n      break;\n    default:\n      console.log(...consoleArgs);\n  }\n};\n\nexport const createLogger = (namespace: string, options: LoggerOptions = {}): Logger => {\n  const { level = \"info\", emitter = fallbackEmitter } = options;\n  const threshold = LEVEL_PRIORITY[level];\n\n  const emit = (logLevel: LogLevel, args: unknown[]): void => {\n    if (LEVEL_PRIORITY[logLevel] < threshold) {\n      return;\n    }\n    emitter(logLevel, namespace, args);\n  };\n\n  return {\n    debug: (...messages: unknown[]) => emit(\"debug\", messages),\n    info: (...messages: unknown[]) => emit(\"info\", messages),\n    warn: (...messages: unknown[]) => emit(\"warn\", messages),\n    error: (...messages: unknown[]) => emit(\"error\", messages),\n  };\n};\n","import {\n  type CommentColorCommand,\n  type CommentCommandParseContext,\n  type CommentCommandParseResult,\n  type CommentFontCommand,\n  type CommentHexColorCommand,\n  type CommentLayoutCommand,\n  type CommentSizeCommand,\n} from \"../shared/types\";\n\nconst COMMENT_SIZE_SCALE: Record<CommentSizeCommand, number> = {\n  small: 0.8,\n  medium: 1,\n  big: 1.4,\n};\n\nconst FONT_FAMILY_MAP: Record<CommentFontCommand, string> = {\n  defont:\n    '\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Hiragino Kaku Gothic Pro\",\"Yu Gothic UI\",\"Yu Gothic\",\"Meiryo\",\"Segoe UI\",\"Osaka\",\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"IPAPGothic\",\"TakaoPGothic\",\"Roboto\",\"Helvetica Neue\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  gothic:\n    '\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"Yu Gothic\",\"Yu Gothic Medium\",\"Meiryo\",\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Segoe UI\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  mincho:\n    '\"MS PMincho\",\"MS Mincho\",\"Hiragino Mincho ProN\",\"Hiragino Mincho Pro\",\"Yu Mincho\",\"Noto Serif CJK JP\",\"Noto Serif JP\",\"Source Han Serif JP\",\"Times New Roman\",\"serif\"',\n};\n\nconst COLOR_COMMAND_MAP: Record<CommentColorCommand, string> = {\n  white: \"#FFFFFF\",\n  red: \"#FF0000\",\n  pink: \"#FF8080\",\n  orange: \"#FF9900\",\n  yellow: \"#FFFF00\",\n  green: \"#00FF00\",\n  cyan: \"#00FFFF\",\n  blue: \"#0000FF\",\n  purple: \"#C000FF\",\n  black: \"#000000\",\n  white2: \"#CC9\",\n  red2: \"#C03\",\n  pink2: \"#F3C\",\n  orange2: \"#F60\",\n  yellow2: \"#990\",\n  green2: \"#0C6\",\n  cyan2: \"#0CC\",\n  blue2: \"#39F\",\n  purple2: \"#63C\",\n  black2: \"#666\",\n};\n\nconst HEX_COLOR_REGEX = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;\n\nconst COMMAND_PREFIX_STRIP_REGEX = /^[,.:;]+/;\nconst COMMAND_SUFFIX_STRIP_REGEX = /[,.:;]+$/;\n\nconst normalizeCommandToken = (value: string): string => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return \"\";\n  }\n  if (HEX_COLOR_REGEX.test(trimmed)) {\n    return trimmed;\n  }\n  const withoutPrefix = trimmed.replace(COMMAND_PREFIX_STRIP_REGEX, \"\");\n  const withoutSuffix = withoutPrefix.replace(COMMAND_SUFFIX_STRIP_REGEX, \"\");\n  return withoutSuffix;\n};\n\nconst normalizeHexColor = (command: CommentHexColorCommand): string | null => {\n  if (!HEX_COLOR_REGEX.test(command)) {\n    return null;\n  }\n  return command.toUpperCase();\n};\n\nconst parseNumericCommandValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  const withoutPx = trimmed.toLowerCase().endsWith(\"px\") ? trimmed.slice(0, -2) : trimmed;\n  const parsed = Number.parseFloat(withoutPx);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst parseLineHeightValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  if (trimmed.endsWith(\"%\")) {\n    const numeric = Number.parseFloat(trimmed.slice(0, -1));\n    if (!Number.isFinite(numeric)) {\n      return null;\n    }\n    return numeric / 100;\n  }\n  return parseNumericCommandValue(trimmed);\n};\n\nconst clampLetterSpacing = (value: number): number => {\n  const maxSpacing = 100;\n  const minSpacing = -100;\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  return Math.min(maxSpacing, Math.max(minSpacing, value));\n};\n\nconst clampLineHeight = (value: number): number => {\n  const minHeight = 0.25;\n  const maxHeight = 5;\n  if (!Number.isFinite(value) || value === 0) {\n    return 1;\n  }\n  return Math.min(maxHeight, Math.max(minHeight, value));\n};\n\nconst isLayoutCommand = (command: string): command is CommentLayoutCommand =>\n  command === \"naka\" || command === \"ue\" || command === \"shita\";\n\nconst isSizeCommand = (command: string): command is CommentSizeCommand =>\n  command === \"small\" || command === \"medium\" || command === \"big\";\n\nconst isFontCommand = (command: string): command is CommentFontCommand =>\n  command === \"defont\" || command === \"gothic\" || command === \"mincho\";\n\nconst isColorCommand = (command: string): command is CommentColorCommand =>\n  command in COLOR_COMMAND_MAP;\n\nexport const parseCommentCommands = (\n  commands: readonly string[],\n  context: CommentCommandParseContext,\n): CommentCommandParseResult => {\n  let layout: CommentLayoutCommand = \"naka\";\n  let size: CommentSizeCommand = \"medium\";\n  let font: CommentFontCommand = \"defont\";\n  let colorOverride: string | null = null;\n  let opacityMultiplier = 1;\n  let opacityOverride: number | null = null;\n  let isInvisible = false;\n  let letterSpacing = 0;\n  let lineHeight = 1;\n\n  for (const rawCommand of commands) {\n    const normalizedToken = normalizeCommandToken(typeof rawCommand === \"string\" ? rawCommand : \"\");\n    if (!normalizedToken) {\n      continue;\n    }\n\n    if (HEX_COLOR_REGEX.test(normalizedToken)) {\n      const normalized = normalizeHexColor(normalizedToken as CommentHexColorCommand);\n      if (normalized) {\n        colorOverride = normalized;\n        continue;\n      }\n    }\n\n    const lower = normalizedToken.toLowerCase();\n\n    if (isLayoutCommand(lower)) {\n      layout = lower;\n      continue;\n    }\n\n    if (isSizeCommand(lower)) {\n      size = lower;\n      continue;\n    }\n\n    if (isFontCommand(lower)) {\n      font = lower;\n      continue;\n    }\n\n    if (isColorCommand(lower)) {\n      colorOverride = COLOR_COMMAND_MAP[lower].toUpperCase();\n      continue;\n    }\n\n    if (lower === \"_live\") {\n      opacityOverride = 0.5;\n      continue;\n    }\n\n    if (lower === \"invisible\") {\n      opacityMultiplier = 0;\n      isInvisible = true;\n      continue;\n    }\n\n    if (lower.startsWith(\"ls:\") || lower.startsWith(\"letterspacing:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseNumericCommandValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          letterSpacing = clampLetterSpacing(numericValue);\n        }\n      }\n      continue;\n    }\n\n    if (lower.startsWith(\"lh:\") || lower.startsWith(\"lineheight:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseLineHeightValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          lineHeight = clampLineHeight(numericValue);\n        }\n      }\n      continue;\n    }\n  }\n\n  const clampedOpacityMultiplier = Math.max(0, Math.min(1, opacityMultiplier));\n  const resolvedColor = (colorOverride ?? context.defaultColor).toUpperCase();\n  const resolvedOpacityOverride =\n    typeof opacityOverride === \"number\" ? Math.max(0, Math.min(1, opacityOverride)) : null;\n\n  return {\n    layout,\n    size,\n    sizeScale: COMMENT_SIZE_SCALE[size],\n    font,\n    fontFamily: FONT_FAMILY_MAP[font],\n    resolvedColor,\n    colorOverride,\n    opacityMultiplier: clampedOpacityMultiplier,\n    opacityOverride: resolvedOpacityOverride,\n    isInvisible,\n    letterSpacing,\n    lineHeight,\n  };\n};\n","const DEFAULT_MAX_LOGS_PER_CATEGORY = 5;\n\nexport interface DebugLoggingOptions {\n  readonly enabled: boolean;\n  readonly maxLogsPerCategory?: number;\n}\n\ntype DebugState = {\n  enabled: boolean;\n  maxLogsPerCategory: number;\n};\n\nconst state: DebugState = {\n  enabled: false,\n  maxLogsPerCategory: DEFAULT_MAX_LOGS_PER_CATEGORY,\n};\n\nconst categoryCounters = new Map<string, number>();\n\nconst normalizeLimit = (limit: number | undefined): number => {\n  if (limit === undefined) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  if (!Number.isFinite(limit)) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  const rounded = Math.max(1, Math.floor(limit));\n  return Math.min(10_000, rounded);\n};\n\nexport const configureDebugLogging = (options: DebugLoggingOptions): void => {\n  state.enabled = Boolean(options.enabled);\n  state.maxLogsPerCategory = normalizeLimit(options.maxLogsPerCategory);\n  if (!state.enabled) {\n    categoryCounters.clear();\n  }\n};\n\nexport const resetDebugCounters = (): void => {\n  categoryCounters.clear();\n};\n\nexport const isDebugLoggingEnabled = (): boolean => state.enabled;\n\nconst shouldEmitLog = (category: string): boolean => {\n  const currentCount = categoryCounters.get(category) ?? 0;\n  if (currentCount >= state.maxLogsPerCategory) {\n    if (currentCount === state.maxLogsPerCategory) {\n      console.debug(`[CommentOverlay][${category}]`, \"Further logs suppressed.\");\n      categoryCounters.set(category, currentCount + 1);\n    }\n    return false;\n  }\n  categoryCounters.set(category, currentCount + 1);\n  return true;\n};\n\nexport const debugLog = (category: string, ...payload: unknown[]): void => {\n  if (!state.enabled) {\n    return;\n  }\n  if (!shouldEmitLog(category)) {\n    return;\n  }\n  console.debug(`[CommentOverlay][${category}]`, ...payload);\n};\n\nexport const formatCommentPreview = (text: string, maxLength = 32): string => {\n  if (text.length <= maxLength) {\n    return text;\n  }\n  return `${text.slice(0, maxLength)}…`;\n};\n","import type {\n  CommentLayoutCommand,\n  RenderStyle,\n  RendererSettings,\n  ScrollDirection,\n} from \"../shared/types\";\nimport { createLogger } from \"../shared/logger\";\nimport { parseCommentCommands } from \"./comment-commands\";\nimport { isDebugLoggingEnabled } from \"../shared/debug\";\n\nconst logger = createLogger(\"CommentEngine:Comment\");\n\ntype TextMeasurementCache = Map<string, number>;\ntype DrawMode = \"fill\" | \"outline\";\n\nconst textMeasurementCaches = new WeakMap<CanvasRenderingContext2D, TextMeasurementCache>();\n\nconst getTextMeasurementCache = (ctx: CanvasRenderingContext2D): TextMeasurementCache => {\n  let cache = textMeasurementCaches.get(ctx);\n  if (!cache) {\n    cache = new Map();\n    textMeasurementCaches.set(ctx, cache);\n  }\n  return cache;\n};\n\nconst measureTextWidth = (ctx: CanvasRenderingContext2D, text: string): number => {\n  if (!ctx) {\n    return 0;\n  }\n  const fontKey = ctx.font ?? \"\";\n  const cacheKey = `${fontKey}::${text}`;\n  const cache = getTextMeasurementCache(ctx);\n  const cached = cache.get(cacheKey);\n  if (cached !== undefined) {\n    return cached;\n  }\n  const width = ctx.measureText(text).width;\n  cache.set(cacheKey, width);\n  return width;\n};\n\nexport const STATIC_VISIBLE_DURATION_MS = 4_000;\n\nconst HEX_COLOR_PATTERN = /^#([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;\n\nconst STATIC_COMMENT_SIDE_MARGIN_PX = 8;\nconst MIN_STATIC_FONT_SIZE_PX = 12;\n\nconst clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nconst expandHex = (fragment: string): string =>\n  fragment.length === 1 ? fragment.repeat(2) : fragment;\n\nconst parseHexComponent = (component: string): number => Number.parseInt(component, 16);\n\nconst resolveFillStyleWithOpacity = (color: string, opacity: number): string => {\n  const match = HEX_COLOR_PATTERN.exec(color);\n  if (!match) {\n    return color;\n  }\n  const body = match[1];\n  let red: number;\n  let green: number;\n  let blue: number;\n  let alpha = 1;\n\n  if (body.length === 3 || body.length === 4) {\n    red = parseHexComponent(expandHex(body[0]));\n    green = parseHexComponent(expandHex(body[1]));\n    blue = parseHexComponent(expandHex(body[2]));\n    if (body.length === 4) {\n      alpha = parseHexComponent(expandHex(body[3])) / 255;\n    }\n  } else {\n    red = parseHexComponent(body.slice(0, 2));\n    green = parseHexComponent(body.slice(2, 4));\n    blue = parseHexComponent(body.slice(4, 6));\n    if (body.length === 8) {\n      alpha = parseHexComponent(body.slice(6, 8)) / 255;\n    }\n  }\n\n  const combinedAlpha = clampOpacity(alpha * clampOpacity(opacity));\n  return `rgba(${red}, ${green}, ${blue}, ${combinedAlpha})`;\n};\n\nexport interface TimeSource {\n  now(): number;\n}\n\nconst createPerformanceTimeSource = (): TimeSource => ({\n  now: () => {\n    if (typeof performance !== \"undefined\" && typeof performance.now === \"function\") {\n      return performance.now();\n    }\n    return Date.now();\n  },\n});\n\nexport const createDefaultTimeSource = (): TimeSource => createPerformanceTimeSource();\n\nexport interface CommentDependencies {\n  timeSource?: TimeSource;\n  settingsVersion?: number;\n}\n\nconst resolveScrollDirection = (input: ScrollDirection | string): ScrollDirection =>\n  input === \"ltr\" ? \"ltr\" : \"rtl\";\n\nconst getDirectionSign = (direction: ScrollDirection): -1 | 1 => (direction === \"ltr\" ? 1 : -1);\n\nexport interface CommentPrepareOptions {\n  visibleWidth: number;\n  virtualExtension: number;\n  maxVisibleDurationMs: number;\n  minVisibleDurationMs: number;\n  maxWidthRatio: number;\n  bufferRatio: number;\n  baseBufferPx: number;\n  entryBufferPx: number;\n}\n\nexport class Comment {\n  readonly text: string;\n  readonly vposMs: number;\n  readonly commands: string[];\n  readonly layout: CommentLayoutCommand;\n  readonly isScrolling: boolean;\n  readonly sizeScale: number;\n  readonly opacityMultiplier: number;\n  readonly opacityOverride: number | null;\n  readonly colorOverride: string | null;\n  readonly isInvisible: boolean;\n\n  x = 0;\n  y = 0;\n  width = 0;\n  height = 0;\n  baseSpeed = 0;\n  speed = 0;\n  lane = -1;\n  color: string;\n  fontSize = 0;\n  fontFamily: string;\n  opacity: number;\n  activationTimeMs: number | null = null;\n  staticExpiryTimeMs: number | null = null;\n  isActive = false;\n  hasShown = false;\n  isPaused = false;\n  lastUpdateTime = 0;\n  reservationWidth = 0;\n  bufferWidth = 0;\n  visibleDurationMs = 0;\n  totalDurationMs = 0;\n  preCollisionDurationMs = 0;\n  speedPixelsPerMs = 0;\n  virtualStartX = 0;\n  exitThreshold = 0;\n  scrollDirection: ScrollDirection = \"rtl\";\n  renderStyle: RenderStyle = \"outline-only\";\n  creationIndex = 0;\n  letterSpacing = 0;\n  lineHeightMultiplier = 1;\n  lineHeightPx = 0;\n  lines: string[] = [];\n  private directionSign: -1 | 1 = -1;\n  private readonly timeSource: TimeSource;\n  private lastSyncedSettingsVersion = -1;\n  private cachedTexture: OffscreenCanvas | null = null;\n  private textureCacheKey = \"\";\n\n  constructor(\n    text: string,\n    vposMs: number,\n    commands: string[] | undefined,\n    settings: RendererSettings,\n    dependencies: CommentDependencies = {},\n  ) {\n    if (typeof text !== \"string\") {\n      throw new Error(\"Comment text must be a string\");\n    }\n    if (!Number.isFinite(vposMs) || vposMs < 0) {\n      throw new Error(\"Comment vposMs must be a non-negative number\");\n    }\n\n    this.text = text;\n    this.vposMs = vposMs;\n    this.commands = Array.isArray(commands) ? [...commands] : [];\n\n    const parsedCommands = parseCommentCommands(this.commands, {\n      defaultColor: settings.commentColor,\n    });\n\n    this.layout = parsedCommands.layout;\n    this.isScrolling = this.layout === \"naka\";\n    this.sizeScale = parsedCommands.sizeScale;\n    this.opacityMultiplier = parsedCommands.opacityMultiplier;\n    this.opacityOverride = parsedCommands.opacityOverride;\n    this.colorOverride = parsedCommands.colorOverride;\n    this.isInvisible = parsedCommands.isInvisible;\n    this.fontFamily = parsedCommands.fontFamily;\n    this.color = parsedCommands.resolvedColor;\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.renderStyle = settings.renderStyle;\n    this.letterSpacing = parsedCommands.letterSpacing;\n    this.lineHeightMultiplier = parsedCommands.lineHeight;\n\n    this.timeSource = dependencies.timeSource ?? createDefaultTimeSource();\n    this.applyScrollDirection(settings.scrollDirection);\n    this.syncWithSettings(settings, dependencies.settingsVersion);\n  }\n\n  prepare(\n    ctx: CanvasRenderingContext2D,\n    visibleWidth: number,\n    canvasHeight: number,\n    options: CommentPrepareOptions,\n  ): void {\n    try {\n      if (!ctx) {\n        throw new Error(\"Canvas context is required\");\n      }\n      if (!Number.isFinite(visibleWidth) || !Number.isFinite(canvasHeight)) {\n        throw new Error(\"Canvas dimensions must be numbers\");\n      }\n      if (!options) {\n        throw new Error(\"Prepare options are required\");\n      }\n\n      const safeVisibleWidth = Math.max(visibleWidth, 1);\n      const baseFontSize = Math.max(24, Math.floor(canvasHeight * 0.05));\n      const scaledFontSize = Math.max(24, Math.floor(baseFontSize * this.sizeScale));\n      this.fontSize = scaledFontSize;\n      ctx.font = `${this.fontSize}px ${this.fontFamily}`;\n      const rawLines = this.text.includes(\"\\n\") ? this.text.split(/\\r?\\n/) : [this.text];\n      this.lines = rawLines.length > 0 ? rawLines : [\"\"];\n      this.updateTextMetrics(ctx);\n\n      const isStaticTopOrBottom =\n        !this.isScrolling && (this.layout === \"ue\" || this.layout === \"shita\");\n      if (isStaticTopOrBottom) {\n        const maxStaticWidth = Math.max(1, safeVisibleWidth - STATIC_COMMENT_SIDE_MARGIN_PX * 2);\n        if (this.width > maxStaticWidth) {\n          const minimumFontSize = Math.max(\n            MIN_STATIC_FONT_SIZE_PX,\n            Math.min(this.fontSize, Math.floor(baseFontSize * 0.6)),\n          );\n          const shrinkFactor = maxStaticWidth / Math.max(this.width, 1);\n          const initialShrink = Math.max(\n            minimumFontSize,\n            Math.floor(this.fontSize * Math.min(shrinkFactor, 1)),\n          );\n          if (initialShrink < this.fontSize) {\n            this.fontSize = initialShrink;\n            ctx.font = `${this.fontSize}px ${this.fontFamily}`;\n            this.updateTextMetrics(ctx);\n          }\n          let iteration = 0;\n          while (this.width > maxStaticWidth && this.fontSize > minimumFontSize && iteration < 5) {\n            const currentShrink = maxStaticWidth / Math.max(this.width, 1);\n            const proposedSize = Math.max(\n              minimumFontSize,\n              Math.floor(this.fontSize * Math.max(currentShrink, 0.7)),\n            );\n            if (proposedSize >= this.fontSize) {\n              this.fontSize = Math.max(minimumFontSize, this.fontSize - 1);\n            } else {\n              this.fontSize = proposedSize;\n            }\n            ctx.font = `${this.fontSize}px ${this.fontFamily}`;\n            this.updateTextMetrics(ctx);\n            iteration += 1;\n          }\n        }\n      }\n\n      if (!this.isScrolling) {\n        this.bufferWidth = 0;\n        const margin = isStaticTopOrBottom ? STATIC_COMMENT_SIDE_MARGIN_PX : 0;\n        const centeredX = Math.max((safeVisibleWidth - this.width) / 2, margin);\n        const maxStart = Math.max(margin, safeVisibleWidth - this.width - margin);\n        const clampedX = Math.min(centeredX, Math.max(maxStart, margin));\n        this.virtualStartX = clampedX;\n        this.x = clampedX;\n        this.baseSpeed = 0;\n        this.speed = 0;\n        this.speedPixelsPerMs = 0;\n        this.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n        this.preCollisionDurationMs = STATIC_VISIBLE_DURATION_MS;\n        this.totalDurationMs = STATIC_VISIBLE_DURATION_MS;\n        this.reservationWidth = this.width;\n        this.staticExpiryTimeMs = this.vposMs + STATIC_VISIBLE_DURATION_MS;\n        this.lastUpdateTime = this.timeSource.now();\n        this.isPaused = false;\n        return;\n      }\n\n      this.staticExpiryTimeMs = null;\n      const maxReservationWidth = measureTextWidth(ctx, \"??\".repeat(150));\n\n      const bufferFromWidth = this.width * Math.max(options.bufferRatio, 0);\n      this.bufferWidth = Math.max(options.baseBufferPx, bufferFromWidth);\n      const entryBuffer = Math.max(options.entryBufferPx, this.bufferWidth);\n\n      const direction = this.scrollDirection;\n\n      const startLeft =\n        direction === \"rtl\"\n          ? safeVisibleWidth + options.virtualExtension\n          : -this.width - this.bufferWidth - options.virtualExtension;\n      const exitLeft =\n        direction === \"rtl\"\n          ? -this.width - this.bufferWidth - entryBuffer\n          : safeVisibleWidth + entryBuffer;\n      const trailingBoundary = direction === \"rtl\" ? safeVisibleWidth + entryBuffer : -entryBuffer;\n      const trailingEdgeAtStart =\n        direction === \"rtl\"\n          ? startLeft + this.width + this.bufferWidth\n          : startLeft - this.bufferWidth;\n\n      this.virtualStartX = startLeft;\n      this.x = startLeft;\n      this.exitThreshold = exitLeft;\n\n      const widthRatio = safeVisibleWidth > 0 ? this.width / safeVisibleWidth : 0;\n      const hasFixedDuration = options.maxVisibleDurationMs === options.minVisibleDurationMs;\n      let visibleDurationMs = options.maxVisibleDurationMs;\n      if (!hasFixedDuration && widthRatio > 1) {\n        const clampedRatio = Math.min(widthRatio, options.maxWidthRatio);\n        const adjustedDuration = options.maxVisibleDurationMs / Math.max(clampedRatio, 1);\n        visibleDurationMs = Math.max(options.minVisibleDurationMs, Math.floor(adjustedDuration));\n      }\n\n      const visibleDistance = safeVisibleWidth + this.width + this.bufferWidth + entryBuffer;\n      const safeVisibleDuration = Math.max(visibleDurationMs, 1);\n      const pixelsPerMs = visibleDistance / safeVisibleDuration;\n      const pixelsPerFrame = (pixelsPerMs * 1000) / 60;\n      this.baseSpeed = pixelsPerFrame;\n      this.speed = this.baseSpeed;\n      this.speedPixelsPerMs = pixelsPerMs;\n\n      const travelDistance = Math.abs(exitLeft - startLeft);\n      const preCollisionDistance =\n        direction === \"rtl\"\n          ? Math.max(0, trailingEdgeAtStart - trailingBoundary)\n          : Math.max(0, trailingBoundary - trailingEdgeAtStart);\n      const safePixelsPerMs = Math.max(pixelsPerMs, Number.EPSILON);\n\n      this.visibleDurationMs = visibleDurationMs;\n      this.preCollisionDurationMs = Math.max(0, Math.ceil(preCollisionDistance / safePixelsPerMs));\n      this.totalDurationMs = Math.max(\n        this.preCollisionDurationMs,\n        Math.ceil(travelDistance / safePixelsPerMs),\n      );\n\n      const reservationBase = this.width + this.bufferWidth + entryBuffer;\n      this.reservationWidth = Math.min(maxReservationWidth, reservationBase);\n      this.lastUpdateTime = this.timeSource.now();\n      this.isPaused = false;\n    } catch (error) {\n      logger.error(\"Comment.prepare\", error as Error, {\n        text: this.text,\n        visibleWidth,\n        canvasHeight,\n        hasContext: Boolean(ctx),\n      });\n      throw error;\n    }\n  }\n\n  update(playbackRate = 1.0, isPaused = false): void {\n    try {\n      if (!this.isActive) {\n        this.isPaused = isPaused;\n        return;\n      }\n\n      const currentTime = this.timeSource.now();\n\n      if (!this.isScrolling) {\n        this.isPaused = isPaused;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      if (isPaused) {\n        this.isPaused = true;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      const deltaTime = (currentTime - this.lastUpdateTime) / (1000 / 60);\n      this.speed = this.baseSpeed * playbackRate;\n      this.x += this.speed * deltaTime * this.directionSign;\n      const hasExited =\n        (this.scrollDirection === \"rtl\" && this.x <= this.exitThreshold) ||\n        (this.scrollDirection === \"ltr\" && this.x >= this.exitThreshold);\n      if (hasExited) {\n        this.isActive = false;\n      }\n      this.lastUpdateTime = currentTime;\n      this.isPaused = false;\n    } catch (error) {\n      logger.error(\"Comment.update\", error as Error, {\n        text: this.text,\n        playbackRate,\n        isPaused,\n        isActive: this.isActive,\n      });\n    }\n  }\n\n  private generateTextureCacheKey(): string {\n    // v2: 行頭スペース処理を追加したためキャッシュを無効化\n    return `v2::${this.text}::${this.fontSize}::${this.fontFamily}::${this.color}::${this.opacity}::${this.renderStyle}::${this.letterSpacing}::${this.lines.length}`;\n  }\n\n  // デバッグ用：キャッシュ統計\n  private static cacheStats = {\n    hits: 0,\n    misses: 0,\n    creates: 0,\n    fallbacks: 0,\n    outlineCallsInCache: 0,\n    fillCallsInCache: 0,\n    outlineCallsInFallback: 0,\n    fillCallsInFallback: 0,\n    letterSpacingComments: 0,\n    normalComments: 0,\n    multiLineComments: 0,\n    totalCharactersDrawn: 0,\n    lastReported: 0,\n  };\n\n  private static reportCacheStats(): void {\n    if (!isDebugLoggingEnabled()) {\n      return;\n    }\n    const now = performance.now();\n    if (now - Comment.cacheStats.lastReported > 5000) {\n      const total = Comment.cacheStats.hits + Comment.cacheStats.misses;\n      const hitRate = total > 0 ? (Comment.cacheStats.hits / total) * 100 : 0;\n      const avgCharsPerComment =\n        Comment.cacheStats.creates > 0\n          ? (Comment.cacheStats.totalCharactersDrawn / Comment.cacheStats.creates).toFixed(1)\n          : \"0\";\n      const totalOutlineCalls =\n        Comment.cacheStats.outlineCallsInCache + Comment.cacheStats.outlineCallsInFallback;\n      const totalFillCalls =\n        Comment.cacheStats.fillCallsInCache + Comment.cacheStats.fillCallsInFallback;\n      console.log(\n        `[TextureCache Stats]`,\n        `\\n  Cache: Hits=${Comment.cacheStats.hits}, Misses=${Comment.cacheStats.misses}, Hit Rate=${hitRate.toFixed(1)}%`,\n        `\\n  Creates: ${Comment.cacheStats.creates}, Fallbacks: ${Comment.cacheStats.fallbacks}`,\n        `\\n  Comments: Normal=${Comment.cacheStats.normalComments}, LetterSpacing=${Comment.cacheStats.letterSpacingComments}, MultiLine=${Comment.cacheStats.multiLineComments}`,\n        `\\n  Draw Calls: Outline=${totalOutlineCalls}, Fill=${totalFillCalls}`,\n        `\\n  Avg Characters/Comment: ${avgCharsPerComment}`,\n      );\n      Comment.cacheStats.lastReported = now;\n    }\n  }\n\n  private isOffscreenCanvasSupported(): boolean {\n    return typeof OffscreenCanvas !== \"undefined\";\n  }\n\n  private createTextureCanvas(ctx: CanvasRenderingContext2D): OffscreenCanvas | null {\n    if (!this.isOffscreenCanvasSupported()) {\n      return null;\n    }\n\n    // 統計収集\n    const hasLetterSpacing = Math.abs(this.letterSpacing) >= Number.EPSILON;\n    const isMultiLine = this.lines.length > 1;\n    if (hasLetterSpacing) {\n      Comment.cacheStats.letterSpacingComments++;\n    }\n    if (isMultiLine) {\n      Comment.cacheStats.multiLineComments++;\n    }\n    if (!hasLetterSpacing && !isMultiLine) {\n      Comment.cacheStats.normalComments++;\n    }\n    Comment.cacheStats.totalCharactersDrawn += this.text.length;\n\n    // テクスチャサイズは実際のコメントサイズより少し大きめに取る（影やエフェクトのため）\n    const padding = Math.max(10, this.fontSize * 0.5);\n    const textureWidth = Math.ceil(this.width + padding * 2);\n    const textureHeight = Math.ceil(this.height + padding * 2);\n\n    const offscreen = new OffscreenCanvas(textureWidth, textureHeight);\n    const offscreenCtx = offscreen.getContext(\"2d\");\n    if (!offscreenCtx) {\n      return null;\n    }\n\n    // オフスクリーンキャンバスに描画\n    offscreenCtx.save();\n    offscreenCtx.font = `${this.fontSize}px ${this.fontFamily}`;\n    const effectiveOpacity = clampOpacity(this.opacity);\n    const drawX = padding; // パディング分オフセット\n    const linesToRender = this.lines.length > 0 ? this.lines : [this.text];\n    const lineAdvance =\n      this.lines.length > 1 && this.lineHeightPx > 0 ? this.lineHeightPx : this.fontSize;\n    const baselineStart = padding + this.fontSize;\n    const drawSegment = this.createSegmentDrawer(offscreenCtx, ctx, \"cache\", drawX);\n\n    const outlineOffsets = this.getOutlineOffsets();\n\n    const drawOutline = (): void => {\n      const outlineAlpha = clampOpacity(effectiveOpacity * 0.6);\n      offscreenCtx.save();\n      offscreenCtx.fillStyle = `rgba(0, 0, 0, ${outlineAlpha})`;\n      for (const [offsetX, offsetY] of outlineOffsets) {\n        linesToRender.forEach((line, index) => {\n          const baseline = baselineStart + index * lineAdvance + offsetY;\n          drawSegment(line, baseline, \"outline\", offsetX);\n        });\n      }\n      offscreenCtx.restore();\n    };\n\n    const drawFill = (fillStyle: string): void => {\n      offscreenCtx.save();\n      offscreenCtx.fillStyle = fillStyle;\n      linesToRender.forEach((line, index) => {\n        const baseline = baselineStart + index * lineAdvance;\n        drawSegment(line, baseline, \"fill\");\n      });\n      offscreenCtx.restore();\n    };\n\n    drawOutline();\n\n    if (this.renderStyle === \"classic\") {\n      const baseShadowOffset = Math.max(1, this.fontSize * 0.04);\n      const baseShadowBlur = this.fontSize * 0.18;\n      type ShadowLayer = Readonly<{\n        offsetXMultiplier: number;\n        offsetYMultiplier: number;\n        blurMultiplier: number;\n        alpha: number;\n        rgb: string;\n      }>;\n      const shadowLayers: ReadonlyArray<ShadowLayer> = [\n        {\n          offsetXMultiplier: 0.9,\n          offsetYMultiplier: 1.1,\n          blurMultiplier: 0.55,\n          alpha: 0.52,\n          rgb: \"20, 28, 40\",\n        },\n        {\n          offsetXMultiplier: 2.4,\n          offsetYMultiplier: 2.7,\n          blurMultiplier: 1.45,\n          alpha: 0.32,\n          rgb: \"0, 0, 0\",\n        },\n        {\n          offsetXMultiplier: -0.7,\n          offsetYMultiplier: -0.6,\n          blurMultiplier: 0.4,\n          alpha: 0.42,\n          rgb: \"255, 255, 255\",\n        },\n      ];\n\n      shadowLayers.forEach((layer) => {\n        const effectiveShadowAlpha = clampOpacity(layer.alpha * effectiveOpacity);\n        offscreenCtx.save();\n        offscreenCtx.shadowColor = `rgba(${layer.rgb}, ${effectiveShadowAlpha})`;\n        offscreenCtx.shadowBlur = baseShadowBlur * layer.blurMultiplier;\n        offscreenCtx.shadowOffsetX = baseShadowOffset * layer.offsetXMultiplier;\n        offscreenCtx.shadowOffsetY = baseShadowOffset * layer.offsetYMultiplier;\n        offscreenCtx.fillStyle = \"rgba(0, 0, 0, 0)\";\n        linesToRender.forEach((line, index) => {\n          const baseline = baselineStart + index * lineAdvance;\n          drawSegment(line, baseline, \"fill\");\n        });\n        offscreenCtx.restore();\n      });\n    }\n\n    const resolvedFillStyle = resolveFillStyleWithOpacity(this.color, effectiveOpacity);\n    drawFill(resolvedFillStyle);\n\n    offscreenCtx.restore();\n    return offscreen;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, interpolatedX: number | null = null): void {\n    try {\n      if (!this.isActive || !ctx) {\n        return;\n      }\n\n      // テクスチャキャッシュを使用\n      const currentCacheKey = this.generateTextureCacheKey();\n      if (this.textureCacheKey !== currentCacheKey || !this.cachedTexture) {\n        // キャッシュが無効または古い場合は再生成\n        Comment.cacheStats.misses++;\n        Comment.cacheStats.creates++;\n        this.cachedTexture = this.createTextureCanvas(ctx);\n        this.textureCacheKey = currentCacheKey;\n      } else {\n        Comment.cacheStats.hits++;\n      }\n\n      // テクスチャが利用可能な場合はdrawImageで描画\n      if (this.cachedTexture) {\n        const drawX = interpolatedX ?? this.x;\n        const padding = Math.max(10, this.fontSize * 0.5);\n        ctx.drawImage(this.cachedTexture, drawX - padding, this.y - padding);\n        Comment.reportCacheStats();\n        return;\n      }\n\n      // フォールバック使用\n      Comment.cacheStats.fallbacks++;\n\n      // フォールバック: 通常の描画処理\n\n      ctx.save();\n      ctx.font = `${this.fontSize}px ${this.fontFamily}`;\n      const effectiveOpacity = clampOpacity(this.opacity);\n      const drawX = interpolatedX ?? this.x;\n      const linesToRender = this.lines.length > 0 ? this.lines : [this.text];\n      const lineAdvance =\n        this.lines.length > 1 && this.lineHeightPx > 0 ? this.lineHeightPx : this.fontSize;\n      const baselineStart = this.y + this.fontSize;\n\n      const drawSegment = this.createSegmentDrawer(ctx, ctx, \"fallback\", drawX);\n      const outlineOffsets = this.getOutlineOffsets();\n\n      const drawOutline = (): void => {\n        const outlineAlpha = clampOpacity(effectiveOpacity * 0.6);\n        ctx.save();\n        ctx.fillStyle = `rgba(0, 0, 0, ${outlineAlpha})`;\n        for (const [offsetX, offsetY] of outlineOffsets) {\n          linesToRender.forEach((line, index) => {\n            const baseline = baselineStart + index * lineAdvance + offsetY;\n            drawSegment(line, baseline, \"outline\", offsetX);\n          });\n        }\n        ctx.restore();\n      };\n\n      const drawFill = (fillStyle: string): void => {\n        ctx.save();\n        ctx.fillStyle = fillStyle;\n        linesToRender.forEach((line, index) => {\n          const baseline = baselineStart + index * lineAdvance;\n          drawSegment(line, baseline, \"fill\");\n        });\n        ctx.restore();\n      };\n\n      drawOutline();\n\n      if (this.renderStyle === \"classic\") {\n        const baseShadowOffset = Math.max(1, this.fontSize * 0.04);\n        const baseShadowBlur = this.fontSize * 0.18;\n        type ShadowLayer = Readonly<{\n          offsetXMultiplier: number;\n          offsetYMultiplier: number;\n          blurMultiplier: number;\n          alpha: number;\n          rgb: string;\n        }>;\n        const shadowLayers: ReadonlyArray<ShadowLayer> = [\n          {\n            offsetXMultiplier: 0.9,\n            offsetYMultiplier: 1.1,\n            blurMultiplier: 0.55,\n            alpha: 0.52,\n            rgb: \"20, 28, 40\",\n          },\n          {\n            offsetXMultiplier: 2.4,\n            offsetYMultiplier: 2.7,\n            blurMultiplier: 1.45,\n            alpha: 0.32,\n            rgb: \"0, 0, 0\",\n          },\n          {\n            offsetXMultiplier: -0.7,\n            offsetYMultiplier: -0.6,\n            blurMultiplier: 0.4,\n            alpha: 0.42,\n            rgb: \"255, 255, 255\",\n          },\n        ];\n\n        shadowLayers.forEach((layer) => {\n          const effectiveShadowAlpha = clampOpacity(layer.alpha * effectiveOpacity);\n          ctx.save();\n          ctx.shadowColor = `rgba(${layer.rgb}, ${effectiveShadowAlpha})`;\n          ctx.shadowBlur = baseShadowBlur * layer.blurMultiplier;\n          ctx.shadowOffsetX = baseShadowOffset * layer.offsetXMultiplier;\n          ctx.shadowOffsetY = baseShadowOffset * layer.offsetYMultiplier;\n          ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n          linesToRender.forEach((line, index) => {\n            const baseline = baselineStart + index * lineAdvance;\n            drawSegment(line, baseline, \"fill\");\n          });\n          ctx.restore();\n        });\n      }\n\n      const resolvedFillStyle = resolveFillStyleWithOpacity(this.color, effectiveOpacity);\n      drawFill(resolvedFillStyle);\n\n      ctx.restore();\n      Comment.reportCacheStats();\n    } catch (error) {\n      logger.error(\"Comment.draw\", error as Error, {\n        text: this.text,\n        isActive: this.isActive,\n        hasContext: Boolean(ctx),\n        interpolatedX,\n      });\n    }\n  }\n\n  syncWithSettings(settings: RendererSettings, settingsVersion?: number): void {\n    const hasSyncedVersion =\n      typeof settingsVersion === \"number\" && settingsVersion === this.lastSyncedSettingsVersion;\n    if (hasSyncedVersion) {\n      return;\n    }\n    this.color = this.getEffectiveColor(settings.commentColor);\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.applyScrollDirection(settings.scrollDirection);\n    this.renderStyle = settings.renderStyle;\n    if (typeof settingsVersion === \"number\") {\n      this.lastSyncedSettingsVersion = settingsVersion;\n    }\n  }\n\n  getEffectiveColor(defaultColor: string): string {\n    const candidate = this.colorOverride ?? defaultColor;\n    if (typeof candidate !== \"string\" || candidate.length === 0) {\n      return defaultColor;\n    }\n    return candidate.toUpperCase();\n  }\n\n  getEffectiveOpacity(defaultOpacity: number): number {\n    if (typeof this.opacityOverride === \"number\") {\n      return clampOpacity(this.opacityOverride);\n    }\n    const scaled = defaultOpacity * this.opacityMultiplier;\n    if (!Number.isFinite(scaled)) {\n      return 0;\n    }\n    return clampOpacity(scaled);\n  }\n\n  markActivated(atTimeMs: number): void {\n    this.activationTimeMs = atTimeMs;\n  }\n\n  clearActivation(): void {\n    this.activationTimeMs = null;\n    if (!this.isScrolling) {\n      this.staticExpiryTimeMs = null;\n    }\n    // テクスチャキャッシュをクリア\n    this.cachedTexture = null;\n    this.textureCacheKey = \"\";\n  }\n\n  hasStaticExpired(currentTimeMs: number): boolean {\n    if (this.isScrolling) {\n      return false;\n    }\n    if (this.staticExpiryTimeMs === null) {\n      return false;\n    }\n    return currentTimeMs >= this.staticExpiryTimeMs;\n  }\n\n  getDirectionSign(): -1 | 1 {\n    return this.directionSign;\n  }\n\n  private applyScrollDirection(direction: ScrollDirection | string): void {\n    const resolved = resolveScrollDirection(direction);\n    this.scrollDirection = resolved;\n    this.directionSign = getDirectionSign(resolved);\n  }\n\n  private createSegmentDrawer(\n    targetCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n    measurementCtx: CanvasRenderingContext2D,\n    statsTarget: \"cache\" | \"fallback\",\n    baseDrawX: number,\n  ): (line: string, baselineY: number, mode: DrawMode, offsetX?: number) => void {\n    return (line, baselineY, mode, offsetX = 0) => {\n      if (line.length === 0) {\n        return;\n      }\n      const leadingSpaces = line.match(/^[\\u3000\\u00A0]+/);\n      const leadingSpaceCount = leadingSpaces ? leadingSpaces[0].length : 0;\n      const leadingSpaceOffset =\n        leadingSpaceCount > 0 ? measureTextWidth(measurementCtx, leadingSpaces![0]) : 0;\n      const effectiveDrawX = baseDrawX + leadingSpaceOffset + offsetX;\n      const trimmedLine = leadingSpaceCount > 0 ? line.substring(leadingSpaceCount) : line;\n\n      const recordDraw = (): void => {\n        if (statsTarget === \"cache\") {\n          if (mode === \"outline\") {\n            Comment.cacheStats.outlineCallsInCache++;\n          } else {\n            Comment.cacheStats.fillCallsInCache++;\n          }\n        } else if (mode === \"outline\") {\n          Comment.cacheStats.outlineCallsInFallback++;\n        } else {\n          Comment.cacheStats.fillCallsInFallback++;\n        }\n      };\n\n      if (Math.abs(this.letterSpacing) < Number.EPSILON) {\n        recordDraw();\n        targetCtx.fillText(trimmedLine, effectiveDrawX, baselineY);\n        return;\n      }\n\n      let cursorX = effectiveDrawX;\n      for (let index = 0; index < trimmedLine.length; index += 1) {\n        const char = trimmedLine[index];\n        recordDraw();\n        targetCtx.fillText(char, cursorX, baselineY);\n        const advance = measureTextWidth(measurementCtx, char);\n        cursorX += advance;\n        if (index < trimmedLine.length - 1) {\n          cursorX += this.letterSpacing;\n        }\n      }\n    };\n  }\n\n  private getOutlineOffsets(): Array<[number, number]> {\n    const outlineThickness = Math.max(1, Math.round(this.fontSize * 0.08));\n    const offsets: Array<[number, number]> = [\n      [-outlineThickness, 0],\n      [outlineThickness, 0],\n      [0, -outlineThickness],\n      [0, outlineThickness],\n    ];\n    if (outlineThickness > 1) {\n      const diagonal = Math.max(1, Math.round(outlineThickness * 0.7));\n      offsets.push(\n        [-diagonal, -diagonal],\n        [-diagonal, diagonal],\n        [diagonal, -diagonal],\n        [diagonal, diagonal],\n      );\n    }\n    return offsets;\n  }\n\n  private updateTextMetrics(ctx: CanvasRenderingContext2D): void {\n    let maxLineWidth = 0;\n    const effectiveLetterSpacing = this.letterSpacing;\n    for (const line of this.lines) {\n      const baseWidth = measureTextWidth(ctx, line);\n      const extraSpacing = line.length > 1 ? effectiveLetterSpacing * (line.length - 1) : 0;\n      const totalWidth = Math.max(0, baseWidth + extraSpacing);\n      if (totalWidth > maxLineWidth) {\n        maxLineWidth = totalWidth;\n      }\n    }\n    this.width = maxLineWidth;\n    const computedLineHeightPx = Math.max(1, Math.floor(this.fontSize * this.lineHeightMultiplier));\n    this.lineHeightPx = computedLineHeightPx;\n    const additionalHeight =\n      this.lines.length > 1 ? (this.lines.length - 1) * computedLineHeightPx : 0;\n    this.height = this.fontSize + additionalHeight;\n  }\n}\n","import type { RendererSettings } from \"../shared/types\";\n\ntype ReadonlySettings = {\n  readonly [K in keyof RendererSettings]: RendererSettings[K] extends\n    | string\n    | number\n    | boolean\n    | null\n    | undefined\n    ? RendererSettings[K]\n    : ReadonlyArray<string>;\n};\n\nexport const NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS = 4_000;\n\nconst BASE_SETTINGS: RendererSettings = {\n  commentColor: \"#FFFFFF\",\n  commentOpacity: 1,\n  isCommentVisible: true,\n  useContainerResizeObserver: true,\n  ngWords: [],\n  ngRegexps: [],\n  scrollDirection: \"rtl\",\n  renderStyle: \"outline-only\",\n  syncMode: \"raf\",\n  scrollVisibleDurationMs: NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS,\n  useFixedLaneCount: false,\n  fixedLaneCount: 12,\n  useDprScaling: true,\n};\n\nexport const DEFAULT_RENDERER_SETTINGS: ReadonlySettings = BASE_SETTINGS;\n\nexport const cloneDefaultSettings = (): RendererSettings => ({\n  ...BASE_SETTINGS,\n  ngWords: [...BASE_SETTINGS.ngWords],\n  ngRegexps: [...BASE_SETTINGS.ngRegexps],\n});\n\nexport const COMMENT_OVERLAY_VERSION = \"v2.4.1\";\n","import { cloneDefaultSettings } from \"../config/default-settings\";\nimport type { RendererSettings } from \"../shared/types\";\nimport {\n  Comment,\n  type CommentDependencies,\n  type CommentPrepareOptions,\n  type TimeSource,\n  createDefaultTimeSource,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"./comment\";\nimport { createLogger, type Logger } from \"../shared/logger\";\nimport {\n  configureDebugLogging,\n  debugLog,\n  formatCommentPreview,\n  isDebugLoggingEnabled,\n} from \"../shared/debug\";\nimport type { DebugLoggingOptions } from \"../shared/debug\";\n\nexport interface CommentRendererConfig {\n  loggerNamespace?: string;\n  timeSource?: TimeSource;\n  animationFrameProvider?: AnimationFrameProvider;\n  createCanvasElement?: () => HTMLCanvasElement;\n  debug?: DebugLoggingOptions;\n}\n\nexport interface CommentRendererInitializeOptions {\n  video: HTMLVideoElement;\n  container?: HTMLElement | null;\n}\n\nexport interface AnimationFrameProvider {\n  request(callback: FrameRequestCallback): ReturnType<typeof setTimeout>;\n  cancel(handle: ReturnType<typeof setTimeout>): void;\n}\n\ntype VideoFrameCallbackMetadataLike = {\n  readonly mediaTime?: number;\n};\n\ntype RequestVideoFrameCallback = (\n  callback: (now: DOMHighResTimeStamp, metadata: VideoFrameCallbackMetadataLike) => void,\n) => number;\n\ntype CancelVideoFrameCallback = (handle: number) => void;\n\ninterface LaneReservation {\n  comment: Comment;\n  startTime: number;\n  endTime: number;\n  totalEndTime: number;\n  startLeft: number;\n  width: number;\n  speed: number;\n  buffer: number;\n  directionSign: -1 | 1;\n}\n\ninterface StaticLaneReservation {\n  comment: Comment;\n  releaseTime: number;\n  yStart: number;\n  yEnd: number;\n  lane: number;\n}\n\nconst toMilliseconds = (seconds: number): number => seconds * 1000;\nconst sanitizeVposMs = (value: number): number | null => {\n  if (!Number.isFinite(value)) {\n    return null;\n  }\n  if (value < 0) {\n    return null;\n  }\n  return Math.round(value);\n};\nconst MAX_VISIBLE_DURATION_MS = 4_000;\nconst MIN_VISIBLE_DURATION_MS = 1_800;\nconst MAX_COMMENT_WIDTH_RATIO = 3;\nconst COLLISION_BUFFER_RATIO = 0.25;\nconst BASE_COLLISION_BUFFER_PX = 32;\nconst ENTRY_BUFFER_PX = 48;\nconst RESERVATION_TIME_MARGIN_MS = 120;\nconst FINAL_PHASE_THRESHOLD_MS = 4_000;\nconst FINAL_PHASE_MIN_GAP_MS = 120;\nconst FINAL_PHASE_MAX_GAP_MS = 800;\nconst FINAL_PHASE_ORDER_EPSILON_MS = 2;\nconst FINAL_PHASE_MIN_WINDOW_MS = 4_000;\n// シーク後も画面上に残る可能性があるコメントを拾えるよう、可視時間と静止時間の合計を参照する\nconst ACTIVE_WINDOW_MS = STATIC_VISIBLE_DURATION_MS + MAX_VISIBLE_DURATION_MS;\nconst VIRTUAL_CANVAS_EXTENSION_PX = 1_000;\nconst MIN_LANE_COUNT = 1;\nconst DEFAULT_LANE_COUNT = 12;\nconst MIN_FONT_SIZE_PX = 24;\nconst EDGE_EPSILON = 1e-3;\nconst SEEK_DIRECTION_EPSILON_MS = 50;\nconst STATIC_COMMENT_VERTICAL_PADDING_RATIO = 0.05;\nconst STATIC_COMMENT_MIN_VERTICAL_PADDING_PX = 10;\n\nconst clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 1;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nconst calculateStaticCommentVerticalPadding = (fontSize: number): number => {\n  return Math.max(\n    STATIC_COMMENT_MIN_VERTICAL_PADDING_PX,\n    Math.floor(fontSize * STATIC_COMMENT_VERTICAL_PADDING_RATIO),\n  );\n};\n\nconst normalizeSettings = (settings: RendererSettings): RendererSettings => {\n  const rawDuration = settings.scrollVisibleDurationMs;\n  const normalizedDuration =\n    rawDuration === null || rawDuration === undefined\n      ? null\n      : Number.isFinite(rawDuration)\n        ? Math.max(1, Math.floor(rawDuration))\n        : null;\n\n  const base: RendererSettings = {\n    ...settings,\n    scrollDirection: settings.scrollDirection === \"ltr\" ? \"ltr\" : \"rtl\",\n    commentOpacity: clampOpacity(settings.commentOpacity),\n    renderStyle: settings.renderStyle === \"classic\" ? \"classic\" : \"outline-only\",\n    scrollVisibleDurationMs: normalizedDuration,\n    syncMode: settings.syncMode === \"video-frame\" ? \"video-frame\" : \"raf\",\n    useDprScaling: Boolean(settings.useDprScaling),\n  };\n  return base;\n};\n\nexport const createDefaultAnimationFrameProvider = (\n  timeSource: TimeSource,\n): AnimationFrameProvider => {\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.requestAnimationFrame === \"function\" &&\n    typeof window.cancelAnimationFrame === \"function\"\n  ) {\n    return {\n      request: (callback) => window.requestAnimationFrame(callback),\n      cancel: (handle) => window.cancelAnimationFrame(handle),\n    };\n  }\n  return {\n    request: (callback) => {\n      const timeoutId = globalThis.setTimeout(() => {\n        callback(timeSource.now());\n      }, 16);\n      return timeoutId;\n    },\n    cancel: (handle) => {\n      globalThis.clearTimeout(handle);\n    },\n  };\n};\n\nconst createBrowserCanvasFactory = (): (() => HTMLCanvasElement) => {\n  if (typeof document === \"undefined\") {\n    return () => {\n      throw new Error(\n        \"Document is not available. Provide a custom createCanvasElement implementation.\",\n      );\n    };\n  }\n  return () => document.createElement(\"canvas\");\n};\n\nconst isRendererSettings = (input: unknown): input is RendererSettings => {\n  if (!input || typeof input !== \"object\") {\n    return false;\n  }\n  const candidate = input as Record<string, unknown>;\n  return (\n    typeof candidate.commentColor === \"string\" &&\n    typeof candidate.commentOpacity === \"number\" &&\n    typeof candidate.isCommentVisible === \"boolean\"\n  );\n};\n\nexport class CommentRenderer {\n  private _settings: RendererSettings;\n  private readonly comments: Comment[] = [];\n  private readonly activeComments = new Set<Comment>();\n  private readonly reservedLanes = new Map<number, LaneReservation[]>();\n  private readonly topStaticLaneReservations: StaticLaneReservation[] = [];\n  private readonly bottomStaticLaneReservations: StaticLaneReservation[] = [];\n  private readonly log: Logger;\n  private readonly timeSource: TimeSource;\n  private readonly animationFrameProvider: AnimationFrameProvider;\n  private readonly createCanvasElement: () => HTMLCanvasElement;\n  private readonly commentDependencies: CommentDependencies;\n  private settingsVersion = 0;\n  private normalizedNgWords: string[] = [];\n  private compiledNgRegexps: RegExp[] = [];\n  private canvas: HTMLCanvasElement | null = null;\n  private ctx: CanvasRenderingContext2D | null = null;\n  private videoElement: HTMLVideoElement | null = null;\n  private containerElement: HTMLElement | null = null;\n  private fullscreenActive = false;\n  private laneCount = DEFAULT_LANE_COUNT;\n  private laneHeight = 0;\n  private displayWidth = 0;\n  private displayHeight = 0;\n  private canvasDpr = 1;\n  private currentTime = 0;\n  private duration = 0;\n  private playbackRate = 1;\n  private isPlaying = true;\n  private isStalled = false;\n  private lastDrawTime = 0;\n  private finalPhaseActive = false;\n  private finalPhaseStartTime: number | null = null;\n  private finalPhaseScheduleDirty = false;\n  private playbackHasBegun = false;\n  private skipDrawingForCurrentFrame = false;\n  private pendingInitialSync = false;\n  private readonly finalPhaseVposOverrides = new Map<Comment, number>();\n  private frameId: ReturnType<typeof setTimeout> | null = null;\n  private videoFrameHandle: number | null = null;\n  private resizeObserver: ResizeObserver | null = null;\n  private resizeObserverTarget: Element | null = null;\n  private readonly isResizeObserverAvailable = typeof ResizeObserver !== \"undefined\";\n  private readonly cleanupTasks: Array<() => void> = [];\n  private commentSequence = 0;\n\n  constructor(settings: RendererSettings | null, config?: CommentRendererConfig);\n  constructor(config?: CommentRendererConfig);\n  constructor(\n    settingsOrConfig: RendererSettings | CommentRendererConfig | null = null,\n    maybeConfig: CommentRendererConfig | undefined = undefined,\n  ) {\n    let baseSettings: RendererSettings;\n    let config: CommentRendererConfig;\n\n    if (isRendererSettings(settingsOrConfig)) {\n      baseSettings = normalizeSettings({ ...(settingsOrConfig as RendererSettings) });\n      config = maybeConfig ?? {};\n    } else {\n      const configCandidate = settingsOrConfig ?? maybeConfig ?? {};\n      config =\n        typeof configCandidate === \"object\" ? (configCandidate as CommentRendererConfig) : {};\n      baseSettings = normalizeSettings(cloneDefaultSettings());\n    }\n\n    this._settings = normalizeSettings(baseSettings);\n    this.timeSource = config.timeSource ?? createDefaultTimeSource();\n    this.animationFrameProvider =\n      config.animationFrameProvider ?? createDefaultAnimationFrameProvider(this.timeSource);\n    this.createCanvasElement = config.createCanvasElement ?? createBrowserCanvasFactory();\n    this.commentDependencies = {\n      timeSource: this.timeSource,\n      settingsVersion: this.settingsVersion,\n    };\n    this.log = createLogger(config.loggerNamespace ?? \"CommentRenderer\");\n\n    this.rebuildNgMatchers();\n\n    if (config.debug) {\n      configureDebugLogging(config.debug);\n    }\n  }\n\n  get settings(): RendererSettings {\n    return this._settings;\n  }\n\n  set settings(value: RendererSettings) {\n    this._settings = normalizeSettings(value);\n    this.settingsVersion += 1;\n    this.commentDependencies.settingsVersion = this.settingsVersion;\n    this.rebuildNgMatchers();\n  }\n\n  private resolveContainer(\n    explicit: HTMLElement | null | undefined,\n    video: HTMLVideoElement,\n  ): HTMLElement {\n    if (explicit) {\n      return explicit;\n    }\n    if (video.parentElement) {\n      return video.parentElement;\n    }\n    if (typeof document !== \"undefined\" && document.body) {\n      return document.body;\n    }\n    throw new Error(\n      \"Cannot resolve container element. Provide container explicitly when DOM is unavailable.\",\n    );\n  }\n\n  private ensureContainerPositioning(container: HTMLElement): void {\n    if (typeof getComputedStyle === \"function\") {\n      const style = getComputedStyle(container);\n      if (style.position === \"static\") {\n        container.style.position = \"relative\";\n      }\n      return;\n    }\n    if (!container.style.position) {\n      container.style.position = \"relative\";\n    }\n  }\n\n  initialize(options: HTMLVideoElement | CommentRendererInitializeOptions): void {\n    try {\n      this.destroyCanvasOnly();\n\n      const video = options instanceof HTMLVideoElement ? options : options.video;\n      const containerCandidate =\n        options instanceof HTMLVideoElement\n          ? options.parentElement\n          : (options.container ?? options.video.parentElement);\n      const container = this.resolveContainer(containerCandidate ?? null, video);\n\n      this.videoElement = video;\n      this.containerElement = container;\n      this.duration = Number.isFinite(video.duration) ? toMilliseconds(video.duration) : 0;\n      this.currentTime = toMilliseconds(video.currentTime);\n      this.playbackRate = video.playbackRate;\n      this.isPlaying = !video.paused;\n      this.isStalled = false;\n      this.lastDrawTime = this.timeSource.now();\n      this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n      this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n\n      const canvas = this.createCanvasElement();\n      const context = canvas.getContext(\"2d\");\n      if (!context) {\n        throw new Error(\"Failed to acquire 2D canvas context\");\n      }\n\n      canvas.style.position = \"absolute\";\n      canvas.style.top = \"0\";\n      canvas.style.left = \"0\";\n      canvas.style.pointerEvents = \"none\";\n      canvas.style.zIndex = \"1000\";\n\n      const parent = this.containerElement;\n      if (parent instanceof HTMLElement) {\n        this.ensureContainerPositioning(parent);\n        parent.appendChild(canvas);\n      }\n\n      this.canvas = canvas;\n      this.ctx = context;\n\n      this.resize();\n      this.calculateLaneMetrics();\n      this.setupVideoEventListeners(video);\n      this.setupResizeHandling(video);\n      this.setupFullscreenHandling();\n      this.setupVideoChangeDetection(video, container);\n      this.startAnimation();\n      this.setupVisibilityHandling();\n    } catch (error) {\n      this.log.error(\"CommentRenderer.initialize\", error as Error);\n      throw error;\n    }\n  }\n\n  addComments(\n    entries: ReadonlyArray<{ text: string; vposMs: number; commands?: string[] }>,\n  ): Comment[] {\n    if (!Array.isArray(entries) || entries.length === 0) {\n      return [];\n    }\n\n    const addedComments: Comment[] = [];\n    this.commentDependencies.settingsVersion = this.settingsVersion;\n\n    for (const entry of entries) {\n      const { text, vposMs, commands = [] } = entry;\n      const preview = formatCommentPreview(text);\n\n      if (this.isNGComment(text)) {\n        debugLog(\"comment-skip-ng\", { preview, vposMs });\n        continue;\n      }\n\n      const normalizedVposMs = sanitizeVposMs(vposMs);\n      if (normalizedVposMs === null) {\n        this.log.warn(\"CommentRenderer.addComment.invalidVpos\", { text, vposMs });\n        debugLog(\"comment-skip-invalid-vpos\", { preview, vposMs });\n        continue;\n      }\n\n      const duplicate =\n        this.comments.some(\n          (comment) => comment.text === text && comment.vposMs === normalizedVposMs,\n        ) ||\n        addedComments.some(\n          (comment) => comment.text === text && comment.vposMs === normalizedVposMs,\n        );\n      if (duplicate) {\n        debugLog(\"comment-skip-duplicate\", { preview, vposMs: normalizedVposMs });\n        continue;\n      }\n\n      const comment = new Comment(\n        text,\n        normalizedVposMs,\n        commands,\n        this._settings,\n        this.commentDependencies,\n      );\n      comment.creationIndex = this.commentSequence++;\n      addedComments.push(comment);\n      debugLog(\"comment-added\", {\n        preview,\n        vposMs: normalizedVposMs,\n        commands: comment.commands.length,\n        layout: comment.layout,\n        isScrolling: comment.isScrolling,\n        invisible: comment.isInvisible,\n      });\n    }\n\n    if (addedComments.length === 0) {\n      return [];\n    }\n\n    this.comments.push(...addedComments);\n    if (this.finalPhaseActive) {\n      this.finalPhaseScheduleDirty = true;\n    }\n    this.comments.sort((a, b) => {\n      const vposMsDiff = a.vposMs - b.vposMs;\n      if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n        return vposMsDiff;\n      }\n      return a.creationIndex - b.creationIndex;\n    });\n\n    return addedComments;\n  }\n\n  addComment(text: string, vposMs: number, commands: string[] = []): Comment | null {\n    const [comment] = this.addComments([{ text, vposMs, commands }]);\n    return comment ?? null;\n  }\n\n  clearComments(): void {\n    this.comments.length = 0;\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n    this.commentSequence = 0;\n    if (this.ctx && this.canvas) {\n      const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n      const width = this.displayWidth > 0 ? this.displayWidth : this.canvas.width / effectiveDpr;\n      const height =\n        this.displayHeight > 0 ? this.displayHeight : this.canvas.height / effectiveDpr;\n      this.ctx.clearRect(0, 0, width, height);\n    }\n  }\n\n  resetState(): void {\n    this.clearComments();\n    this.currentTime = 0;\n    this.resetFinalPhaseState();\n    this.playbackHasBegun = false;\n    this.skipDrawingForCurrentFrame = false;\n    this.isStalled = false;\n    this.pendingInitialSync = false;\n  }\n\n  destroy(): void {\n    this.stopAnimation();\n    this.cleanupResizeHandling();\n    this.runCleanupTasks();\n\n    if (this.canvas) {\n      this.canvas.remove();\n    }\n    this.canvas = null;\n    this.ctx = null;\n    this.videoElement = null;\n    this.containerElement = null;\n    this.comments.length = 0;\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.resetFinalPhaseState();\n    this.displayWidth = 0;\n    this.displayHeight = 0;\n    this.canvasDpr = 1;\n    this.commentSequence = 0;\n    this.playbackHasBegun = false;\n    this.skipDrawingForCurrentFrame = false;\n    this.isStalled = false;\n    this.pendingInitialSync = false;\n  }\n\n  /**\n   * 前エポックのゴーストコメントを強制掃除し、次のフレームで絶対時間同期を行う\n   * 動画ロード直後の初期化やソース変更時に使用\n   */\n  hardReset(): void {\n    const canvas = this.canvas;\n    const ctx = this.ctx;\n\n    // アクティブコメントを全てクリア\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n\n    // 全コメントを非アクティブ化\n    this.comments.forEach((comment) => {\n      comment.isActive = false;\n      comment.hasShown = false;\n      comment.lane = -1;\n      comment.clearActivation();\n    });\n\n    // キャンバスを全消去\n    if (canvas && ctx) {\n      const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n      const effectiveWidth =\n        this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n      const effectiveHeight =\n        this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n      ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    }\n\n    // 次のフレームで絶対時間同期を実行するフラグを立てる\n    this.pendingInitialSync = true;\n    this.resetFinalPhaseState();\n  }\n\n  private resetFinalPhaseState(): void {\n    this.finalPhaseActive = false;\n    this.finalPhaseStartTime = null;\n    this.finalPhaseScheduleDirty = false;\n    this.finalPhaseVposOverrides.clear();\n  }\n\n  private getEffectiveCommentVpos(comment: Comment): number {\n    if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n      this.recomputeFinalPhaseTimeline();\n    }\n    const override = this.finalPhaseVposOverrides.get(comment);\n    return override ?? comment.vposMs;\n  }\n\n  private getFinalPhaseDisplayDuration(comment: Comment): number {\n    if (!comment.isScrolling) {\n      return STATIC_VISIBLE_DURATION_MS;\n    }\n\n    const durations: number[] = [];\n    if (Number.isFinite(comment.visibleDurationMs) && comment.visibleDurationMs > 0) {\n      durations.push(comment.visibleDurationMs);\n    }\n    if (Number.isFinite(comment.totalDurationMs) && comment.totalDurationMs > 0) {\n      durations.push(comment.totalDurationMs);\n    }\n\n    if (durations.length > 0) {\n      return Math.max(...durations);\n    }\n\n    return MAX_VISIBLE_DURATION_MS;\n  }\n\n  private resolveFinalPhaseVpos(comment: Comment): number {\n    if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n      this.finalPhaseVposOverrides.delete(comment);\n      return comment.vposMs;\n    }\n    if (this.finalPhaseScheduleDirty) {\n      this.recomputeFinalPhaseTimeline();\n    }\n    const override = this.finalPhaseVposOverrides.get(comment);\n    if (override !== undefined) {\n      return override;\n    }\n    const fallback = Math.max(comment.vposMs, this.finalPhaseStartTime);\n    this.finalPhaseVposOverrides.set(comment, fallback);\n    return fallback;\n  }\n\n  private recomputeFinalPhaseTimeline(): void {\n    if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n      this.finalPhaseVposOverrides.clear();\n      this.finalPhaseScheduleDirty = false;\n      return;\n    }\n\n    const windowStart = this.finalPhaseStartTime;\n    const durationMs = this.duration > 0 ? this.duration : windowStart + FINAL_PHASE_MIN_WINDOW_MS;\n    const windowEnd = Math.max(windowStart + FINAL_PHASE_MIN_WINDOW_MS, durationMs);\n\n    const candidates = this.comments\n      .filter((comment) => {\n        if (comment.hasShown) {\n          return false;\n        }\n        if (comment.isInvisible) {\n          return false;\n        }\n        if (this.isNGComment(comment.text)) {\n          return false;\n        }\n        return comment.vposMs >= windowStart - ACTIVE_WINDOW_MS;\n      })\n      .sort((a, b) => {\n        const diff = a.vposMs - b.vposMs;\n        if (Math.abs(diff) > EDGE_EPSILON) {\n          return diff;\n        }\n        return a.creationIndex - b.creationIndex;\n      });\n\n    this.finalPhaseVposOverrides.clear();\n\n    if (candidates.length === 0) {\n      this.finalPhaseScheduleDirty = false;\n      return;\n    }\n\n    const windowSpan = Math.max(windowEnd - windowStart, FINAL_PHASE_MIN_WINDOW_MS);\n    const baseGap = windowSpan / Math.max(candidates.length, 1);\n    const boundedGap = Number.isFinite(baseGap) ? baseGap : FINAL_PHASE_MIN_GAP_MS;\n    const gap = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(boundedGap, FINAL_PHASE_MAX_GAP_MS));\n\n    let nextStart = windowStart;\n    candidates.forEach((comment, index) => {\n      const durationNeeded = Math.max(1, this.getFinalPhaseDisplayDuration(comment));\n      const availableLatestStart = windowEnd - durationNeeded;\n      let assigned = Math.max(windowStart, Math.min(nextStart, availableLatestStart));\n      if (!Number.isFinite(assigned)) {\n        assigned = windowStart;\n      }\n      const epsilon = FINAL_PHASE_ORDER_EPSILON_MS * index;\n      if (assigned + epsilon <= availableLatestStart) {\n        assigned += epsilon;\n      }\n      this.finalPhaseVposOverrides.set(comment, assigned);\n      const spacing = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(durationNeeded / 2, gap));\n      nextStart = assigned + spacing;\n    });\n\n    this.finalPhaseScheduleDirty = false;\n  }\n\n  private shouldSuppressRendering(): boolean {\n    return (\n      !this.playbackHasBegun && !this.isPlaying && this.currentTime <= SEEK_DIRECTION_EPSILON_MS\n    );\n  }\n\n  private updatePlaybackProgressState(): void {\n    if (this.playbackHasBegun) {\n      return;\n    }\n    if (this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS) {\n      this.playbackHasBegun = true;\n    }\n  }\n\n  updateSettings(newSettings: RendererSettings): void {\n    const previousUseContainer = this._settings.useContainerResizeObserver;\n    const previousDirection = this._settings.scrollDirection;\n    const previousUseDprScaling = this._settings.useDprScaling;\n    const previousSyncMode = this._settings.syncMode;\n    this.settings = newSettings;\n    const directionChanged = previousDirection !== this._settings.scrollDirection;\n    const useDprScalingChanged = previousUseDprScaling !== this._settings.useDprScaling;\n    const syncModeChanged = previousSyncMode !== this._settings.syncMode;\n\n    this.comments.forEach((comment) => {\n      comment.syncWithSettings(this._settings, this.settingsVersion);\n    });\n\n    if (directionChanged) {\n      this.resetCommentActivity();\n    }\n\n    if (!this._settings.isCommentVisible && this.ctx && this.canvas) {\n      this.comments.forEach((comment) => {\n        comment.isActive = false;\n        comment.clearActivation();\n      });\n      this.activeComments.clear();\n      const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n      const width = this.displayWidth > 0 ? this.displayWidth : this.canvas.width / effectiveDpr;\n      const height =\n        this.displayHeight > 0 ? this.displayHeight : this.canvas.height / effectiveDpr;\n      this.ctx.clearRect(0, 0, width, height);\n      this.reservedLanes.clear();\n      this.topStaticLaneReservations.length = 0;\n      this.bottomStaticLaneReservations.length = 0;\n    }\n\n    if (previousUseContainer !== this._settings.useContainerResizeObserver && this.videoElement) {\n      this.setupResizeHandling(this.videoElement);\n    }\n\n    if (useDprScalingChanged) {\n      this.resize();\n    }\n\n    if (syncModeChanged && this.videoElement) {\n      this.startAnimation();\n    }\n\n    this.calculateLaneMetrics();\n  }\n\n  getVideoElement(): HTMLVideoElement | null {\n    return this.videoElement;\n  }\n\n  getCurrentVideoSource(): string | null {\n    const video = this.videoElement;\n    if (!video) {\n      return null;\n    }\n    if (typeof video.currentSrc === \"string\" && video.currentSrc.length > 0) {\n      return video.currentSrc;\n    }\n    const attribute = video.getAttribute(\"src\");\n    if (attribute && attribute.length > 0) {\n      return attribute;\n    }\n    const sourceElement = video.querySelector(\"source[src]\") as HTMLSourceElement | null;\n    if (sourceElement && typeof sourceElement.src === \"string\") {\n      return sourceElement.src;\n    }\n    return null;\n  }\n\n  getCommentsSnapshot(): Comment[] {\n    return [...this.comments];\n  }\n\n  private rebuildNgMatchers(): void {\n    const normalizedWords: string[] = [];\n    const compiledRegexps: RegExp[] = [];\n\n    const sourceWords = Array.isArray(this._settings.ngWords) ? this._settings.ngWords : [];\n    for (const word of sourceWords) {\n      if (typeof word !== \"string\") {\n        continue;\n      }\n      const normalized = word.trim().toLowerCase();\n      if (normalized.length === 0) {\n        continue;\n      }\n      normalizedWords.push(normalized);\n    }\n\n    const sourcePatterns = Array.isArray(this._settings.ngRegexps) ? this._settings.ngRegexps : [];\n    for (const pattern of sourcePatterns) {\n      if (typeof pattern !== \"string\" || pattern.length === 0) {\n        continue;\n      }\n      try {\n        compiledRegexps.push(new RegExp(pattern));\n      } catch (regexError) {\n        this.log.error(\"CommentRenderer.rebuildNgMatchers.regex\", regexError as Error, {\n          pattern,\n        });\n      }\n    }\n\n    this.normalizedNgWords = normalizedWords;\n    this.compiledNgRegexps = compiledRegexps;\n  }\n\n  isNGComment(text: string): boolean {\n    try {\n      if (typeof text !== \"string\") {\n        return true;\n      }\n\n      if (this.normalizedNgWords.length > 0) {\n        const normalizedText = text.toLowerCase();\n        const containsNgWord = this.normalizedNgWords.some((word) => normalizedText.includes(word));\n        if (containsNgWord) {\n          return true;\n        }\n      }\n\n      if (this.compiledNgRegexps.length > 0) {\n        return this.compiledNgRegexps.some((regexp) => regexp.test(text));\n      }\n\n      return false;\n    } catch (error) {\n      this.log.error(\"CommentRenderer.isNGComment\", error as Error, { text });\n      return true;\n    }\n  }\n\n  resize(width?: number, height?: number): void {\n    const video = this.videoElement;\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (!video || !canvas) {\n      return;\n    }\n\n    const rect = video.getBoundingClientRect();\n    const currentDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const fallbackWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / currentDpr;\n    const fallbackHeight = this.displayHeight > 0 ? this.displayHeight : canvas.height / currentDpr;\n\n    const measuredWidth = width ?? rect.width ?? fallbackWidth;\n    const measuredHeight = height ?? rect.height ?? fallbackHeight;\n\n    if (\n      !Number.isFinite(measuredWidth) ||\n      !Number.isFinite(measuredHeight) ||\n      measuredWidth <= 0 ||\n      measuredHeight <= 0\n    ) {\n      return;\n    }\n\n    const cssWidth = Math.max(1, Math.floor(measuredWidth));\n    const cssHeight = Math.max(1, Math.floor(measuredHeight));\n    const previousDisplayWidth = this.displayWidth > 0 ? this.displayWidth : cssWidth;\n    const previousDisplayHeight = this.displayHeight > 0 ? this.displayHeight : cssHeight;\n    const nextDpr = this._settings.useDprScaling ? this.resolveDevicePixelRatio() : 1;\n    const pixelWidth = Math.max(1, Math.round(cssWidth * nextDpr));\n    const pixelHeight = Math.max(1, Math.round(cssHeight * nextDpr));\n\n    const needsResize =\n      this.displayWidth !== cssWidth ||\n      this.displayHeight !== cssHeight ||\n      Math.abs(this.canvasDpr - nextDpr) > Number.EPSILON ||\n      canvas.width !== pixelWidth ||\n      canvas.height !== pixelHeight;\n\n    if (!needsResize) {\n      return;\n    }\n\n    this.displayWidth = cssWidth;\n    this.displayHeight = cssHeight;\n    this.canvasDpr = nextDpr;\n\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    canvas.style.width = `${cssWidth}px`;\n    canvas.style.height = `${cssHeight}px`;\n\n    if (context) {\n      context.setTransform(1, 0, 0, 1, 0, 0);\n      if (this._settings.useDprScaling) {\n        context.scale(nextDpr, nextDpr);\n      }\n    }\n\n    const scaleX = previousDisplayWidth > 0 ? cssWidth / previousDisplayWidth : 1;\n    const scaleY = previousDisplayHeight > 0 ? cssHeight / previousDisplayHeight : 1;\n\n    if (scaleX !== 1 || scaleY !== 1) {\n      this.comments.forEach((comment) => {\n        if (comment.isActive) {\n          comment.x *= scaleX;\n          comment.y *= scaleY;\n          comment.width *= scaleX;\n          comment.fontSize = Math.max(\n            MIN_FONT_SIZE_PX,\n            Math.floor(Math.max(1, comment.fontSize) * scaleY),\n          );\n          comment.height = comment.fontSize;\n          comment.virtualStartX *= scaleX;\n          comment.exitThreshold *= scaleX;\n          comment.baseSpeed *= scaleX;\n          comment.speed *= scaleX;\n          comment.speedPixelsPerMs *= scaleX;\n          comment.bufferWidth *= scaleX;\n          comment.reservationWidth *= scaleX;\n        }\n      });\n    }\n\n    this.calculateLaneMetrics();\n  }\n\n  private resolveDevicePixelRatio(): number {\n    if (typeof window === \"undefined\") {\n      return 1;\n    }\n    const ratio = Number(window.devicePixelRatio);\n    if (!Number.isFinite(ratio) || ratio <= 0) {\n      return 1;\n    }\n    return ratio;\n  }\n\n  private destroyCanvasOnly(): void {\n    this.stopAnimation();\n    this.cleanupResizeHandling();\n    this.runCleanupTasks();\n    if (this.canvas) {\n      this.canvas.remove();\n    }\n    this.canvas = null;\n    this.ctx = null;\n    this.displayWidth = 0;\n    this.displayHeight = 0;\n    this.canvasDpr = 1;\n    this.fullscreenActive = false;\n  }\n\n  private calculateLaneMetrics(): void {\n    const canvas = this.canvas;\n    if (!canvas) {\n      return;\n    }\n\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / Math.max(this.canvasDpr, 1);\n    const baseHeight = Math.max(MIN_FONT_SIZE_PX, Math.floor(effectiveHeight * 0.05));\n    this.laneHeight = baseHeight * 1.2;\n    const availableLanes = Math.floor(effectiveHeight / Math.max(this.laneHeight, 1));\n    if (this._settings.useFixedLaneCount) {\n      // 利用可能レーン数の範囲にクランプして固定値を適用\n      const desired = Number.isFinite(this._settings.fixedLaneCount)\n        ? Math.floor(this._settings.fixedLaneCount)\n        : DEFAULT_LANE_COUNT;\n      const clamped = Math.max(MIN_LANE_COUNT, Math.min(availableLanes, desired));\n      this.laneCount = clamped;\n    } else {\n      this.laneCount = Math.max(MIN_LANE_COUNT, availableLanes);\n    }\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n  }\n\n  private updateComments(frameTimeMs?: number): void {\n    const video = this.videoElement;\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (!video || !canvas || !context) {\n      return;\n    }\n\n    const referenceTime =\n      typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n    this.currentTime = referenceTime;\n    this.playbackRate = video.playbackRate;\n    this.isPlaying = !video.paused;\n    this.updatePlaybackProgressState();\n    this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n    if (this.skipDrawingForCurrentFrame) {\n      return;\n    }\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n    const isNearEnd =\n      this.duration > 0 && this.duration - this.currentTime <= FINAL_PHASE_THRESHOLD_MS;\n\n    if (isNearEnd && !this.finalPhaseActive) {\n      this.finalPhaseActive = true;\n      this.finalPhaseStartTime = this.currentTime;\n      this.finalPhaseVposOverrides.clear();\n      this.finalPhaseScheduleDirty = true;\n      context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n      this.comments.forEach((comment) => {\n        comment.isActive = false;\n        comment.clearActivation();\n      });\n      this.activeComments.clear();\n      this.reservedLanes.clear();\n      this.topStaticLaneReservations.length = 0;\n      this.bottomStaticLaneReservations.length = 0;\n    }\n\n    if (!isNearEnd && this.finalPhaseActive) {\n      this.resetFinalPhaseState();\n    }\n\n    if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n      this.recomputeFinalPhaseTimeline();\n    }\n\n    this.pruneStaticLaneReservations(this.currentTime);\n\n    // 時間インデックスを用いて、アクティブウィンドウ内のコメントのみを処理\n    const activeWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n    for (const comment of activeWindowComments) {\n      const debugActive = isDebugLoggingEnabled();\n      const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n      if (debugActive) {\n        debugLog(\"comment-evaluate\", {\n          stage: \"update\",\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          currentTime: this.currentTime,\n          isActive: comment.isActive,\n          hasShown: comment.hasShown,\n        });\n      }\n\n      if (this.isNGComment(comment.text)) {\n        if (debugActive) {\n          debugLog(\"comment-eval-skip\", {\n            preview,\n            vposMs: comment.vposMs,\n            effectiveVposMs: this.getEffectiveCommentVpos(comment),\n            reason: \"ng-runtime\",\n          });\n        }\n        continue;\n      }\n      if (comment.isInvisible) {\n        if (debugActive) {\n          debugLog(\"comment-eval-skip\", {\n            preview,\n            vposMs: comment.vposMs,\n            effectiveVposMs: this.getEffectiveCommentVpos(comment),\n            reason: \"invisible\",\n          });\n        }\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.hasShown = true;\n        comment.clearActivation();\n        continue;\n      }\n\n      comment.syncWithSettings(this._settings, this.settingsVersion);\n\n      if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n        this.activateComment(\n          comment,\n          context,\n          effectiveWidth,\n          effectiveHeight,\n          prepareOptions,\n          this.currentTime,\n        );\n      }\n\n      if (comment.isActive) {\n        if (comment.layout !== \"naka\" && comment.hasStaticExpired(this.currentTime)) {\n          const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n          this.releaseStaticLane(staticPosition, comment.lane);\n          comment.isActive = false;\n          this.activeComments.delete(comment);\n          comment.clearActivation();\n          continue;\n        }\n\n        if (\n          comment.layout === \"naka\" &&\n          this.getEffectiveCommentVpos(comment) > this.currentTime + SEEK_DIRECTION_EPSILON_MS\n        ) {\n          comment.x = comment.virtualStartX;\n          comment.lastUpdateTime = this.timeSource.now();\n          continue;\n        }\n\n        comment.hasShown = true;\n        comment.update(this.playbackRate, !this.isPlaying);\n        if (!comment.isScrolling && comment.hasStaticExpired(this.currentTime)) {\n          const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n          this.releaseStaticLane(staticPosition, comment.lane);\n          comment.isActive = false;\n          this.activeComments.delete(comment);\n          comment.clearActivation();\n        }\n      }\n    }\n\n    for (const comment of this.comments) {\n      if (\n        comment.isActive &&\n        comment.isScrolling &&\n        ((comment.scrollDirection === \"rtl\" && comment.x <= comment.exitThreshold) ||\n          (comment.scrollDirection === \"ltr\" && comment.x >= comment.exitThreshold))\n      ) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n  }\n\n  private buildPrepareOptions(visibleWidth: number): CommentPrepareOptions {\n    const overrideDuration = this._settings.scrollVisibleDurationMs;\n    let maxVisibleDurationMs = MAX_VISIBLE_DURATION_MS;\n    let minVisibleDurationMs = MIN_VISIBLE_DURATION_MS;\n\n    if (overrideDuration !== null) {\n      maxVisibleDurationMs = overrideDuration;\n      minVisibleDurationMs = Math.max(1, Math.min(overrideDuration, MIN_VISIBLE_DURATION_MS));\n    }\n\n    return {\n      visibleWidth,\n      virtualExtension: VIRTUAL_CANVAS_EXTENSION_PX,\n      maxVisibleDurationMs,\n      minVisibleDurationMs,\n      maxWidthRatio: MAX_COMMENT_WIDTH_RATIO,\n      bufferRatio: COLLISION_BUFFER_RATIO,\n      baseBufferPx: BASE_COLLISION_BUFFER_PX,\n      entryBufferPx: ENTRY_BUFFER_PX,\n    };\n  }\n\n  private findAvailableLane(comment: Comment): number {\n    const currentTime = this.currentTime;\n    this.pruneLaneReservations(currentTime);\n    this.pruneStaticLaneReservations(currentTime);\n    const laneCandidates = this.getLanePriorityOrder(currentTime);\n    const newReservation = this.createLaneReservation(comment, currentTime);\n\n    for (const lane of laneCandidates) {\n      if (this.isLaneAvailable(lane, newReservation, currentTime)) {\n        this.storeLaneReservation(lane, newReservation);\n        return lane;\n      }\n    }\n\n    const fallbackLane = laneCandidates[0] ?? 0;\n    this.storeLaneReservation(fallbackLane, newReservation);\n    return fallbackLane;\n  }\n\n  /**\n   * 二分探索で、指定した時刻より後に終了する最初の予約のインデックスを返す\n   */\n  private findFirstValidReservationIndex(\n    reservations: LaneReservation[],\n    cutoffTime: number,\n  ): number {\n    let left = 0;\n    let right = reservations.length;\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      const reservation = reservations[mid];\n      if (\n        reservation !== undefined &&\n        reservation.totalEndTime + RESERVATION_TIME_MARGIN_MS <= cutoffTime\n      ) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n    return left;\n  }\n\n  private pruneLaneReservations(currentTime: number): void {\n    for (const [lane, reservations] of this.reservedLanes.entries()) {\n      // 二分探索で有効な予約の開始インデックスを取得\n      const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n      if (firstValidIndex >= reservations.length) {\n        // 全て期限切れ\n        this.reservedLanes.delete(lane);\n      } else if (firstValidIndex > 0) {\n        // 一部を削除\n        this.reservedLanes.set(lane, reservations.slice(firstValidIndex));\n      }\n      // firstValidIndex === 0 の場合は何もしない（全て有効）\n    }\n  }\n\n  private pruneStaticLaneReservations(currentTime: number): void {\n    // 期限切れの予約を削除（時間でフィルタリング）\n    const filterValid = (reservations: StaticLaneReservation[]): StaticLaneReservation[] =>\n      reservations.filter((reservation) => reservation.releaseTime > currentTime);\n\n    const topFiltered = filterValid(this.topStaticLaneReservations);\n    const bottomFiltered = filterValid(this.bottomStaticLaneReservations);\n\n    // 配列を置き換え\n    this.topStaticLaneReservations.length = 0;\n    this.topStaticLaneReservations.push(...topFiltered);\n\n    this.bottomStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.push(...bottomFiltered);\n  }\n\n  /**\n   * 二分探索で、指定した時刻以上の最初のコメントのインデックスを返す\n   */\n  private findCommentIndexAtOrAfter(targetVposMs: number): number {\n    let left = 0;\n    let right = this.comments.length;\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      const comment = this.comments[mid];\n      if (comment !== undefined && comment.vposMs < targetVposMs) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n    return left;\n  }\n\n  /**\n   * 指定した時刻範囲内のコメントのみを返す\n   */\n  private getCommentsInTimeWindow(centerTimeMs: number, windowMs: number): Comment[] {\n    if (this.comments.length === 0) {\n      return [];\n    }\n    const startTime = centerTimeMs - windowMs;\n    const endTime = centerTimeMs + windowMs;\n    const startIndex = this.findCommentIndexAtOrAfter(startTime);\n\n    // 開始インデックスから順に、終了時刻までのコメントを集める\n    const result: Comment[] = [];\n    for (let i = startIndex; i < this.comments.length; i++) {\n      const comment = this.comments[i];\n      if (comment === undefined) {\n        break;\n      }\n      if (comment.vposMs > endTime) {\n        break;\n      }\n      result.push(comment);\n    }\n    return result;\n  }\n\n  private getStaticReservations(position: \"ue\" | \"shita\"): StaticLaneReservation[] {\n    return position === \"ue\" ? this.topStaticLaneReservations : this.bottomStaticLaneReservations;\n  }\n\n  private getStaticLaneDepth(position: \"ue\" | \"shita\"): number {\n    const reservations = this.getStaticReservations(position);\n    if (reservations.length === 0) {\n      return 0;\n    }\n    let maxIndex = -1;\n    for (const reservation of reservations) {\n      if (reservation.lane > maxIndex) {\n        maxIndex = reservation.lane;\n      }\n    }\n    return Math.max(0, maxIndex + 1);\n  }\n\n  private getStaticLaneLimit(position: \"ue\" | \"shita\"): number {\n    const otherPosition = position === \"ue\" ? \"shita\" : \"ue\";\n    const otherDepth = this.getStaticLaneDepth(otherPosition);\n    const available = this.laneCount - otherDepth;\n    if (available <= 0) {\n      return -1;\n    }\n    return available - 1;\n  }\n\n  private getGlobalLaneIndexForBottom(localIndex: number): number {\n    const clampedLaneCount = Math.max(1, this.laneCount);\n    const clampedIndex = Math.max(0, localIndex);\n    return Math.max(0, clampedLaneCount - 1 - clampedIndex);\n  }\n\n  private resolveStaticCommentOffset(\n    position: \"ue\" | \"shita\",\n    lane: number,\n    displayHeight: number,\n    comment: Comment,\n  ): number {\n    const effectiveHeight = Math.max(1, displayHeight);\n    const commentHeight = Math.max(comment.height, comment.fontSize);\n    // 描画時のパディング（影やエフェクトのため）を考慮\n    const padding = calculateStaticCommentVerticalPadding(comment.fontSize);\n\n    if (position === \"ue\") {\n      // 上コメント：レーンベースの位置を計算\n      const baseY = lane * this.laneHeight;\n      // 実際の描画は y - padding から始まるので、上端がマイナスにならないようクランプ\n      const minY = padding;\n      // 下端が画面からはみ出ないようクランプ（実際の下端は y + height + padding）\n      const maxY = Math.max(padding, effectiveHeight - commentHeight - padding);\n      return Math.max(minY, Math.min(baseY, maxY));\n    }\n\n    // 下コメント：下端を基準に配置\n    // lane 0 = 画面下端、lane 1 = laneHeight分上、というように配置\n    const targetBottomY = effectiveHeight - lane * this.laneHeight;\n    // 実際の描画下端は y + height + padding なので、これが targetBottomY になるように計算\n    const adjustedY = targetBottomY - commentHeight - padding;\n    // 上端が画面外に出ないようクランプ（描画開始位置は y - padding）\n    return Math.max(padding, adjustedY);\n  }\n\n  private getStaticReservedLaneSet(): Set<number> {\n    const reserved = new Set<number>();\n    for (const reservation of this.topStaticLaneReservations) {\n      reserved.add(reservation.lane);\n    }\n    for (const reservation of this.bottomStaticLaneReservations) {\n      reserved.add(this.getGlobalLaneIndexForBottom(reservation.lane));\n    }\n    return reserved;\n  }\n\n  private shouldActivateCommentAtTime(\n    comment: Comment,\n    timeMs: number,\n    preview: string = \"\",\n  ): boolean {\n    const debugActive = preview.length > 0 && isDebugLoggingEnabled();\n    const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n    if (\n      this.finalPhaseActive &&\n      this.finalPhaseStartTime !== null &&\n      comment.vposMs < this.finalPhaseStartTime - EDGE_EPSILON\n    ) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          reason: \"final-phase-trimmed\",\n          finalPhaseStartTime: this.finalPhaseStartTime,\n        });\n      }\n      this.finalPhaseVposOverrides.delete(comment);\n      return false;\n    }\n\n    if (comment.isInvisible) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          reason: \"invisible\",\n        });\n      }\n      return false;\n    }\n    if (comment.isActive) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          reason: \"already-active\",\n        });\n      }\n      return false;\n    }\n    if (effectiveVpos > timeMs + SEEK_DIRECTION_EPSILON_MS) {\n      if (debugActive) {\n        debugLog(\"comment-eval-pending\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          reason: \"future\",\n          currentTime: timeMs,\n        });\n      }\n      return false;\n    }\n    if (effectiveVpos < timeMs - ACTIVE_WINDOW_MS) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          reason: \"expired-window\",\n          currentTime: timeMs,\n        });\n      }\n      return false;\n    }\n\n    if (debugActive) {\n      debugLog(\"comment-eval-ready\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        currentTime: timeMs,\n      });\n    }\n    return true;\n  }\n\n  private activateComment(\n    comment: Comment,\n    context: CanvasRenderingContext2D,\n    displayWidth: number,\n    displayHeight: number,\n    options: CommentPrepareOptions,\n    referenceTime: number,\n  ): void {\n    comment.prepare(context, displayWidth, displayHeight, options);\n    const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n    if (isDebugLoggingEnabled()) {\n      debugLog(\"comment-prepared\", {\n        preview: formatCommentPreview(comment.text),\n        layout: comment.layout,\n        isScrolling: comment.isScrolling,\n        width: comment.width,\n        height: comment.height,\n        bufferWidth: comment.bufferWidth,\n        visibleDurationMs: comment.visibleDurationMs,\n        effectiveVposMs: effectiveVpos,\n      });\n    }\n\n    if (comment.layout === \"naka\") {\n      const elapsedMs = Math.max(0, referenceTime - effectiveVpos);\n      const displacement = comment.speedPixelsPerMs * elapsedMs;\n\n      // --- ファイナルフェーズ時の速度調整ロジック ---\n      if (this.finalPhaseActive && this.finalPhaseStartTime !== null) {\n        // コメントが画面を横断しきるべき最終時刻を決定\n        const videoDuration =\n          this.duration > 0 ? this.duration : this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS;\n        const finalPhaseWindowEnd = Math.max(\n          this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS,\n          videoDuration,\n        );\n\n        // コメントが移動すべき全距離\n        const travelDistance = Math.abs(comment.exitThreshold - comment.virtualStartX);\n        // コメントが移動に使える時間\n        const availableTravelTime = finalPhaseWindowEnd - effectiveVpos;\n\n        if (availableTravelTime > 0 && travelDistance > 0) {\n          const requiredSpeedPixelsPerMs = travelDistance / availableTravelTime;\n\n          // 必要な速度が現在の速度より速い場合のみ調整\n          if (requiredSpeedPixelsPerMs > comment.speedPixelsPerMs) {\n            comment.speedPixelsPerMs = requiredSpeedPixelsPerMs;\n            comment.baseSpeed = requiredSpeedPixelsPerMs * (1000 / 60); // px/ms を px/frame に変換\n            comment.speed = comment.baseSpeed; // 即座に適用 (playbackRate は update() で適用される)\n            comment.totalDurationMs = Math.ceil(travelDistance / requiredSpeedPixelsPerMs); // 総移動時間も更新\n          }\n        }\n      }\n      // --- ファイナルフェーズ時の速度調整ロジックここまで ---\n\n      const directionSign = comment.getDirectionSign();\n      const projectedX = comment.virtualStartX + directionSign * displacement;\n      const exitThreshold = comment.exitThreshold;\n      const direction = comment.scrollDirection;\n      const alreadyExited =\n        (direction === \"rtl\" && projectedX <= exitThreshold) ||\n        (direction === \"ltr\" && projectedX >= exitThreshold);\n\n      if (alreadyExited) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.hasShown = true;\n        comment.clearActivation();\n        comment.lane = -1;\n        if (isDebugLoggingEnabled()) {\n          debugLog(\"comment-skip-exited\", {\n            preview: formatCommentPreview(comment.text),\n            vposMs: comment.vposMs,\n            effectiveVposMs: effectiveVpos,\n            referenceTime,\n          });\n        }\n        return;\n      }\n\n      comment.lane = this.findAvailableLane(comment);\n      comment.y = comment.lane * this.laneHeight;\n      comment.x = projectedX;\n      comment.isActive = true;\n      this.activeComments.add(comment);\n      comment.hasShown = true;\n      comment.isPaused = !this.isPlaying;\n      comment.markActivated(referenceTime);\n      comment.lastUpdateTime = this.timeSource.now();\n      if (isDebugLoggingEnabled()) {\n        debugLog(\"comment-activate-scroll\", {\n          preview: formatCommentPreview(comment.text),\n          lane: comment.lane,\n          startX: comment.x,\n          width: comment.width,\n          visibleDurationMs: comment.visibleDurationMs,\n          effectiveVposMs: effectiveVpos,\n        });\n      }\n      return;\n    }\n\n    const displayEnd = effectiveVpos + STATIC_VISIBLE_DURATION_MS;\n    if (referenceTime > displayEnd) {\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.hasShown = true;\n      comment.clearActivation();\n      comment.lane = -1;\n      if (isDebugLoggingEnabled()) {\n        debugLog(\"comment-skip-expired\", {\n          preview: formatCommentPreview(comment.text),\n          vposMs: comment.vposMs,\n          effectiveVposMs: effectiveVpos,\n          referenceTime,\n          displayEnd,\n        });\n      }\n      return;\n    }\n\n    const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n    const laneIndex = this.assignStaticLane(staticPosition, comment, displayHeight, referenceTime);\n    comment.lane = laneIndex;\n    comment.y = this.resolveStaticCommentOffset(staticPosition, laneIndex, displayHeight, comment);\n    comment.x = comment.virtualStartX;\n    comment.isActive = true;\n    this.activeComments.add(comment);\n    comment.hasShown = true;\n    comment.isPaused = !this.isPlaying;\n    comment.markActivated(referenceTime);\n    comment.lastUpdateTime = this.timeSource.now();\n    comment.staticExpiryTimeMs = displayEnd;\n    this.reserveStaticLane(staticPosition, comment, laneIndex, displayEnd);\n    if (isDebugLoggingEnabled()) {\n      debugLog(\"comment-activate-static\", {\n        preview: formatCommentPreview(comment.text),\n        lane: comment.lane,\n        position: staticPosition,\n        displayEnd,\n        effectiveVposMs: effectiveVpos,\n      });\n    }\n  }\n\n  private assignStaticLane(\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    displayHeight: number,\n    currentTime: number,\n  ): number {\n    const reservations = this.getStaticReservations(position);\n    const limit = this.getStaticLaneLimit(position);\n    const laneCount = limit >= 0 ? limit + 1 : 0;\n    const laneIndices = Array.from({ length: laneCount }, (_, index) => index);\n\n    // 各候補レーンに対してY座標を計算し、重なりがないかチェック\n    for (const lane of laneIndices) {\n      // このレーンに配置した場合のY座標範囲を計算\n      const yOffset = this.resolveStaticCommentOffset(position, lane, displayHeight, comment);\n      const commentHeight = Math.max(comment.height, comment.fontSize);\n      const padding = calculateStaticCommentVerticalPadding(comment.fontSize);\n      const yStart = yOffset - padding;\n      const yEnd = yOffset + commentHeight + padding;\n\n      // 既存の予約と重なりがないかチェック\n      const hasConflict = reservations.some((reservation) => {\n        // 時間的な重なりチェック（余裕を持たせる）\n        const timeOverlap = reservation.releaseTime > currentTime;\n        if (!timeOverlap) {\n          return false;\n        }\n\n        // Y座標の重なりチェック\n        const yOverlap = !(yEnd <= reservation.yStart || yStart >= reservation.yEnd);\n        return yOverlap;\n      });\n\n      if (!hasConflict) {\n        return lane;\n      }\n    }\n\n    // 全レーンに衝突がある場合、最も早くリリースされるレーンを選択\n    let fallbackLane = laneIndices[0] ?? 0;\n    let earliestRelease = Number.POSITIVE_INFINITY;\n    for (const reservation of reservations) {\n      if (reservation.releaseTime < earliestRelease) {\n        earliestRelease = reservation.releaseTime;\n        fallbackLane = reservation.lane;\n      }\n    }\n    return fallbackLane;\n  }\n\n  private reserveStaticLane(\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    lane: number,\n    releaseTime: number,\n  ): void {\n    const reservations = this.getStaticReservations(position);\n    const commentHeight = Math.max(comment.height, comment.fontSize);\n    const padding = calculateStaticCommentVerticalPadding(comment.fontSize);\n    const yStart = comment.y - padding;\n    const yEnd = comment.y + commentHeight + padding;\n\n    reservations.push({\n      comment,\n      releaseTime,\n      yStart,\n      yEnd,\n      lane,\n    });\n  }\n\n  private releaseStaticLane(position: \"ue\" | \"shita\", lane: number): void {\n    if (lane < 0) {\n      return;\n    }\n    const reservations = this.getStaticReservations(position);\n    const index = reservations.findIndex((r) => r.lane === lane);\n    if (index >= 0) {\n      reservations.splice(index, 1);\n    }\n  }\n\n  private getLanePriorityOrder(currentTime: number): number[] {\n    const indices = Array.from({ length: this.laneCount }, (_, index) => index);\n    const sorted = indices.sort((a, b) => {\n      const nextA = this.getLaneNextAvailableTime(a, currentTime);\n      const nextB = this.getLaneNextAvailableTime(b, currentTime);\n      if (Math.abs(nextA - nextB) <= EDGE_EPSILON) {\n        return a - b;\n      }\n      return nextA - nextB;\n    });\n    const staticReserved = this.getStaticReservedLaneSet();\n    if (staticReserved.size === 0) {\n      return sorted;\n    }\n    const preferred = sorted.filter((lane) => !staticReserved.has(lane));\n    if (preferred.length === 0) {\n      return sorted;\n    }\n    const blocked = sorted.filter((lane) => staticReserved.has(lane));\n    return [...preferred, ...blocked];\n  }\n\n  private getLaneNextAvailableTime(lane: number, currentTime: number): number {\n    const reservations = this.reservedLanes.get(lane);\n    if (!reservations || reservations.length === 0) {\n      return currentTime;\n    }\n    // 有効な予約から開始して最大のendTimeを見つける\n    const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n    let nextTime = currentTime;\n    for (let i = firstValidIndex; i < reservations.length; i++) {\n      const reservation = reservations[i];\n      if (reservation !== undefined) {\n        nextTime = Math.max(nextTime, reservation.endTime);\n      }\n    }\n    return nextTime;\n  }\n\n  private createLaneReservation(comment: Comment, referenceTime: number): LaneReservation {\n    const speed = Math.max(comment.speedPixelsPerMs, EDGE_EPSILON);\n    const effectiveStart = this.getEffectiveCommentVpos(comment);\n    const baseStartTime = Number.isFinite(effectiveStart) ? effectiveStart : referenceTime;\n    const startTime = Math.max(0, baseStartTime);\n    const endTime = startTime + comment.preCollisionDurationMs + RESERVATION_TIME_MARGIN_MS;\n    const totalEndTime = startTime + comment.totalDurationMs + RESERVATION_TIME_MARGIN_MS;\n    return {\n      comment,\n      startTime,\n      endTime: Math.max(startTime, endTime),\n      totalEndTime: Math.max(startTime, totalEndTime),\n      startLeft: comment.virtualStartX,\n      width: comment.width,\n      speed,\n      buffer: comment.bufferWidth,\n      directionSign: comment.getDirectionSign(),\n    };\n  }\n\n  private isLaneAvailable(lane: number, candidate: LaneReservation, currentTime: number): boolean {\n    const reservations = this.reservedLanes.get(lane);\n    if (!reservations || reservations.length === 0) {\n      return true;\n    }\n    // リストはtotalEndTimeでソート済みなので、有効な予約から開始\n    const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n    for (let i = firstValidIndex; i < reservations.length; i++) {\n      const reservation = reservations[i];\n      if (reservation === undefined) {\n        break;\n      }\n      if (this.areReservationsConflicting(reservation, candidate)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private storeLaneReservation(lane: number, reservation: LaneReservation): void {\n    const existing = this.reservedLanes.get(lane) ?? [];\n    // totalEndTimeでソートすることで、期限切れ予約の削除を効率化\n    const updated = [...existing, reservation].sort((a, b) => a.totalEndTime - b.totalEndTime);\n    this.reservedLanes.set(lane, updated);\n  }\n\n  private areReservationsConflicting(a: LaneReservation, b: LaneReservation): boolean {\n    const overlapStart = Math.max(a.startTime, b.startTime);\n    const overlapEnd = Math.min(a.endTime, b.endTime);\n    if (overlapStart >= overlapEnd) {\n      return false;\n    }\n\n    const evaluationTimes = new Set<number>([\n      overlapStart,\n      overlapEnd,\n      overlapStart + (overlapEnd - overlapStart) / 2,\n    ]);\n\n    const forwardIntersection = this.solveLeftRightEqualityTime(a, b);\n    if (\n      forwardIntersection !== null &&\n      forwardIntersection >= overlapStart - EDGE_EPSILON &&\n      forwardIntersection <= overlapEnd + EDGE_EPSILON\n    ) {\n      evaluationTimes.add(forwardIntersection);\n    }\n\n    const backwardIntersection = this.solveLeftRightEqualityTime(b, a);\n    if (\n      backwardIntersection !== null &&\n      backwardIntersection >= overlapStart - EDGE_EPSILON &&\n      backwardIntersection <= overlapEnd + EDGE_EPSILON\n    ) {\n      evaluationTimes.add(backwardIntersection);\n    }\n\n    for (const time of evaluationTimes) {\n      if (time < overlapStart - EDGE_EPSILON || time > overlapEnd + EDGE_EPSILON) {\n        continue;\n      }\n      const forwardGap = this.computeForwardGap(a, b, time);\n      const backwardGap = this.computeForwardGap(b, a, time);\n      if (forwardGap <= EDGE_EPSILON && backwardGap <= EDGE_EPSILON) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private computeForwardGap(from: LaneReservation, to: LaneReservation, time: number): number {\n    const fromEdges = this.getBufferedEdges(from, time);\n    const toEdges = this.getBufferedEdges(to, time);\n    return fromEdges.left - toEdges.right;\n  }\n\n  private getBufferedEdges(\n    reservation: LaneReservation,\n    time: number,\n  ): { left: number; right: number } {\n    const elapsed = Math.max(0, time - reservation.startTime);\n    const displacement = reservation.speed * elapsed;\n    const rawLeft = reservation.startLeft + reservation.directionSign * displacement;\n    const left = rawLeft - reservation.buffer;\n    const right = rawLeft + reservation.width + reservation.buffer;\n    return { left, right };\n  }\n\n  private solveLeftRightEqualityTime(left: LaneReservation, right: LaneReservation): number | null {\n    const leftSign = left.directionSign;\n    const rightSign = right.directionSign;\n    const denominator = rightSign * right.speed - leftSign * left.speed;\n    if (Math.abs(denominator) < EDGE_EPSILON) {\n      return null;\n    }\n    const numerator =\n      right.startLeft +\n      rightSign * right.speed * right.startTime +\n      right.width +\n      right.buffer -\n      left.startLeft -\n      leftSign * left.speed * left.startTime +\n      left.buffer;\n    const time = numerator / denominator;\n    if (!Number.isFinite(time)) {\n      return null;\n    }\n    return time;\n  }\n\n  private draw(): void {\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (!canvas || !context) {\n      return;\n    }\n\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n\n    const now = this.timeSource.now();\n\n    if (this.skipDrawingForCurrentFrame || this.shouldSuppressRendering() || this.isStalled) {\n      context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n      this.lastDrawTime = now;\n      return;\n    }\n\n    context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    const activeComments = Array.from(this.activeComments);\n\n    if (this._settings.isCommentVisible) {\n      const deltaTime = (now - this.lastDrawTime) / (1000 / 60);\n      activeComments.sort((a, b) => {\n        const aVpos = this.getEffectiveCommentVpos(a);\n        const bVpos = this.getEffectiveCommentVpos(b);\n        const vposMsDiff = aVpos - bVpos;\n        if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n          return vposMsDiff;\n        }\n        if (a.isScrolling !== b.isScrolling) {\n          return a.isScrolling ? 1 : -1;\n        }\n        return a.creationIndex - b.creationIndex;\n      });\n      activeComments.forEach((comment) => {\n        const shouldInterpolate = this.isPlaying && !comment.isPaused;\n        const interpolatedX = shouldInterpolate\n          ? comment.x + comment.getDirectionSign() * comment.speed * deltaTime\n          : comment.x;\n        comment.draw(context, interpolatedX);\n      });\n    }\n\n    this.lastDrawTime = now;\n  }\n\n  /**\n   * 初回フレームで絶対時間同期を実行\n   * 相対進行（dt積分）で初期区間を駆け抜けないようにする\n   */\n  private performInitialSync(frameTimeMs?: number): void {\n    const video = this.videoElement;\n    const canvas = this.canvas;\n    const context = this.ctx;\n    if (!video || !canvas || !context) {\n      return;\n    }\n\n    // 絶対時間を取得（VFCのmediaTimeまたはvideo.currentTime）\n    const absoluteTime =\n      typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n    this.currentTime = absoluteTime;\n    this.lastDrawTime = this.timeSource.now();\n\n    // 既存のアクティブコメントは全てクリア済み（hardReset()で実施）\n    // 現在時刻に基づいてコメントを再配置（onSeek()と同様のロジック）\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n    // 時間ウィンドウ内のコメントを取得\n    const windowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n    windowComments.forEach((comment) => {\n      if (this.isNGComment(comment.text) || comment.isInvisible) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n        return;\n      }\n\n      comment.syncWithSettings(this._settings, this.settingsVersion);\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.lane = -1;\n      comment.clearActivation();\n\n      if (this.shouldActivateCommentAtTime(comment, this.currentTime)) {\n        this.activateComment(\n          comment,\n          context,\n          effectiveWidth,\n          effectiveHeight,\n          prepareOptions,\n          this.currentTime,\n        );\n        return;\n      }\n\n      const effectiveVpos = this.getEffectiveCommentVpos(comment);\n      if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n        comment.hasShown = true;\n      } else {\n        comment.hasShown = false;\n      }\n    });\n  }\n\n  private processFrame(frameTimeMs?: number): void {\n    if (!this.videoElement) {\n      return;\n    }\n    if (!this._settings.isCommentVisible) {\n      return;\n    }\n\n    // 初回フレームでは絶対時間同期を実行\n    if (this.pendingInitialSync) {\n      this.performInitialSync(frameTimeMs);\n      this.pendingInitialSync = false;\n    }\n\n    this.updateComments(frameTimeMs);\n    this.draw();\n  }\n\n  private readonly handleAnimationFrame = (): void => {\n    const pendingId = this.frameId;\n    this.frameId = null;\n    if (pendingId !== null) {\n      this.animationFrameProvider.cancel(pendingId);\n    }\n    this.processFrame();\n    this.scheduleNextFrame();\n  };\n\n  private readonly handleVideoFrame = (\n    _now: DOMHighResTimeStamp,\n    metadata: VideoFrameCallbackMetadataLike,\n  ): void => {\n    this.videoFrameHandle = null;\n    const mediaTime =\n      typeof metadata?.mediaTime === \"number\" ? metadata.mediaTime * 1000 : undefined;\n    this.processFrame(typeof mediaTime === \"number\" ? mediaTime : undefined);\n    this.scheduleNextFrame();\n  };\n\n  private shouldUseVideoFrameCallback(): boolean {\n    if (this._settings.syncMode !== \"video-frame\") {\n      return false;\n    }\n    const video = this.videoElement as HTMLVideoElement & {\n      requestVideoFrameCallback?: RequestVideoFrameCallback;\n      cancelVideoFrameCallback?: CancelVideoFrameCallback;\n    };\n    return (\n      Boolean(video) &&\n      typeof video.requestVideoFrameCallback === \"function\" &&\n      typeof video.cancelVideoFrameCallback === \"function\"\n    );\n  }\n\n  private scheduleNextFrame(): void {\n    const video = this.videoElement;\n    if (!video) {\n      return;\n    }\n    if (this.shouldUseVideoFrameCallback()) {\n      this.cancelAnimationFrameRequest();\n      this.cancelVideoFrameCallback();\n      const request = (\n        video as HTMLVideoElement & {\n          requestVideoFrameCallback?: RequestVideoFrameCallback;\n        }\n      ).requestVideoFrameCallback;\n      if (typeof request === \"function\") {\n        this.videoFrameHandle = request.call(video, this.handleVideoFrame);\n      }\n      return;\n    }\n    this.cancelVideoFrameCallback();\n    this.frameId = this.animationFrameProvider.request(this.handleAnimationFrame);\n  }\n\n  private cancelAnimationFrameRequest(): void {\n    if (this.frameId !== null) {\n      this.animationFrameProvider.cancel(this.frameId);\n      this.frameId = null;\n    }\n  }\n\n  private cancelVideoFrameCallback(): void {\n    if (this.videoFrameHandle === null) {\n      return;\n    }\n    const video = this.videoElement as HTMLVideoElement & {\n      cancelVideoFrameCallback?: CancelVideoFrameCallback;\n    };\n    if (video && typeof video.cancelVideoFrameCallback === \"function\") {\n      video.cancelVideoFrameCallback(this.videoFrameHandle);\n    }\n    this.videoFrameHandle = null;\n  }\n\n  private startAnimation(): void {\n    this.stopAnimation();\n    this.scheduleNextFrame();\n  }\n\n  private stopAnimation(): void {\n    this.cancelAnimationFrameRequest();\n    this.cancelVideoFrameCallback();\n  }\n\n  private onSeek(): void {\n    const canvas = this.canvas;\n    const context = this.ctx;\n    const video = this.videoElement;\n    if (!canvas || !context || !video) {\n      return;\n    }\n\n    const nextTime = toMilliseconds(video.currentTime);\n    this.currentTime = nextTime;\n    this.resetFinalPhaseState();\n    this.updatePlaybackProgressState();\n\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n    // シーク時も時間インデックスを用いて範囲を限定\n    // ただし、シーク後のhasShown状態更新のため、範囲外も一部処理する\n    const seekWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n    seekWindowComments.forEach((comment) => {\n      const debugActive = isDebugLoggingEnabled();\n      const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n      if (debugActive) {\n        debugLog(\"comment-evaluate\", {\n          stage: \"seek\",\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          currentTime: this.currentTime,\n          isActive: comment.isActive,\n          hasShown: comment.hasShown,\n        });\n      }\n\n      if (this.isNGComment(comment.text)) {\n        if (debugActive) {\n          debugLog(\"comment-eval-skip\", {\n            preview,\n            vposMs: comment.vposMs,\n            effectiveVposMs: this.getEffectiveCommentVpos(comment),\n            reason: \"ng-runtime\",\n          });\n        }\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n        return;\n      }\n\n      if (comment.isInvisible) {\n        if (debugActive) {\n          debugLog(\"comment-eval-skip\", {\n            preview,\n            vposMs: comment.vposMs,\n            effectiveVposMs: this.getEffectiveCommentVpos(comment),\n            reason: \"invisible\",\n          });\n        }\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.hasShown = true;\n        comment.clearActivation();\n        return;\n      }\n\n      comment.syncWithSettings(this._settings, this.settingsVersion);\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.lane = -1;\n      comment.clearActivation();\n\n      if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n        this.activateComment(\n          comment,\n          context,\n          effectiveWidth,\n          effectiveHeight,\n          prepareOptions,\n          this.currentTime,\n        );\n        return;\n      }\n\n      const effectiveVpos = this.getEffectiveCommentVpos(comment);\n      if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n        comment.hasShown = true;\n      } else {\n        comment.hasShown = false;\n      }\n    });\n\n    if (this._settings.isCommentVisible) {\n      this.lastDrawTime = this.timeSource.now();\n      this.draw();\n    }\n  }\n\n  private setupVideoEventListeners(videoElement: HTMLVideoElement): void {\n    try {\n      const onPlay = (): void => {\n        this.isPlaying = true;\n        this.playbackHasBegun = true;\n        const now = this.timeSource.now();\n        this.lastDrawTime = now;\n\n        // 再生開始時に前エポックのゴーストコメントを掃除\n        // 次のフレームで絶対時間同期を行う\n        if (!this.pendingInitialSync) {\n          this.hardReset();\n        }\n\n        this.comments.forEach((comment) => {\n          comment.lastUpdateTime = now;\n          comment.isPaused = false;\n        });\n      };\n      const onPause = (): void => {\n        this.isPlaying = false;\n        const now = this.timeSource.now();\n        this.comments.forEach((comment) => {\n          comment.lastUpdateTime = now;\n          comment.isPaused = true;\n        });\n      };\n      const onSeeking = (): void => {\n        this.onSeek();\n      };\n      const onSeeked = (): void => {\n        this.onSeek();\n      };\n      const onRateChange = (): void => {\n        this.playbackRate = videoElement.playbackRate;\n        const now = this.timeSource.now();\n        this.comments.forEach((comment) => {\n          comment.lastUpdateTime = now;\n        });\n      };\n      const onLoadedMetadata = (): void => {\n        this.handleVideoMetadataLoaded(videoElement);\n      };\n      const onDurationChange = (): void => {\n        this.duration = Number.isFinite(videoElement.duration)\n          ? toMilliseconds(videoElement.duration)\n          : 0;\n      };\n      const onEmptied = (): void => {\n        this.handleVideoSourceChange();\n      };\n      const onWaiting = (): void => {\n        this.handleVideoStalled();\n      };\n      const onCanPlay = (): void => {\n        this.handleVideoCanPlay();\n      };\n      const onPlaying = (): void => {\n        this.handleVideoCanPlay();\n      };\n\n      videoElement.addEventListener(\"play\", onPlay);\n      videoElement.addEventListener(\"pause\", onPause);\n      videoElement.addEventListener(\"seeking\", onSeeking);\n      videoElement.addEventListener(\"seeked\", onSeeked);\n      videoElement.addEventListener(\"ratechange\", onRateChange);\n      videoElement.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n      videoElement.addEventListener(\"durationchange\", onDurationChange);\n      videoElement.addEventListener(\"emptied\", onEmptied);\n      videoElement.addEventListener(\"waiting\", onWaiting);\n      videoElement.addEventListener(\"canplay\", onCanPlay);\n      videoElement.addEventListener(\"playing\", onPlaying);\n\n      this.addCleanup(() => videoElement.removeEventListener(\"play\", onPlay));\n      this.addCleanup(() => videoElement.removeEventListener(\"pause\", onPause));\n      this.addCleanup(() => videoElement.removeEventListener(\"seeking\", onSeeking));\n      this.addCleanup(() => videoElement.removeEventListener(\"seeked\", onSeeked));\n      this.addCleanup(() => videoElement.removeEventListener(\"ratechange\", onRateChange));\n      this.addCleanup(() => videoElement.removeEventListener(\"loadedmetadata\", onLoadedMetadata));\n      this.addCleanup(() => videoElement.removeEventListener(\"durationchange\", onDurationChange));\n      this.addCleanup(() => videoElement.removeEventListener(\"emptied\", onEmptied));\n      this.addCleanup(() => videoElement.removeEventListener(\"waiting\", onWaiting));\n      this.addCleanup(() => videoElement.removeEventListener(\"canplay\", onCanPlay));\n      this.addCleanup(() => videoElement.removeEventListener(\"playing\", onPlaying));\n    } catch (error) {\n      this.log.error(\"CommentRenderer.setupVideoEventListeners\", error as Error);\n      throw error;\n    }\n  }\n\n  private handleVideoMetadataLoaded(videoElement: HTMLVideoElement): void {\n    this.handleVideoSourceChange(videoElement);\n    this.resize();\n    this.calculateLaneMetrics();\n    // メタデータロード時に絶対時間同期を準備\n    this.hardReset();\n    this.onSeek();\n  }\n\n  private handleVideoStalled(): void {\n    const canvas = this.canvas;\n    const ctx = this.ctx;\n    if (!canvas || !ctx) {\n      return;\n    }\n\n    this.isStalled = true;\n\n    // キャンバスをクリア\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n\n    // アクティブコメントの状態を保持しつつ、描画をクリア\n    // （ストール解除後に再描画されるよう、isActiveは維持）\n    this.comments.forEach((comment) => {\n      if (comment.isActive) {\n        comment.lastUpdateTime = this.timeSource.now();\n      }\n    });\n  }\n\n  private handleVideoCanPlay(): void {\n    if (!this.isStalled) {\n      return;\n    }\n\n    this.isStalled = false;\n\n    // 時刻を同期\n    if (this.videoElement) {\n      this.currentTime = toMilliseconds(this.videoElement.currentTime);\n      this.isPlaying = !this.videoElement.paused;\n    }\n\n    // lastDrawTimeを更新して補間計算を正常化\n    this.lastDrawTime = this.timeSource.now();\n\n    // 次のフレームで描画を再開\n    // （アニメーションループが動いているので自動的に再描画される）\n  }\n\n  private handleVideoSourceChange(videoElement?: HTMLVideoElement | null): void {\n    const target = videoElement ?? this.videoElement;\n    if (!target) {\n      this.isPlaying = false;\n      this.resetFinalPhaseState();\n      this.resetCommentActivity();\n      return;\n    }\n    this.syncVideoState(target);\n    this.resetFinalPhaseState();\n    this.resetCommentActivity();\n  }\n\n  private syncVideoState(videoElement: HTMLVideoElement): void {\n    this.duration = Number.isFinite(videoElement.duration)\n      ? toMilliseconds(videoElement.duration)\n      : 0;\n    this.currentTime = toMilliseconds(videoElement.currentTime);\n    this.playbackRate = videoElement.playbackRate;\n    this.isPlaying = !videoElement.paused;\n    this.isStalled = false;\n    this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n    this.lastDrawTime = this.timeSource.now();\n  }\n\n  private resetCommentActivity(): void {\n    const now = this.timeSource.now();\n    const canvas = this.canvas;\n    const context = this.ctx;\n    this.resetFinalPhaseState();\n    this.skipDrawingForCurrentFrame = false;\n    this.isStalled = false;\n    this.pendingInitialSync = false;\n    this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n    if (canvas && context) {\n      const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n      const width = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n      const height = this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n      context.clearRect(0, 0, width, height);\n    }\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n    this.comments.forEach((comment) => {\n      comment.isActive = false;\n      comment.isPaused = !this.isPlaying;\n      comment.hasShown = false;\n      comment.lane = -1;\n      comment.x = comment.virtualStartX;\n      comment.speed = comment.baseSpeed;\n      comment.lastUpdateTime = now;\n      comment.clearActivation();\n    });\n    this.activeComments.clear();\n  }\n\n  private setupVideoChangeDetection(videoElement: HTMLVideoElement, container: HTMLElement): void {\n    if (typeof MutationObserver === \"undefined\") {\n      this.log.debug(\n        \"MutationObserver is not available in this environment. Video change detection is disabled.\",\n      );\n      return;\n    }\n\n    const videoObserver = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type === \"attributes\" && mutation.attributeName === \"src\") {\n          const targetNode = mutation.target;\n          let previous: string | null = null;\n          let current: string | null = null;\n          if (targetNode instanceof HTMLVideoElement || targetNode instanceof HTMLSourceElement) {\n            previous = typeof mutation.oldValue === \"string\" ? mutation.oldValue : null;\n            current = targetNode.getAttribute(\"src\");\n          }\n          if (previous === current) {\n            continue;\n          }\n          this.handleVideoSourceChange(videoElement);\n          return;\n        }\n        if (mutation.type === \"childList\") {\n          for (const node of mutation.addedNodes) {\n            if (node instanceof HTMLSourceElement) {\n              this.handleVideoSourceChange(videoElement);\n              return;\n            }\n          }\n          for (const node of mutation.removedNodes) {\n            if (node instanceof HTMLSourceElement) {\n              this.handleVideoSourceChange(videoElement);\n              return;\n            }\n          }\n        }\n      }\n    });\n\n    videoObserver.observe(videoElement, {\n      attributes: true,\n      attributeFilter: [\"src\"],\n      attributeOldValue: true,\n      childList: true,\n      subtree: true,\n    });\n    this.addCleanup(() => videoObserver.disconnect());\n\n    const containerObserver = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        if (mutation.type !== \"childList\") {\n          continue;\n        }\n        for (const node of mutation.addedNodes) {\n          const nextVideo = this.extractVideoElement(node);\n          if (nextVideo && nextVideo !== this.videoElement) {\n            this.initialize(nextVideo);\n            return;\n          }\n        }\n        for (const node of mutation.removedNodes) {\n          if (node === this.videoElement) {\n            this.videoElement = null;\n            this.handleVideoSourceChange(null);\n            return;\n          }\n          if (node instanceof Element) {\n            const removedVideo = node.querySelector(\"video\");\n            if (removedVideo && removedVideo === this.videoElement) {\n              this.videoElement = null;\n              this.handleVideoSourceChange(null);\n              return;\n            }\n          }\n        }\n      }\n    });\n\n    containerObserver.observe(container, { childList: true, subtree: true });\n    this.addCleanup(() => containerObserver.disconnect());\n  }\n\n  private extractVideoElement(node: Node): HTMLVideoElement | null {\n    if (node instanceof HTMLVideoElement) {\n      return node;\n    }\n    if (node instanceof Element) {\n      const candidate = node.querySelector(\"video\");\n      if (candidate instanceof HTMLVideoElement) {\n        return candidate;\n      }\n    }\n    return null;\n  }\n\n  private setupVisibilityHandling(): void {\n    if (\n      typeof document === \"undefined\" ||\n      typeof document.addEventListener !== \"function\" ||\n      typeof document.removeEventListener !== \"function\"\n    ) {\n      return;\n    }\n\n    const enforceVisibilityState = (): void => {\n      const state = document.visibilityState;\n      if (state !== \"visible\") {\n        this.stopAnimation();\n        return;\n      }\n      if (!this._settings.isCommentVisible) {\n        return;\n      }\n      // ビジビリティ復帰時にコメント状態をリセット\n      this.handleVisibilityRestore();\n      this.startAnimation();\n    };\n\n    document.addEventListener(\"visibilitychange\", enforceVisibilityState);\n    this.addCleanup(() => document.removeEventListener(\"visibilitychange\", enforceVisibilityState));\n\n    if (document.visibilityState !== \"visible\") {\n      this.stopAnimation();\n    }\n  }\n\n  private handleVisibilityRestore(): void {\n    const canvas = this.canvas;\n    const ctx = this.ctx;\n    const video = this.videoElement;\n    if (!canvas || !ctx || !video) {\n      return;\n    }\n\n    // ビデオ時刻を更新（visibilitychange中に時間が進んでいる可能性がある）\n    this.currentTime = toMilliseconds(video.currentTime);\n    this.isPlaying = !video.paused;\n\n    // 内部状態を完全にクリア\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n\n    // キャンバスをクリア\n    ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n\n    const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n    const now = this.timeSource.now();\n\n    // アクティブウィンドウ内のコメントを再評価\n    const windowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n    windowComments.forEach((comment) => {\n      if (this.isNGComment(comment.text) || comment.isInvisible) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n        return;\n      }\n\n      comment.syncWithSettings(this._settings, this.settingsVersion);\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.lane = -1;\n      comment.clearActivation();\n      comment.lastUpdateTime = now;\n\n      if (this.shouldActivateCommentAtTime(comment, this.currentTime)) {\n        this.activateComment(\n          comment,\n          ctx,\n          effectiveWidth,\n          effectiveHeight,\n          prepareOptions,\n          this.currentTime,\n        );\n      }\n\n      const effectiveVpos = this.getEffectiveCommentVpos(comment);\n      if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n        comment.hasShown = true;\n      } else if (effectiveVpos > this.currentTime) {\n        comment.hasShown = false;\n      }\n    });\n\n    // lastDrawTimeを更新して補間計算を正常化\n    this.lastDrawTime = now;\n  }\n\n  private setupResizeHandling(videoElement: HTMLVideoElement): void {\n    this.cleanupResizeHandling();\n\n    if (this._settings.useContainerResizeObserver && this.isResizeObserverAvailable) {\n      const target = this.resolveResizeObserverTarget(videoElement);\n      const observer = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          const { width, height } = entry.contentRect;\n          if (width > 0 && height > 0) {\n            this.resize(width, height);\n          } else {\n            this.resize();\n          }\n        }\n      });\n      observer.observe(target);\n      this.resizeObserver = observer;\n      this.resizeObserverTarget = target;\n    } else if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\") {\n      const onResize = (): void => {\n        this.resize();\n      };\n      window.addEventListener(\"resize\", onResize);\n      this.addCleanup(() => window.removeEventListener(\"resize\", onResize));\n    } else {\n      this.log.debug(\n        \"Resize handling is disabled because neither ResizeObserver nor window APIs are available.\",\n      );\n    }\n  }\n\n  private cleanupResizeHandling(): void {\n    if (this.resizeObserver && this.resizeObserverTarget) {\n      this.resizeObserver.unobserve(this.resizeObserverTarget);\n    }\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n    this.resizeObserverTarget = null;\n  }\n\n  private setupFullscreenHandling(): void {\n    if (\n      typeof document === \"undefined\" ||\n      typeof document.addEventListener !== \"function\" ||\n      typeof document.removeEventListener !== \"function\"\n    ) {\n      return;\n    }\n\n    const onFullscreenChange = (): void => {\n      void this.handleFullscreenChange();\n    };\n\n    const events = [\n      \"fullscreenchange\",\n      \"webkitfullscreenchange\",\n      \"mozfullscreenchange\",\n      \"MSFullscreenChange\",\n    ];\n\n    events.forEach((eventName) => {\n      document.addEventListener(eventName, onFullscreenChange);\n      this.addCleanup(() => document.removeEventListener(eventName, onFullscreenChange));\n    });\n\n    void this.handleFullscreenChange();\n  }\n\n  private resolveResizeObserverTarget(videoElement: HTMLVideoElement): Element {\n    const fullscreenContainer = this.resolveFullscreenContainer(videoElement);\n    if (fullscreenContainer) {\n      return fullscreenContainer;\n    }\n    return videoElement.parentElement ?? videoElement;\n  }\n\n  private async handleFullscreenChange(): Promise<void> {\n    const canvas = this.canvas;\n    const video = this.videoElement;\n    if (!canvas || !video) {\n      return;\n    }\n\n    const baseContainer = this.containerElement ?? video.parentElement ?? null;\n    const fullscreenElement = this.getFullscreenElement();\n    const nextContainer = this.resolveActiveOverlayContainer(\n      video,\n      baseContainer,\n      fullscreenElement,\n    );\n\n    if (!(nextContainer instanceof HTMLElement)) {\n      return;\n    }\n\n    if (canvas.parentElement !== nextContainer) {\n      this.ensureContainerPositioning(nextContainer);\n      nextContainer.appendChild(canvas);\n    } else {\n      this.ensureContainerPositioning(nextContainer);\n    }\n\n    const fullscreenContainer =\n      fullscreenElement instanceof HTMLElement && fullscreenElement.contains(video)\n        ? fullscreenElement\n        : null;\n    const isFullscreenNow = fullscreenContainer !== null;\n    if (this.fullscreenActive !== isFullscreenNow) {\n      this.fullscreenActive = isFullscreenNow;\n      this.setupResizeHandling(video);\n    }\n\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0\";\n    canvas.style.left = \"0\";\n\n    this.resize();\n  }\n\n  private resolveFullscreenContainer(videoElement: HTMLVideoElement): HTMLElement | null {\n    const fullscreenElement = this.getFullscreenElement();\n    if (!(fullscreenElement instanceof HTMLElement)) {\n      return null;\n    }\n    if (fullscreenElement === videoElement) {\n      return fullscreenElement;\n    }\n    if (fullscreenElement.contains(videoElement)) {\n      return fullscreenElement;\n    }\n    return null;\n  }\n\n  private resolveActiveOverlayContainer(\n    videoElement: HTMLVideoElement,\n    baseContainer: HTMLElement | null,\n    fullscreenElement: Element | null,\n  ): HTMLElement | null {\n    if (fullscreenElement instanceof HTMLElement && fullscreenElement.contains(videoElement)) {\n      if (fullscreenElement instanceof HTMLVideoElement) {\n        if (baseContainer instanceof HTMLElement) {\n          return baseContainer;\n        }\n        return fullscreenElement;\n      }\n      return fullscreenElement;\n    }\n    return baseContainer ?? null;\n  }\n\n  private getFullscreenElement(): Element | null {\n    if (typeof document === \"undefined\") {\n      return null;\n    }\n    const doc = document as Document & {\n      webkitFullscreenElement?: Element | null;\n      msFullscreenElement?: Element | null;\n      mozFullScreenElement?: Element | null;\n    };\n    return (\n      document.fullscreenElement ??\n      doc.webkitFullscreenElement ??\n      doc.mozFullScreenElement ??\n      doc.msFullscreenElement ??\n      null\n    );\n  }\n\n  private addCleanup(task: () => void): void {\n    this.cleanupTasks.push(task);\n  }\n\n  private runCleanupTasks(): void {\n    while (this.cleanupTasks.length > 0) {\n      const task = this.cleanupTasks.pop();\n      try {\n        task?.();\n      } catch (error) {\n        this.log.error(\"CommentRenderer.cleanupTask\", error as Error);\n      }\n    }\n  }\n}\n"],"names":["LEVEL_PRIORITY","fallbackEmitter","level","namespace","args","consoleArgs","createLogger","options","emitter","threshold","emit","logLevel","messages","COMMENT_SIZE_SCALE","FONT_FAMILY_MAP","COLOR_COMMAND_MAP","HEX_COLOR_REGEX","COMMAND_PREFIX_STRIP_REGEX","COMMAND_SUFFIX_STRIP_REGEX","normalizeCommandToken","value","trimmed","normalizeHexColor","command","parseNumericCommandValue","withoutPx","parsed","parseLineHeightValue","numeric","clampLetterSpacing","clampLineHeight","isLayoutCommand","isSizeCommand","isFontCommand","isColorCommand","parseCommentCommands","commands","context","layout","size","font","colorOverride","opacityMultiplier","opacityOverride","isInvisible","letterSpacing","lineHeight","rawCommand","normalizedToken","normalized","lower","separatorIndex","numericValue","clampedOpacityMultiplier","resolvedColor","resolvedOpacityOverride","DEFAULT_MAX_LOGS_PER_CATEGORY","state","categoryCounters","normalizeLimit","limit","rounded","configureDebugLogging","resetDebugCounters","isDebugLoggingEnabled","shouldEmitLog","category","currentCount","debugLog","payload","formatCommentPreview","text","maxLength","logger","textMeasurementCaches","getTextMeasurementCache","ctx","cache","measureTextWidth","cacheKey","cached","width","STATIC_VISIBLE_DURATION_MS","HEX_COLOR_PATTERN","STATIC_COMMENT_SIDE_MARGIN_PX","MIN_STATIC_FONT_SIZE_PX","clampOpacity","expandHex","fragment","parseHexComponent","component","resolveFillStyleWithOpacity","color","opacity","match","body","red","green","blue","alpha","combinedAlpha","createPerformanceTimeSource","createDefaultTimeSource","resolveScrollDirection","input","getDirectionSign","direction","Comment","vposMs","settings","dependencies","parsedCommands","visibleWidth","canvasHeight","safeVisibleWidth","baseFontSize","scaledFontSize","rawLines","isStaticTopOrBottom","maxStaticWidth","minimumFontSize","shrinkFactor","initialShrink","iteration","currentShrink","proposedSize","margin","centeredX","maxStart","clampedX","maxReservationWidth","bufferFromWidth","entryBuffer","startLeft","exitLeft","trailingBoundary","trailingEdgeAtStart","widthRatio","hasFixedDuration","visibleDurationMs","clampedRatio","adjustedDuration","visibleDistance","safeVisibleDuration","pixelsPerMs","pixelsPerFrame","travelDistance","preCollisionDistance","safePixelsPerMs","reservationBase","error","playbackRate","isPaused","currentTime","deltaTime","now","total","hitRate","avgCharsPerComment","totalOutlineCalls","totalFillCalls","hasLetterSpacing","isMultiLine","padding","textureWidth","textureHeight","offscreen","offscreenCtx","effectiveOpacity","drawX","linesToRender","lineAdvance","baselineStart","drawSegment","outlineOffsets","drawOutline","outlineAlpha","offsetX","offsetY","line","index","baseline","drawFill","fillStyle","baseShadowOffset","baseShadowBlur","layer","effectiveShadowAlpha","resolvedFillStyle","interpolatedX","currentCacheKey","settingsVersion","defaultColor","candidate","defaultOpacity","scaled","atTimeMs","currentTimeMs","resolved","targetCtx","measurementCtx","statsTarget","baseDrawX","baselineY","mode","leadingSpaces","leadingSpaceCount","leadingSpaceOffset","effectiveDrawX","trimmedLine","recordDraw","cursorX","char","advance","outlineThickness","offsets","diagonal","maxLineWidth","effectiveLetterSpacing","baseWidth","extraSpacing","totalWidth","computedLineHeightPx","additionalHeight","NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS","BASE_SETTINGS","DEFAULT_RENDERER_SETTINGS","cloneDefaultSettings","COMMENT_OVERLAY_VERSION","toMilliseconds","seconds","sanitizeVposMs","MAX_VISIBLE_DURATION_MS","MIN_VISIBLE_DURATION_MS","MAX_COMMENT_WIDTH_RATIO","COLLISION_BUFFER_RATIO","BASE_COLLISION_BUFFER_PX","ENTRY_BUFFER_PX","RESERVATION_TIME_MARGIN_MS","FINAL_PHASE_THRESHOLD_MS","FINAL_PHASE_MIN_GAP_MS","FINAL_PHASE_MAX_GAP_MS","FINAL_PHASE_ORDER_EPSILON_MS","FINAL_PHASE_MIN_WINDOW_MS","ACTIVE_WINDOW_MS","VIRTUAL_CANVAS_EXTENSION_PX","MIN_LANE_COUNT","DEFAULT_LANE_COUNT","MIN_FONT_SIZE_PX","EDGE_EPSILON","SEEK_DIRECTION_EPSILON_MS","STATIC_COMMENT_VERTICAL_PADDING_RATIO","STATIC_COMMENT_MIN_VERTICAL_PADDING_PX","calculateStaticCommentVerticalPadding","fontSize","normalizeSettings","rawDuration","normalizedDuration","createDefaultAnimationFrameProvider","timeSource","callback","handle","createBrowserCanvasFactory","isRendererSettings","CommentRenderer","settingsOrConfig","maybeConfig","baseSettings","config","configCandidate","explicit","video","container","containerCandidate","canvas","parent","entries","addedComments","entry","preview","normalizedVposMs","comment","a","b","vposMsDiff","effectiveDpr","height","effectiveWidth","effectiveHeight","durations","override","fallback","windowStart","durationMs","windowEnd","candidates","diff","baseGap","boundedGap","gap","nextStart","durationNeeded","availableLatestStart","assigned","epsilon","spacing","newSettings","previousUseContainer","previousDirection","previousUseDprScaling","previousSyncMode","directionChanged","useDprScalingChanged","syncModeChanged","attribute","sourceElement","normalizedWords","compiledRegexps","sourceWords","word","sourcePatterns","pattern","regexError","normalizedText","regexp","rect","currentDpr","fallbackWidth","fallbackHeight","measuredWidth","measuredHeight","cssWidth","cssHeight","previousDisplayWidth","previousDisplayHeight","nextDpr","pixelWidth","pixelHeight","scaleX","scaleY","ratio","baseHeight","availableLanes","desired","clamped","frameTimeMs","referenceTime","prepareOptions","isNearEnd","activeWindowComments","debugActive","staticPosition","overrideDuration","maxVisibleDurationMs","minVisibleDurationMs","laneCandidates","newReservation","lane","fallbackLane","reservations","cutoffTime","left","right","mid","reservation","firstValidIndex","filterValid","topFiltered","bottomFiltered","targetVposMs","centerTimeMs","windowMs","startTime","endTime","startIndex","result","i","position","maxIndex","otherPosition","otherDepth","available","localIndex","clampedLaneCount","clampedIndex","displayHeight","commentHeight","baseY","minY","maxY","adjustedY","reserved","timeMs","effectiveVpos","displayWidth","elapsedMs","displacement","videoDuration","finalPhaseWindowEnd","availableTravelTime","requiredSpeedPixelsPerMs","directionSign","projectedX","exitThreshold","displayEnd","laneIndex","laneCount","laneIndices","_","yOffset","yStart","yEnd","earliestRelease","releaseTime","r","sorted","nextA","nextB","staticReserved","preferred","blocked","nextTime","speed","effectiveStart","baseStartTime","totalEndTime","updated","overlapStart","overlapEnd","evaluationTimes","forwardIntersection","backwardIntersection","time","forwardGap","backwardGap","from","to","fromEdges","toEdges","elapsed","rawLeft","leftSign","rightSign","denominator","activeComments","aVpos","bVpos","absoluteTime","pendingId","_now","metadata","mediaTime","request","videoElement","onPlay","onPause","onSeeking","onSeeked","onRateChange","onLoadedMetadata","onDurationChange","onEmptied","onWaiting","onCanPlay","onPlaying","target","videoObserver","mutations","mutation","targetNode","previous","current","node","containerObserver","nextVideo","removedVideo","enforceVisibilityState","observer","onResize","onFullscreenChange","eventName","fullscreenContainer","baseContainer","fullscreenElement","nextContainer","isFullscreenNow","doc","task"],"mappings":"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"}