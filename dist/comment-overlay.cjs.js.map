{"version":3,"file":"comment-overlay.cjs.js","sources":["../src/comment/comment-commands.ts","../src/comment/color.ts","../src/comment/time-source.ts","../src/shared/constants.ts","../src/shared/logger.ts","../src/comment/logger.ts","../src/comment/text-measure.ts","../src/comment/prepare.ts","../src/shared/debug.ts","../src/comment/render.ts","../src/comment/direction.ts","../src/comment/comment.ts","../src/config/default-settings.ts","../src/shared/settings.ts","../src/renderer/comments.ts","../src/renderer/final-phase.ts","../src/renderer/playback.ts","../src/renderer/activation.ts","../src/renderer/lanes-prune.ts","../src/renderer/lanes-static.ts","../src/renderer/lanes-activation.ts","../src/renderer/lanes-reservations.ts","../src/renderer/render.ts","../src/renderer/timing.ts","../src/renderer/auto-hard-reset.ts","../src/renderer/lifecycle-core.ts","../src/renderer/lifecycle-video-events.ts","../src/renderer/visibility.ts","../src/renderer/resize.ts","../src/renderer/fullscreen.ts","../src/renderer/cleanup.ts","../src/renderer/comment-renderer.ts"],"sourcesContent":["import {\n  type CommentColorCommand,\n  type CommentCommandParseContext,\n  type CommentCommandParseResult,\n  type CommentFontCommand,\n  type CommentHexColorCommand,\n  type CommentLayoutCommand,\n  type CommentSizeCommand,\n} from \"@/shared/types\";\n\nconst COMMENT_SIZE_SCALE: Record<CommentSizeCommand, number> = {\n  small: 0.8,\n  medium: 1,\n  big: 1.4,\n};\n\nconst FONT_FAMILY_MAP: Record<CommentFontCommand, string> = {\n  defont:\n    '\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Hiragino Kaku Gothic Pro\",\"Yu Gothic UI\",\"Yu Gothic\",\"Meiryo\",\"Segoe UI\",\"Osaka\",\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"IPAPGothic\",\"TakaoPGothic\",\"Roboto\",\"Helvetica Neue\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  gothic:\n    '\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"Yu Gothic\",\"Yu Gothic Medium\",\"Meiryo\",\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Segoe UI\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  mincho:\n    '\"MS PMincho\",\"MS Mincho\",\"Hiragino Mincho ProN\",\"Hiragino Mincho Pro\",\"Yu Mincho\",\"Noto Serif CJK JP\",\"Noto Serif JP\",\"Source Han Serif JP\",\"Times New Roman\",\"serif\"',\n};\n\nconst COLOR_COMMAND_MAP: Record<CommentColorCommand, string> = {\n  white: \"#FFFFFC\",\n  red: \"#FF8888\",\n  pink: \"#FFA5CC\",\n  orange: \"#FFBA66\",\n  yellow: \"#FFFFAA\",\n  green: \"#88FF88\",\n  cyan: \"#88FFFF\",\n  blue: \"#8899FF\",\n  purple: \"#D9A5FF\",\n  black: \"#444444\",\n  white2: \"#CC9\",\n  red2: \"#C03\",\n  pink2: \"#F3C\",\n  orange2: \"#F60\",\n  yellow2: \"#990\",\n  green2: \"#0C6\",\n  cyan2: \"#0CC\",\n  blue2: \"#39F\",\n  purple2: \"#63C\",\n  black2: \"#666\",\n};\n\nconst HEX_COLOR_REGEX = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;\n\nconst COMMAND_PREFIX_STRIP_REGEX = /^[,.:;]+/;\nconst COMMAND_SUFFIX_STRIP_REGEX = /[,.:;]+$/;\n\nconst normalizeCommandToken = (value: string): string => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return \"\";\n  }\n  if (HEX_COLOR_REGEX.test(trimmed)) {\n    return trimmed;\n  }\n  const withoutPrefix = trimmed.replace(COMMAND_PREFIX_STRIP_REGEX, \"\");\n  const withoutSuffix = withoutPrefix.replace(COMMAND_SUFFIX_STRIP_REGEX, \"\");\n  return withoutSuffix;\n};\n\nconst normalizeHexColor = (command: CommentHexColorCommand): string | null => {\n  if (!HEX_COLOR_REGEX.test(command)) {\n    return null;\n  }\n  return command.toUpperCase();\n};\n\nconst parseNumericCommandValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  const withoutPx = trimmed.toLowerCase().endsWith(\"px\") ? trimmed.slice(0, -2) : trimmed;\n  const parsed = Number.parseFloat(withoutPx);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst parseLineHeightValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  if (trimmed.endsWith(\"%\")) {\n    const numeric = Number.parseFloat(trimmed.slice(0, -1));\n    if (!Number.isFinite(numeric)) {\n      return null;\n    }\n    return numeric / 100;\n  }\n  return parseNumericCommandValue(trimmed);\n};\n\nconst clampLetterSpacing = (value: number): number => {\n  const maxSpacing = 100;\n  const minSpacing = -100;\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  return Math.min(maxSpacing, Math.max(minSpacing, value));\n};\n\nconst clampLineHeight = (value: number): number => {\n  const minHeight = 0.25;\n  const maxHeight = 5;\n  if (!Number.isFinite(value) || value === 0) {\n    return 1;\n  }\n  return Math.min(maxHeight, Math.max(minHeight, value));\n};\n\nconst isLayoutCommand = (command: string): command is CommentLayoutCommand =>\n  command === \"naka\" || command === \"ue\" || command === \"shita\";\n\nconst isSizeCommand = (command: string): command is CommentSizeCommand =>\n  command === \"small\" || command === \"medium\" || command === \"big\";\n\nconst isFontCommand = (command: string): command is CommentFontCommand =>\n  command === \"defont\" || command === \"gothic\" || command === \"mincho\";\n\nconst isColorCommand = (command: string): command is CommentColorCommand =>\n  command in COLOR_COMMAND_MAP;\n\nexport const parseCommentCommands = (\n  commands: readonly string[],\n  context: CommentCommandParseContext,\n): CommentCommandParseResult => {\n  let layout: CommentLayoutCommand = \"naka\";\n  let size: CommentSizeCommand = \"medium\";\n  let font: CommentFontCommand = \"defont\";\n  let colorOverride: string | null = null;\n  let opacityMultiplier = 1;\n  let opacityOverride: number | null = null;\n  let isInvisible = false;\n  let letterSpacing = 0;\n  let lineHeight = 1;\n\n  for (const rawCommand of commands) {\n    const normalizedToken = normalizeCommandToken(typeof rawCommand === \"string\" ? rawCommand : \"\");\n    if (!normalizedToken) {\n      continue;\n    }\n\n    if (HEX_COLOR_REGEX.test(normalizedToken)) {\n      const normalized = normalizeHexColor(normalizedToken as CommentHexColorCommand);\n      if (normalized) {\n        colorOverride = normalized;\n        continue;\n      }\n    }\n\n    const lower = normalizedToken.toLowerCase();\n\n    if (isLayoutCommand(lower)) {\n      layout = lower;\n      continue;\n    }\n\n    if (isSizeCommand(lower)) {\n      size = lower;\n      continue;\n    }\n\n    if (isFontCommand(lower)) {\n      font = lower;\n      continue;\n    }\n\n    if (isColorCommand(lower)) {\n      colorOverride = COLOR_COMMAND_MAP[lower].toUpperCase();\n      continue;\n    }\n\n    if (lower === \"_live\") {\n      opacityOverride = 0.5;\n      continue;\n    }\n\n    if (lower === \"invisible\") {\n      opacityMultiplier = 0;\n      isInvisible = true;\n      continue;\n    }\n\n    if (lower.startsWith(\"ls:\") || lower.startsWith(\"letterspacing:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseNumericCommandValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          letterSpacing = clampLetterSpacing(numericValue);\n        }\n      }\n      continue;\n    }\n\n    if (lower.startsWith(\"lh:\") || lower.startsWith(\"lineheight:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseLineHeightValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          lineHeight = clampLineHeight(numericValue);\n        }\n      }\n      continue;\n    }\n  }\n\n  const clampedOpacityMultiplier = Math.max(0, Math.min(1, opacityMultiplier));\n  const resolvedColor = (colorOverride ?? context.defaultColor).toUpperCase();\n  const resolvedOpacityOverride =\n    typeof opacityOverride === \"number\" ? Math.max(0, Math.min(1, opacityOverride)) : null;\n\n  return {\n    layout,\n    size,\n    sizeScale: COMMENT_SIZE_SCALE[size],\n    font,\n    fontFamily: FONT_FAMILY_MAP[font],\n    resolvedColor,\n    colorOverride,\n    opacityMultiplier: clampedOpacityMultiplier,\n    opacityOverride: resolvedOpacityOverride,\n    isInvisible,\n    letterSpacing,\n    lineHeight,\n  };\n};\n","const HEX_COLOR_PATTERN = /^#([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;\n\nconst expandHex = (fragment: string): string =>\n  fragment.length === 1 ? fragment.repeat(2) : fragment;\n\nconst parseHexComponent = (component: string): number => Number.parseInt(component, 16);\n\nexport const clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nexport const resolveFillStyleWithOpacity = (color: string, opacity: number): string => {\n  const match = HEX_COLOR_PATTERN.exec(color);\n  if (!match) {\n    return color;\n  }\n  const body = match[1];\n  let red: number;\n  let green: number;\n  let blue: number;\n  let alpha = 1;\n\n  if (body.length === 3 || body.length === 4) {\n    red = parseHexComponent(expandHex(body[0]));\n    green = parseHexComponent(expandHex(body[1]));\n    blue = parseHexComponent(expandHex(body[2]));\n    if (body.length === 4) {\n      alpha = parseHexComponent(expandHex(body[3])) / 255;\n    }\n  } else {\n    red = parseHexComponent(body.slice(0, 2));\n    green = parseHexComponent(body.slice(2, 4));\n    blue = parseHexComponent(body.slice(4, 6));\n    if (body.length === 8) {\n      alpha = parseHexComponent(body.slice(6, 8)) / 255;\n    }\n  }\n\n  const combinedAlpha = clampOpacity(alpha * clampOpacity(opacity));\n  return `rgba(${red}, ${green}, ${blue}, ${combinedAlpha})`;\n};\n","import type { TimeSource } from \"@/shared/types\";\n\nconst createPerformanceTimeSource = (): TimeSource => ({\n  now: () => {\n    if (typeof performance !== \"undefined\" && typeof performance.now === \"function\") {\n      return performance.now();\n    }\n    return Date.now();\n  },\n});\n\nexport const createDefaultTimeSource = (): TimeSource => createPerformanceTimeSource();\n","export const toMilliseconds = (seconds: number): number => seconds * 1000;\n\nexport const sanitizeVposMs = (value: number): number | null => {\n  if (!Number.isFinite(value)) {\n    return null;\n  }\n  if (value < 0) {\n    return null;\n  }\n  return Math.round(value);\n};\n\nexport const MAX_VISIBLE_DURATION_MS = 4_000;\nexport const MIN_VISIBLE_DURATION_MS = 1_800;\nexport const MAX_COMMENT_WIDTH_RATIO = 3;\nexport const COLLISION_BUFFER_RATIO = 0.25;\nexport const BASE_COLLISION_BUFFER_PX = 32;\nexport const ENTRY_BUFFER_PX = 48;\nexport const RESERVATION_TIME_MARGIN_MS = 120;\nexport const FINAL_PHASE_THRESHOLD_MS = 4_000;\nexport const FINAL_PHASE_MIN_GAP_MS = 120;\nexport const FINAL_PHASE_MAX_GAP_MS = 800;\nexport const FINAL_PHASE_ORDER_EPSILON_MS = 2;\nexport const FINAL_PHASE_MIN_WINDOW_MS = 4_000;\nexport const STATIC_VISIBLE_DURATION_MS = 4_000;\nexport const ACTIVE_WINDOW_MS = STATIC_VISIBLE_DURATION_MS + MAX_VISIBLE_DURATION_MS;\nexport const VIRTUAL_CANVAS_EXTENSION_PX = 1_000;\nexport const MIN_LANE_COUNT = 1;\nexport const DEFAULT_LANE_COUNT = 12;\nexport const MIN_FONT_SIZE_PX = 24;\nexport const EDGE_EPSILON = 1e-3;\nexport const SEEK_DIRECTION_EPSILON_MS = 50;\nexport const STATIC_COMMENT_VERTICAL_PADDING_RATIO = 0.05;\nexport const STATIC_COMMENT_MIN_VERTICAL_PADDING_PX = 10;\nexport const STATIC_COMMENT_EDGE_PADDING_PX = 5;\nexport const STATIC_COMMENT_STACKING_PADDING_PX = 2;\nexport const STATIC_COMMENT_SIDE_MARGIN_PX = 8;\nexport const MIN_STATIC_FONT_SIZE_PX = 12;\nexport const AUTO_HARD_RESET_DEDUP_WINDOW_MS = 500;\nexport const AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS = 3_000;\n","import type { LogLevel, Logger, LoggerOptions } from \"@/shared/types\";\n\nconst LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nconst fallbackEmitter = (level: LogLevel, namespace: string, args: unknown[]): void => {\n  const prefix = `[${namespace}]`;\n  const consoleArgs: unknown[] = [prefix, ...args];\n  switch (level) {\n    case \"debug\":\n      console.debug(...consoleArgs);\n      break;\n    case \"info\":\n      console.info(...consoleArgs);\n      break;\n    case \"warn\":\n      console.warn(...consoleArgs);\n      break;\n    case \"error\":\n      console.error(...consoleArgs);\n      break;\n    default:\n      console.log(...consoleArgs);\n  }\n};\n\nexport const createLogger = (namespace: string, options: LoggerOptions = {}): Logger => {\n  const { level = \"info\", emitter = fallbackEmitter } = options;\n  const threshold = LEVEL_PRIORITY[level];\n\n  const emit = (logLevel: LogLevel, args: unknown[]): void => {\n    if (LEVEL_PRIORITY[logLevel] < threshold) {\n      return;\n    }\n    emitter(logLevel, namespace, args);\n  };\n\n  return {\n    debug: (...messages: unknown[]) => emit(\"debug\", messages),\n    info: (...messages: unknown[]) => emit(\"info\", messages),\n    warn: (...messages: unknown[]) => emit(\"warn\", messages),\n    error: (...messages: unknown[]) => emit(\"error\", messages),\n  };\n};\n\nexport type { LogLevel, Logger, LoggerOptions } from \"@/shared/types\";\n","import { createLogger } from \"@/shared/logger\";\n\nexport const commentLogger = createLogger(\"CommentEngine:Comment\");\n","import type { TextMeasurementCache } from \"@/shared/types\";\n\nconst textMeasurementCaches = new WeakMap<CanvasRenderingContext2D, TextMeasurementCache>();\n\nconst getTextMeasurementCache = (ctx: CanvasRenderingContext2D): TextMeasurementCache => {\n  let cache = textMeasurementCaches.get(ctx);\n  if (!cache) {\n    cache = new Map();\n    textMeasurementCaches.set(ctx, cache);\n  }\n  return cache;\n};\n\nexport const measureTextWidth = (ctx: CanvasRenderingContext2D, text: string): number => {\n  if (!ctx) {\n    return 0;\n  }\n  const fontKey = ctx.font ?? \"\";\n  const cacheKey = `${fontKey}::${text}`;\n  const cache = getTextMeasurementCache(ctx);\n  const cached = cache.get(cacheKey);\n  if (cached !== undefined) {\n    return cached;\n  }\n  const width = ctx.measureText(text).width;\n  cache.set(cacheKey, width);\n  return width;\n};\n","import type { CommentPrepareOptions } from \"@/shared/types\";\nimport type { Comment } from \"@/comment/comment\";\nimport {\n  STATIC_VISIBLE_DURATION_MS,\n  STATIC_COMMENT_SIDE_MARGIN_PX,\n  MIN_STATIC_FONT_SIZE_PX,\n} from \"@/shared/constants\";\nimport { commentLogger as logger } from \"@/comment/logger\";\nimport { measureTextWidth } from \"@/comment/text-measure\";\n\nconst ensureLines = (text: string): string[] => {\n  if (text.includes(\"\\n\")) {\n    const rawLines = text.split(/\\r?\\n/);\n    return rawLines.length > 0 ? rawLines : [\"\"];\n  }\n  return [text];\n};\n\nconst clampFontSize = (value: number): number => Math.max(24, value);\n\nconst updateTextMetrics = (comment: Comment, ctx: CanvasRenderingContext2D): void => {\n  let maxLineWidth = 0;\n  const effectiveLetterSpacing = comment.letterSpacing;\n  for (const line of comment.lines) {\n    const baseWidth = measureTextWidth(ctx, line);\n    const extraSpacing = line.length > 1 ? effectiveLetterSpacing * (line.length - 1) : 0;\n    const totalWidth = Math.max(0, baseWidth + extraSpacing);\n    if (totalWidth > maxLineWidth) {\n      maxLineWidth = totalWidth;\n    }\n  }\n  comment.width = maxLineWidth;\n  const computedLineHeightPx = Math.max(\n    1,\n    Math.floor(comment.fontSize * comment.lineHeightMultiplier),\n  );\n  comment.lineHeightPx = computedLineHeightPx;\n  const additionalHeight =\n    comment.lines.length > 1 ? (comment.lines.length - 1) * computedLineHeightPx : 0;\n  comment.height = comment.fontSize + additionalHeight;\n};\n\nexport const prepareComment = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  visibleWidth: number,\n  canvasHeight: number,\n  options: CommentPrepareOptions,\n): void => {\n  try {\n    if (!ctx) {\n      throw new Error(\"Canvas context is required\");\n    }\n    if (!Number.isFinite(visibleWidth) || !Number.isFinite(canvasHeight)) {\n      throw new Error(\"Canvas dimensions must be numbers\");\n    }\n    if (!options) {\n      throw new Error(\"Prepare options are required\");\n    }\n\n    const safeVisibleWidth = Math.max(visibleWidth, 1);\n    const baseFontSize = clampFontSize(Math.floor(canvasHeight * 0.05));\n    const scaledFontSize = clampFontSize(Math.floor(baseFontSize * comment.sizeScale));\n    comment.fontSize = scaledFontSize;\n    ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n    comment.lines = ensureLines(comment.text);\n    updateTextMetrics(comment, ctx);\n\n    const isStaticTopOrBottom =\n      !comment.isScrolling && (comment.layout === \"ue\" || comment.layout === \"shita\");\n    if (isStaticTopOrBottom) {\n      const maxStaticWidth = Math.max(1, safeVisibleWidth - STATIC_COMMENT_SIDE_MARGIN_PX * 2);\n      if (comment.width > maxStaticWidth) {\n        const minimumFontSize = Math.max(\n          MIN_STATIC_FONT_SIZE_PX,\n          Math.min(comment.fontSize, Math.floor(baseFontSize * 0.6)),\n        );\n        const shrinkFactor = maxStaticWidth / Math.max(comment.width, 1);\n        const initialShrink = Math.max(\n          minimumFontSize,\n          Math.floor(comment.fontSize * Math.min(shrinkFactor, 1)),\n        );\n        if (initialShrink < comment.fontSize) {\n          comment.fontSize = initialShrink;\n          ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n          updateTextMetrics(comment, ctx);\n        }\n        let iteration = 0;\n        while (\n          comment.width > maxStaticWidth &&\n          comment.fontSize > minimumFontSize &&\n          iteration < 5\n        ) {\n          const currentShrink = maxStaticWidth / Math.max(comment.width, 1);\n          const proposedSize = Math.max(\n            minimumFontSize,\n            Math.floor(comment.fontSize * Math.max(currentShrink, 0.7)),\n          );\n          if (proposedSize >= comment.fontSize) {\n            comment.fontSize = Math.max(minimumFontSize, comment.fontSize - 1);\n          } else {\n            comment.fontSize = proposedSize;\n          }\n          ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n          updateTextMetrics(comment, ctx);\n          iteration += 1;\n        }\n      }\n    }\n\n    if (!comment.isScrolling) {\n      comment.bufferWidth = 0;\n      const margin = isStaticTopOrBottom ? STATIC_COMMENT_SIDE_MARGIN_PX : 0;\n      const centeredX = Math.max((safeVisibleWidth - comment.width) / 2, margin);\n      const maxStart = Math.max(margin, safeVisibleWidth - comment.width - margin);\n      const clampedX = Math.min(centeredX, Math.max(maxStart, margin));\n      comment.virtualStartX = clampedX;\n      comment.x = clampedX;\n      comment.baseSpeed = 0;\n      comment.speed = 0;\n      comment.speedPixelsPerMs = 0;\n      comment.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.preCollisionDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.totalDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.reservationWidth = comment.width;\n      comment.staticExpiryTimeMs = comment.vposMs + STATIC_VISIBLE_DURATION_MS;\n      comment.lastUpdateTime = comment.getTimeSource().now();\n      comment.isPaused = false;\n      return;\n    }\n\n    comment.staticExpiryTimeMs = null;\n    const maxReservationWidth = measureTextWidth(ctx, \"??\".repeat(150));\n\n    const bufferFromWidth = comment.width * Math.max(options.bufferRatio, 0);\n    comment.bufferWidth = Math.max(options.baseBufferPx, bufferFromWidth);\n    const entryBuffer = Math.max(options.entryBufferPx, comment.bufferWidth);\n\n    const direction = comment.scrollDirection;\n\n    const startLeft =\n      direction === \"rtl\"\n        ? safeVisibleWidth + options.virtualExtension\n        : -comment.width - comment.bufferWidth - options.virtualExtension;\n    const exitLeft =\n      direction === \"rtl\"\n        ? -comment.width - comment.bufferWidth - entryBuffer\n        : safeVisibleWidth + entryBuffer;\n    const trailingBoundary = direction === \"rtl\" ? safeVisibleWidth + entryBuffer : -entryBuffer;\n    const trailingEdgeAtStart =\n      direction === \"rtl\"\n        ? startLeft + comment.width + comment.bufferWidth\n        : startLeft - comment.bufferWidth;\n\n    comment.virtualStartX = startLeft;\n    comment.x = startLeft;\n    comment.exitThreshold = exitLeft;\n\n    const widthRatio = safeVisibleWidth > 0 ? comment.width / safeVisibleWidth : 0;\n    const hasFixedDuration = options.maxVisibleDurationMs === options.minVisibleDurationMs;\n    let visibleDurationMs = options.maxVisibleDurationMs;\n    if (!hasFixedDuration && widthRatio > 1) {\n      const clampedRatio = Math.min(widthRatio, options.maxWidthRatio);\n      const adjustedDuration = options.maxVisibleDurationMs / Math.max(clampedRatio, 1);\n      visibleDurationMs = Math.max(options.minVisibleDurationMs, Math.floor(adjustedDuration));\n    }\n\n    const visibleDistance = safeVisibleWidth + comment.width + comment.bufferWidth + entryBuffer;\n    const safeVisibleDuration = Math.max(visibleDurationMs, 1);\n    const pixelsPerMs = visibleDistance / safeVisibleDuration;\n    const pixelsPerFrame = (pixelsPerMs * 1000) / 60;\n    comment.baseSpeed = pixelsPerFrame;\n    comment.speed = comment.baseSpeed;\n    comment.speedPixelsPerMs = pixelsPerMs;\n\n    const travelDistance = Math.abs(exitLeft - startLeft);\n    const preCollisionDistance =\n      direction === \"rtl\"\n        ? Math.max(0, trailingEdgeAtStart - trailingBoundary)\n        : Math.max(0, trailingBoundary - trailingEdgeAtStart);\n    const safePixelsPerMs = Math.max(pixelsPerMs, Number.EPSILON);\n\n    comment.visibleDurationMs = visibleDurationMs;\n    comment.preCollisionDurationMs = Math.max(0, Math.ceil(preCollisionDistance / safePixelsPerMs));\n    comment.totalDurationMs = Math.max(\n      comment.preCollisionDurationMs,\n      Math.ceil(travelDistance / safePixelsPerMs),\n    );\n\n    const reservationBase = comment.width + comment.bufferWidth + entryBuffer;\n    comment.reservationWidth = Math.min(maxReservationWidth, reservationBase);\n    comment.lastUpdateTime = comment.getTimeSource().now();\n    comment.isPaused = false;\n  } catch (error) {\n    logger.error(\"Comment.prepare\", error as Error, {\n      text: comment.text,\n      visibleWidth,\n      canvasHeight,\n      hasContext: Boolean(ctx),\n    });\n    throw error;\n  }\n};\n\nexport { updateTextMetrics };\n","import type { DebugLoggingOptions, DebugState } from \"@/shared/types\";\nexport type { DebugLoggingOptions } from \"@/shared/types\";\n\nconst DEFAULT_MAX_LOGS_PER_CATEGORY = 5;\n\nconst state: DebugState = {\n  enabled: false,\n  maxLogsPerCategory: DEFAULT_MAX_LOGS_PER_CATEGORY,\n};\n\nconst categoryCounters = new Map<string, number>();\n\nconst normalizeLimit = (limit: number | undefined): number => {\n  if (limit === undefined) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  if (!Number.isFinite(limit)) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  const rounded = Math.max(1, Math.floor(limit));\n  return Math.min(10_000, rounded);\n};\n\nexport const configureDebugLogging = (options: DebugLoggingOptions): void => {\n  state.enabled = Boolean(options.enabled);\n  state.maxLogsPerCategory = normalizeLimit(options.maxLogsPerCategory);\n  if (!state.enabled) {\n    categoryCounters.clear();\n  }\n};\n\nexport const resetDebugCounters = (): void => {\n  categoryCounters.clear();\n};\n\nexport const isDebugLoggingEnabled = (): boolean => state.enabled;\n\nconst shouldEmitLog = (category: string): boolean => {\n  const currentCount = categoryCounters.get(category) ?? 0;\n  if (currentCount >= state.maxLogsPerCategory) {\n    if (currentCount === state.maxLogsPerCategory) {\n      console.debug(`[CommentOverlay][${category}]`, \"Further logs suppressed.\");\n      categoryCounters.set(category, currentCount + 1);\n    }\n    return false;\n  }\n  categoryCounters.set(category, currentCount + 1);\n  return true;\n};\n\nexport const debugLog = (category: string, ...payload: unknown[]): void => {\n  if (!state.enabled) {\n    return;\n  }\n  if (!shouldEmitLog(category)) {\n    return;\n  }\n  console.debug(`[CommentOverlay][${category}]`, ...payload);\n};\n\nexport const formatCommentPreview = (text: string, maxLength = 32): string => {\n  if (text.length <= maxLength) {\n    return text;\n  }\n  return `${text.slice(0, maxLength)}…`;\n};\n\n// 内部状態ダンプ\nexport const dumpRendererState = (\n  label: string,\n  snapshot: {\n    currentTime: number;\n    duration: number;\n    isPlaying: boolean;\n    epochId: number;\n    totalComments: number;\n    activeComments: number;\n    reservedLanes: number;\n    finalPhaseActive: boolean;\n    playbackHasBegun: boolean;\n    isStalled: boolean;\n  },\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  console.group(`[CommentOverlay][state-dump] ${label}`);\n  console.table({\n    \"Current Time\": `${snapshot.currentTime.toFixed(2)}ms`,\n    Duration: `${snapshot.duration.toFixed(2)}ms`,\n    \"Is Playing\": snapshot.isPlaying,\n    \"Epoch ID\": snapshot.epochId,\n    \"Total Comments\": snapshot.totalComments,\n    \"Active Comments\": snapshot.activeComments,\n    \"Reserved Lanes\": snapshot.reservedLanes,\n    \"Final Phase\": snapshot.finalPhaseActive,\n    \"Playback Begun\": snapshot.playbackHasBegun,\n    \"Is Stalled\": snapshot.isStalled,\n  });\n  console.groupEnd();\n};\n\n// エポック変更のログ\nexport const logEpochChange = (\n  previousEpochId: number,\n  newEpochId: number,\n  reason: string,\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  debugLog(\"epoch-change\", `Epoch changed: ${previousEpochId} → ${newEpochId} (reason: ${reason})`);\n};\n","import type { Comment } from \"@/comment/comment\";\nimport type { DrawMode } from \"@/shared/types\";\nimport { clampOpacity, resolveFillStyleWithOpacity } from \"@/comment/color\";\nimport { commentLogger as logger } from \"@/comment/logger\";\nimport { isDebugLoggingEnabled } from \"@/shared/debug\";\nimport { measureTextWidth } from \"@/comment/text-measure\";\n\nconst cacheStats = {\n  hits: 0,\n  misses: 0,\n  creates: 0,\n  fallbacks: 0,\n  outlineCallsInCache: 0,\n  fillCallsInCache: 0,\n  outlineCallsInFallback: 0,\n  fillCallsInFallback: 0,\n  letterSpacingComments: 0,\n  normalComments: 0,\n  multiLineComments: 0,\n  totalCharactersDrawn: 0,\n  lastReported: 0,\n};\n\nconst reportCacheStats = (): void => {\n  if (!isDebugLoggingEnabled()) {\n    return;\n  }\n  const now = performance.now();\n  if (now - cacheStats.lastReported <= 5000) {\n    return;\n  }\n  const total = cacheStats.hits + cacheStats.misses;\n  const hitRate = total > 0 ? (cacheStats.hits / total) * 100 : 0;\n  const avgCharsPerComment =\n    cacheStats.creates > 0\n      ? (cacheStats.totalCharactersDrawn / cacheStats.creates).toFixed(1)\n      : \"0\";\n  const totalOutlineCalls = cacheStats.outlineCallsInCache + cacheStats.outlineCallsInFallback;\n  const totalFillCalls = cacheStats.fillCallsInCache + cacheStats.fillCallsInFallback;\n  console.log(\n    `[TextureCache Stats]`,\n    `\\n  Cache: Hits=${cacheStats.hits}, Misses=${cacheStats.misses}, Hit Rate=${hitRate.toFixed(1)}%`,\n    `\\n  Creates: ${cacheStats.creates}, Fallbacks: ${cacheStats.fallbacks}`,\n    `\\n  Comments: Normal=${cacheStats.normalComments}, LetterSpacing=${cacheStats.letterSpacingComments}, MultiLine=${cacheStats.multiLineComments}`,\n    `\\n  Draw Calls: Outline=${totalOutlineCalls}, Fill=${totalFillCalls}`,\n    `\\n  Avg Characters/Comment: ${avgCharsPerComment}`,\n  );\n  cacheStats.lastReported = now;\n};\n\nconst isOffscreenCanvasSupported = (): boolean => typeof OffscreenCanvas !== \"undefined\";\n\ntype ShadowParams = {\n  blur: number;\n  alpha: number;\n};\n\nconst getShadowParams = (\n  intensity: import(\"@/shared/types\").ShadowIntensity,\n  fontSize: number,\n  baseOpacity: number,\n): ShadowParams => {\n  if (intensity === \"none\") {\n    return { blur: 0, alpha: 0 };\n  }\n\n  const blurRatio = {\n    light: 0.06,\n    medium: 0.1,\n    strong: 0.15,\n  }[intensity];\n\n  const alphaMultiplier = {\n    light: 0.6,\n    medium: 0.8,\n    strong: 0.95,\n  }[intensity];\n\n  const blur = Math.max(2, fontSize * blurRatio);\n  const alpha = clampOpacity(baseOpacity * alphaMultiplier);\n\n  return { blur, alpha };\n};\n\nconst createSegmentDrawer = (\n  comment: Comment,\n  targetCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  measurementCtx: CanvasRenderingContext2D,\n  statsTarget: \"cache\" | \"fallback\",\n  baseDrawX: number,\n): ((line: string, baselineY: number, mode: DrawMode, offsetX?: number) => void) => {\n  return (line, baselineY, mode, offsetX = 0) => {\n    if (line.length === 0) {\n      return;\n    }\n\n    const effectiveDrawX = baseDrawX + offsetX;\n\n    const recordDraw = (): void => {\n      if (statsTarget === \"cache\") {\n        if (mode === \"outline\") {\n          cacheStats.outlineCallsInCache++;\n        } else {\n          cacheStats.fillCallsInCache++;\n        }\n      } else if (mode === \"outline\") {\n        cacheStats.outlineCallsInFallback++;\n      } else {\n        cacheStats.fillCallsInFallback++;\n      }\n    };\n\n    if (Math.abs(comment.letterSpacing) < Number.EPSILON) {\n      recordDraw();\n      targetCtx.fillText(line, effectiveDrawX, baselineY);\n      return;\n    }\n\n    let cursorX = effectiveDrawX;\n    for (let index = 0; index < line.length; index += 1) {\n      const char = line[index];\n      recordDraw();\n      targetCtx.fillText(char, cursorX, baselineY);\n      const advance = measureTextWidth(measurementCtx, char);\n      cursorX += advance;\n      if (index < line.length - 1) {\n        cursorX += comment.letterSpacing;\n      }\n    }\n  };\n};\n\nconst generateTextureCacheKey = (comment: Comment): string => {\n  return `v2::${comment.text}::${comment.fontSize}::${comment.fontFamily}::${comment.color}::${comment.opacity}::${comment.renderStyle}::${comment.letterSpacing}::${comment.lines.length}`;\n};\n\nconst createTextureCanvas = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n): OffscreenCanvas | null => {\n  if (!isOffscreenCanvasSupported()) {\n    return null;\n  }\n\n  const hasLetterSpacing = Math.abs(comment.letterSpacing) >= Number.EPSILON;\n  const isMultiLine = comment.lines.length > 1;\n  if (hasLetterSpacing) {\n    cacheStats.letterSpacingComments++;\n  }\n  if (isMultiLine) {\n    cacheStats.multiLineComments++;\n  }\n  if (!hasLetterSpacing && !isMultiLine) {\n    cacheStats.normalComments++;\n  }\n  cacheStats.totalCharactersDrawn += comment.text.length;\n\n  const padding = Math.max(10, comment.fontSize * 0.5);\n  const textureWidth = Math.ceil(comment.width + padding * 2);\n  const textureHeight = Math.ceil(comment.height + padding * 2);\n\n  const offscreen = new OffscreenCanvas(textureWidth, textureHeight);\n  const offscreenCtx = offscreen.getContext(\"2d\");\n  if (!offscreenCtx) {\n    return null;\n  }\n\n  offscreenCtx.save();\n  offscreenCtx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n  const effectiveOpacity = clampOpacity(comment.opacity);\n  const drawX = padding;\n  const linesToRender = comment.lines.length > 0 ? comment.lines : [comment.text];\n  const lineAdvance =\n    comment.lines.length > 1 && comment.lineHeightPx > 0 ? comment.lineHeightPx : comment.fontSize;\n  const baselineStart = padding + comment.fontSize;\n  const drawSegment = createSegmentDrawer(comment, offscreenCtx, ctx, \"cache\", drawX);\n\n  const resolvedFillStyle = resolveFillStyleWithOpacity(comment.color, effectiveOpacity);\n\n  const shadowParams = getShadowParams(comment.shadowIntensity, comment.fontSize, effectiveOpacity);\n\n  if (isDebugLoggingEnabled()) {\n    console.log(\n      `[Shadow Debug - Cache]`,\n      `\\n  Text: \"${comment.text}\"`,\n      `\\n  FontSize: ${comment.fontSize}`,\n      `\\n  Shadow intensity: ${comment.shadowIntensity}`,\n      `\\n  Shadow blur: ${shadowParams.blur}px`,\n      `\\n  Shadow alpha: ${shadowParams.alpha}`,\n      `\\n  Fill style: ${resolvedFillStyle}`,\n    );\n  }\n\n  offscreenCtx.save();\n  offscreenCtx.shadowColor = `rgba(0, 0, 0, ${shadowParams.alpha})`;\n  offscreenCtx.shadowBlur = shadowParams.blur;\n  offscreenCtx.shadowOffsetX = 0;\n  offscreenCtx.shadowOffsetY = 0;\n  offscreenCtx.fillStyle = resolvedFillStyle;\n\n  linesToRender.forEach((line: string, index: number) => {\n    const baseline = baselineStart + index * lineAdvance;\n    drawSegment(line, baseline, \"fill\");\n  });\n\n  offscreenCtx.restore();\n\n  offscreenCtx.restore();\n  return offscreen;\n};\n\nconst drawWithFallback = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  interpolatedX: number | null,\n): void => {\n  cacheStats.fallbacks++;\n  ctx.save();\n  ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n  const effectiveOpacity = clampOpacity(comment.opacity);\n  const drawX = interpolatedX ?? comment.x;\n  const linesToRender = comment.lines.length > 0 ? comment.lines : [comment.text];\n  const lineAdvance =\n    comment.lines.length > 1 && comment.lineHeightPx > 0 ? comment.lineHeightPx : comment.fontSize;\n  const baselineStart = comment.y + comment.fontSize;\n  const drawSegment = createSegmentDrawer(comment, ctx, ctx, \"fallback\", drawX);\n\n  const resolvedFillStyle = resolveFillStyleWithOpacity(comment.color, effectiveOpacity);\n\n  const shadowParams = getShadowParams(comment.shadowIntensity, comment.fontSize, effectiveOpacity);\n\n  if (isDebugLoggingEnabled()) {\n    console.log(\n      `[Shadow Debug - Fallback]`,\n      `\\n  Text: \"${comment.text}\"`,\n      `\\n  FontSize: ${comment.fontSize}`,\n      `\\n  Shadow intensity: ${comment.shadowIntensity}`,\n      `\\n  Shadow blur: ${shadowParams.blur}px`,\n      `\\n  Shadow alpha: ${shadowParams.alpha}`,\n      `\\n  Fill style: ${resolvedFillStyle}`,\n    );\n  }\n\n  ctx.save();\n  ctx.shadowColor = `rgba(0, 0, 0, ${shadowParams.alpha})`;\n  ctx.shadowBlur = shadowParams.blur;\n  ctx.shadowOffsetX = 0;\n  ctx.shadowOffsetY = 0;\n  ctx.fillStyle = resolvedFillStyle;\n\n  linesToRender.forEach((line: string, index: number) => {\n    const baseline = baselineStart + index * lineAdvance;\n    drawSegment(line, baseline, \"fill\");\n  });\n\n  ctx.restore();\n\n  ctx.restore();\n};\n\nexport const drawComment = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  interpolatedX: number | null,\n): void => {\n  try {\n    if (!comment.isActive || !ctx) {\n      return;\n    }\n    const currentCacheKey = generateTextureCacheKey(comment);\n    const cachedTexture = comment.getCachedTexture();\n    if (comment.getTextureCacheKey() !== currentCacheKey || !cachedTexture) {\n      cacheStats.misses++;\n      cacheStats.creates++;\n      const created = createTextureCanvas(comment, ctx);\n      comment.setCachedTexture(created);\n      comment.setTextureCacheKey(currentCacheKey);\n    } else {\n      cacheStats.hits++;\n    }\n\n    const texture = comment.getCachedTexture();\n    if (texture) {\n      const drawX = interpolatedX ?? comment.x;\n      const padding = Math.max(10, comment.fontSize * 0.5);\n      ctx.drawImage(texture, drawX - padding, comment.y - padding);\n      reportCacheStats();\n      return;\n    }\n\n    drawWithFallback(comment, ctx, interpolatedX);\n    reportCacheStats();\n  } catch (error) {\n    logger.error(\"Comment.draw\", error as Error, {\n      text: comment.text,\n      isActive: comment.isActive,\n      hasContext: Boolean(ctx),\n      interpolatedX,\n    });\n  }\n};\n","import type { ScrollDirection } from \"@/shared/types\";\n\nexport const resolveScrollDirection = (input: ScrollDirection | string): ScrollDirection =>\n  input === \"ltr\" ? \"ltr\" : \"rtl\";\n\nexport const getDirectionSign = (direction: ScrollDirection): -1 | 1 =>\n  direction === \"ltr\" ? 1 : -1;\n","import type {\n  CommentLayoutCommand,\n  RenderStyle,\n  RendererSettings,\n  ScrollDirection,\n  CommentDependencies,\n  CommentPrepareOptions,\n  TimeSource,\n} from \"@/shared/types\";\nimport { parseCommentCommands } from \"@/comment/comment-commands\";\nimport { clampOpacity } from \"@/comment/color\";\nimport { createDefaultTimeSource } from \"@/comment/time-source\";\nimport { prepareComment } from \"@/comment/prepare\";\nimport { drawComment } from \"@/comment/render\";\nimport { resolveScrollDirection, getDirectionSign } from \"@/comment/direction\";\nimport { commentLogger as logger } from \"@/comment/logger\";\n\nexport class Comment {\n  readonly text: string;\n  readonly vposMs: number;\n  readonly commands: string[];\n  readonly layout: CommentLayoutCommand;\n  readonly isScrolling: boolean;\n  readonly sizeScale: number;\n  readonly opacityMultiplier: number;\n  readonly opacityOverride: number | null;\n  readonly colorOverride: string | null;\n  readonly isInvisible: boolean;\n\n  x = 0;\n  y = 0;\n  width = 0;\n  height = 0;\n  baseSpeed = 0;\n  speed = 0;\n  lane = -1;\n  color: string;\n  fontSize = 0;\n  fontFamily: string;\n  opacity: number;\n  activationTimeMs: number | null = null;\n  staticExpiryTimeMs: number | null = null;\n  isActive = false;\n  hasShown = false;\n  isPaused = false;\n  lastUpdateTime = 0;\n  reservationWidth = 0;\n  bufferWidth = 0;\n  visibleDurationMs = 0;\n  totalDurationMs = 0;\n  preCollisionDurationMs = 0;\n  speedPixelsPerMs = 0;\n  virtualStartX = 0;\n  exitThreshold = 0;\n  scrollDirection: ScrollDirection = \"rtl\";\n  renderStyle: RenderStyle = \"outline-only\";\n  shadowIntensity: import(\"@/shared/types\").ShadowIntensity = \"medium\";\n  creationIndex = 0;\n  letterSpacing = 0;\n  lineHeightMultiplier = 1;\n  lineHeightPx = 0;\n  lines: string[] = [];\n  epochId = 0;\n  private directionSign: -1 | 1 = -1;\n  private readonly timeSource: TimeSource;\n  private lastSyncedSettingsVersion = -1;\n  private cachedTexture: OffscreenCanvas | null = null;\n  private textureCacheKey = \"\";\n\n  constructor(\n    text: string,\n    vposMs: number,\n    commands: string[] | undefined,\n    settings: RendererSettings,\n    dependencies: CommentDependencies = {},\n  ) {\n    if (typeof text !== \"string\") {\n      throw new Error(\"Comment text must be a string\");\n    }\n    if (!Number.isFinite(vposMs) || vposMs < 0) {\n      throw new Error(\"Comment vposMs must be a non-negative number\");\n    }\n\n    this.text = text;\n    this.vposMs = vposMs;\n    this.commands = Array.isArray(commands) ? [...commands] : [];\n\n    const parsedCommands = parseCommentCommands(this.commands, {\n      defaultColor: settings.commentColor,\n    });\n\n    this.layout = parsedCommands.layout;\n    this.isScrolling = this.layout === \"naka\";\n    this.sizeScale = parsedCommands.sizeScale;\n    this.opacityMultiplier = parsedCommands.opacityMultiplier;\n    this.opacityOverride = parsedCommands.opacityOverride;\n    this.colorOverride = parsedCommands.colorOverride;\n    this.isInvisible = parsedCommands.isInvisible;\n    this.fontFamily = parsedCommands.fontFamily;\n    this.color = parsedCommands.resolvedColor;\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.renderStyle = settings.renderStyle;\n    this.shadowIntensity = settings.shadowIntensity;\n    this.letterSpacing = parsedCommands.letterSpacing;\n    this.lineHeightMultiplier = parsedCommands.lineHeight;\n\n    this.timeSource = dependencies.timeSource ?? createDefaultTimeSource();\n    this.applyScrollDirection(settings.scrollDirection);\n    this.syncWithSettings(settings, dependencies.settingsVersion);\n  }\n\n  prepare(\n    ctx: CanvasRenderingContext2D,\n    visibleWidth: number,\n    canvasHeight: number,\n    options: CommentPrepareOptions,\n  ): void {\n    prepareComment(this, ctx, visibleWidth, canvasHeight, options);\n  }\n\n  draw(ctx: CanvasRenderingContext2D, interpolatedX: number | null = null): void {\n    drawComment(this, ctx, interpolatedX);\n  }\n\n  update(playbackRate = 1.0, isPaused = false): void {\n    try {\n      if (!this.isActive) {\n        this.isPaused = isPaused;\n        return;\n      }\n\n      const currentTime = this.timeSource.now();\n\n      if (!this.isScrolling) {\n        this.isPaused = isPaused;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      if (isPaused) {\n        this.isPaused = true;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      const deltaTime = (currentTime - this.lastUpdateTime) / (1000 / 60);\n      this.speed = this.baseSpeed * playbackRate;\n      this.x += this.speed * deltaTime * this.directionSign;\n      const hasExited =\n        (this.scrollDirection === \"rtl\" && this.x <= this.exitThreshold) ||\n        (this.scrollDirection === \"ltr\" && this.x >= this.exitThreshold);\n      if (hasExited) {\n        this.isActive = false;\n      }\n      this.lastUpdateTime = currentTime;\n      this.isPaused = false;\n    } catch (error) {\n      logger.error(\"Comment.update\", error as Error, {\n        text: this.text,\n        playbackRate,\n        isPaused,\n        isActive: this.isActive,\n      });\n    }\n  }\n\n  syncWithSettings(settings: RendererSettings, settingsVersion?: number): void {\n    const hasSyncedVersion =\n      typeof settingsVersion === \"number\" && settingsVersion === this.lastSyncedSettingsVersion;\n    if (hasSyncedVersion) {\n      return;\n    }\n    this.color = this.getEffectiveColor(settings.commentColor);\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.applyScrollDirection(settings.scrollDirection);\n    this.renderStyle = settings.renderStyle;\n    this.shadowIntensity = settings.shadowIntensity;\n    if (typeof settingsVersion === \"number\") {\n      this.lastSyncedSettingsVersion = settingsVersion;\n    }\n  }\n\n  getEffectiveColor(defaultColor: string): string {\n    const candidate = this.colorOverride ?? defaultColor;\n    if (typeof candidate !== \"string\" || candidate.length === 0) {\n      return defaultColor;\n    }\n    return candidate.toUpperCase();\n  }\n\n  getEffectiveOpacity(defaultOpacity: number): number {\n    if (typeof this.opacityOverride === \"number\") {\n      return clampOpacity(this.opacityOverride);\n    }\n    const scaled = defaultOpacity * this.opacityMultiplier;\n    if (!Number.isFinite(scaled)) {\n      return 0;\n    }\n    return clampOpacity(scaled);\n  }\n\n  markActivated(atTimeMs: number): void {\n    this.activationTimeMs = atTimeMs;\n  }\n\n  clearActivation(): void {\n    this.activationTimeMs = null;\n    if (!this.isScrolling) {\n      this.staticExpiryTimeMs = null;\n    }\n    this.resetTextureCache();\n  }\n\n  hasStaticExpired(currentTimeMs: number): boolean {\n    if (this.isScrolling) {\n      return false;\n    }\n    if (this.staticExpiryTimeMs === null) {\n      return false;\n    }\n    return currentTimeMs >= this.staticExpiryTimeMs;\n  }\n\n  getDirectionSign(): -1 | 1 {\n    return this.directionSign;\n  }\n\n  getTimeSource(): TimeSource {\n    return this.timeSource;\n  }\n\n  getTextureCacheKey(): string {\n    return this.textureCacheKey;\n  }\n\n  setTextureCacheKey(value: string): void {\n    this.textureCacheKey = value;\n  }\n\n  getCachedTexture(): OffscreenCanvas | null {\n    return this.cachedTexture;\n  }\n\n  setCachedTexture(texture: OffscreenCanvas | null): void {\n    this.cachedTexture = texture;\n  }\n\n  resetTextureCache(): void {\n    this.cachedTexture = null;\n    this.textureCacheKey = \"\";\n  }\n\n  private applyScrollDirection(direction: ScrollDirection | string): void {\n    const resolved = resolveScrollDirection(direction);\n    this.scrollDirection = resolved;\n    this.directionSign = getDirectionSign(resolved);\n  }\n}\n","import type { RendererSettings, ReadonlyRendererSettings } from \"@/shared/types\";\n\nexport const NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS = 4_000;\n\nconst BASE_SETTINGS: RendererSettings = {\n  commentColor: \"#FFFFFF\",\n  commentOpacity: 1,\n  isCommentVisible: true,\n  useContainerResizeObserver: true,\n  ngWords: [],\n  ngRegexps: [],\n  scrollDirection: \"rtl\",\n  renderStyle: \"outline-only\",\n  syncMode: \"raf\",\n  scrollVisibleDurationMs: NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS,\n  useFixedLaneCount: false,\n  fixedLaneCount: 12,\n  useDprScaling: true,\n  enableAutoHardReset: true,\n  shadowIntensity: \"medium\",\n};\n\nexport const DEFAULT_RENDERER_SETTINGS: ReadonlyRendererSettings = BASE_SETTINGS;\n\nexport const cloneDefaultSettings = (): RendererSettings => ({\n  ...BASE_SETTINGS,\n  ngWords: [...BASE_SETTINGS.ngWords],\n  ngRegexps: [...BASE_SETTINGS.ngRegexps],\n});\n\nexport const COMMENT_OVERLAY_VERSION = \"v2.8.0\";\n","import type { RendererSettings, AnimationFrameProvider, TimeSource } from \"@/shared/types\";\nimport {\n  STATIC_COMMENT_EDGE_PADDING_PX,\n  STATIC_COMMENT_STACKING_PADDING_PX,\n} from \"@/shared/constants\";\n\nexport const clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 1;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nexport const calculateStaticCommentVerticalPadding = (\n  _fontSize: number,\n  laneIndex: number = 0,\n): number => {\n  if (laneIndex === 0) {\n    return STATIC_COMMENT_EDGE_PADDING_PX;\n  }\n  return STATIC_COMMENT_STACKING_PADDING_PX;\n};\n\nexport const normalizeSettings = (settings: RendererSettings): RendererSettings => {\n  const rawDuration = settings.scrollVisibleDurationMs;\n  const normalizedDuration =\n    rawDuration === null || rawDuration === undefined\n      ? null\n      : Number.isFinite(rawDuration)\n        ? Math.max(1, Math.floor(rawDuration))\n        : null;\n\n  return {\n    ...settings,\n    scrollDirection: settings.scrollDirection === \"ltr\" ? \"ltr\" : \"rtl\",\n    commentOpacity: clampOpacity(settings.commentOpacity),\n    renderStyle: settings.renderStyle === \"classic\" ? \"classic\" : \"outline-only\",\n    scrollVisibleDurationMs: normalizedDuration,\n    syncMode: settings.syncMode === \"video-frame\" ? \"video-frame\" : \"raf\",\n    useDprScaling: Boolean(settings.useDprScaling),\n    enableAutoHardReset: settings.enableAutoHardReset !== false,\n  };\n};\n\nexport const createDefaultAnimationFrameProvider = (\n  timeSource: TimeSource,\n): AnimationFrameProvider => {\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.requestAnimationFrame === \"function\" &&\n    typeof window.cancelAnimationFrame === \"function\"\n  ) {\n    return {\n      request: (callback) => window.requestAnimationFrame(callback),\n      cancel: (handle) => window.cancelAnimationFrame(handle),\n    };\n  }\n  return {\n    request: (callback) => {\n      const timeoutId = globalThis.setTimeout(() => {\n        callback(timeSource.now());\n      }, 16);\n      return timeoutId;\n    },\n    cancel: (handle) => {\n      globalThis.clearTimeout(handle);\n    },\n  };\n};\n\nexport const createBrowserCanvasFactory = (): (() => HTMLCanvasElement) => {\n  if (typeof document === \"undefined\") {\n    return () => {\n      throw new Error(\n        \"Document is not available. Provide a custom createCanvasElement implementation.\",\n      );\n    };\n  }\n  return () => document.createElement(\"canvas\");\n};\n\nexport const isRendererSettings = (input: unknown): input is RendererSettings => {\n  if (!input || typeof input !== \"object\") {\n    return false;\n  }\n  const candidate = input as Record<string, unknown>;\n  return (\n    typeof candidate.commentColor === \"string\" &&\n    typeof candidate.commentOpacity === \"number\" &&\n    typeof candidate.isCommentVisible === \"boolean\"\n  );\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { Comment } from \"@/comment/comment\";\nimport { formatCommentPreview, debugLog } from \"@/shared/debug\";\nimport { EDGE_EPSILON, sanitizeVposMs } from \"@/shared/constants\";\n\nconst addCommentsImpl = function (\n  this: CommentRenderer,\n  entries: ReadonlyArray<{ text: string; vposMs: number; commands?: string[] }>,\n): Comment[] {\n  if (!Array.isArray(entries) || entries.length === 0) {\n    return [];\n  }\n\n  const addedComments: Comment[] = [];\n  this.commentDependencies.settingsVersion = this.settingsVersion;\n\n  for (const entry of entries) {\n    const { text, vposMs, commands = [] } = entry;\n    const preview = formatCommentPreview(text);\n\n    if (this.isNGComment(text)) {\n      debugLog(\"comment-skip-ng\", { preview, vposMs });\n      continue;\n    }\n\n    const normalizedVposMs = sanitizeVposMs(vposMs);\n    if (normalizedVposMs === null) {\n      this.log.warn(\"CommentRenderer.addComment.invalidVpos\", { text, vposMs });\n      debugLog(\"comment-skip-invalid-vpos\", { preview, vposMs });\n      continue;\n    }\n\n    const duplicate =\n      this.comments.some(\n        (comment) => comment.text === text && comment.vposMs === normalizedVposMs,\n      ) ||\n      addedComments.some((comment) => comment.text === text && comment.vposMs === normalizedVposMs);\n    if (duplicate) {\n      debugLog(\"comment-skip-duplicate\", { preview, vposMs: normalizedVposMs });\n      continue;\n    }\n\n    const comment = new Comment(\n      text,\n      normalizedVposMs,\n      commands,\n      this._settings,\n      this.commentDependencies,\n    );\n    comment.creationIndex = this.commentSequence++;\n    comment.epochId = this.epochId;\n    addedComments.push(comment);\n    debugLog(\"comment-added\", {\n      preview,\n      vposMs: normalizedVposMs,\n      commands: comment.commands.length,\n      layout: comment.layout,\n      isScrolling: comment.isScrolling,\n      invisible: comment.isInvisible,\n    });\n  }\n\n  if (addedComments.length === 0) {\n    return [];\n  }\n\n  this.comments.push(...addedComments);\n  if (this.finalPhaseActive) {\n    this.finalPhaseScheduleDirty = true;\n  }\n  this.comments.sort((a, b) => {\n    const vposMsDiff = a.vposMs - b.vposMs;\n    if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n      return vposMsDiff;\n    }\n    return a.creationIndex - b.creationIndex;\n  });\n\n  return addedComments;\n};\n\nconst addCommentImpl = function (\n  this: CommentRenderer,\n  text: string,\n  vposMs: number,\n  commands: string[] = [],\n): Comment | null {\n  const [comment] = this.addComments([{ text, vposMs, commands }]);\n  return comment ?? null;\n};\n\nconst clearCommentsImpl = function (this: CommentRenderer): void {\n  this.comments.length = 0;\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  this.commentSequence = 0;\n  if (this.ctx && this.canvas) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const width = this.displayWidth > 0 ? this.displayWidth : this.canvas.width / effectiveDpr;\n    const height = this.displayHeight > 0 ? this.displayHeight : this.canvas.height / effectiveDpr;\n    this.ctx.clearRect(0, 0, width, height);\n  }\n};\n\nconst resetStateImpl = function (this: CommentRenderer): void {\n  this.clearComments();\n  this.currentTime = 0;\n  this.resetFinalPhaseState();\n  this.playbackHasBegun = false;\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n};\n\nexport const rebuildNgMatchersImpl = function (this: CommentRenderer): void {\n  const settings = this._settings;\n  const ngWords = Array.isArray(settings.ngWords) ? settings.ngWords : [];\n  this.normalizedNgWords = ngWords.filter((word): word is string => typeof word === \"string\");\n  const sourcePatterns = Array.isArray(settings.ngRegexps) ? settings.ngRegexps : [];\n  this.compiledNgRegexps = sourcePatterns\n    .map((entry): RegExp | null => {\n      if (typeof entry !== \"string\") {\n        return null;\n      }\n      try {\n        return new RegExp(entry, \"i\");\n      } catch (error) {\n        this.log.warn(\"CommentRenderer.invalidNgRegexp\", error as Error, { entry });\n        return null;\n      }\n    })\n    .filter((entry): entry is RegExp => Boolean(entry));\n};\n\nconst isNgCommentImpl = function (this: CommentRenderer, text: string): boolean {\n  if (typeof text !== \"string\" || text.length === 0) {\n    return false;\n  }\n  if (this.normalizedNgWords.some((word) => word.length > 0 && text.includes(word))) {\n    return true;\n  }\n  return this.compiledNgRegexps.some((regexp) => regexp.test(text));\n};\n\nexport const registerCommentCollectionMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.addComments = addCommentsImpl;\n  ctor.prototype.addComment = addCommentImpl;\n  ctor.prototype.clearComments = clearCommentsImpl;\n  ctor.prototype.resetState = resetStateImpl;\n  ctor.prototype.rebuildNgMatchers = rebuildNgMatchersImpl;\n  ctor.prototype.isNGComment = isNgCommentImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  EDGE_EPSILON,\n  FINAL_PHASE_MIN_GAP_MS,\n  FINAL_PHASE_MAX_GAP_MS,\n  FINAL_PHASE_ORDER_EPSILON_MS,\n  FINAL_PHASE_MIN_WINDOW_MS,\n  MAX_VISIBLE_DURATION_MS,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"@/shared/constants\";\nimport { dumpRendererState, logEpochChange } from \"@/shared/debug\";\nimport type { EpochChangeInfo, RendererStateSnapshot } from \"@/shared/types\";\n\nconst hardResetImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  const now = this.timeSource.now();\n  this.lastHardResetAt = now;\n\n  this.incrementEpoch(\"manual-reset\");\n\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n\n  this.comments.forEach((comment) => {\n    comment.isActive = false;\n    comment.hasShown = false;\n    comment.lane = -1;\n    comment.clearActivation();\n    comment.epochId = this.epochId;\n  });\n\n  if (canvas && ctx) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n  }\n\n  this.pendingInitialSync = true;\n  this.resetFinalPhaseState();\n  this.emitStateSnapshot(\"hardReset\");\n};\n\nconst resetFinalPhaseStateImpl = function (this: CommentRenderer): void {\n  this.finalPhaseActive = false;\n  this.finalPhaseStartTime = null;\n  this.finalPhaseScheduleDirty = false;\n  this.finalPhaseVposOverrides.clear();\n};\n\nconst incrementEpochImpl = function (\n  this: CommentRenderer,\n  reason: \"source-change\" | \"metadata-loaded\" | \"manual-reset\",\n): void {\n  const previousEpochId = this.epochId;\n  this.epochId += 1;\n\n  logEpochChange(previousEpochId, this.epochId, reason);\n\n  if (this.eventHooks.onEpochChange) {\n    const info: EpochChangeInfo = {\n      previousEpochId,\n      newEpochId: this.epochId,\n      reason,\n      timestamp: this.timeSource.now(),\n    };\n    try {\n      this.eventHooks.onEpochChange(info);\n    } catch (error) {\n      this.log.error(\"CommentRenderer.incrementEpoch.callback\", error as Error, { info });\n    }\n  }\n\n  this.comments.forEach((comment) => {\n    comment.epochId = this.epochId;\n  });\n};\n\nconst emitStateSnapshotImpl = function (this: CommentRenderer, label: string): void {\n  const now = this.timeSource.now();\n  if (now - this.lastSnapshotEmitTime < this.snapshotEmitThrottleMs) {\n    return;\n  }\n\n  const snapshot: RendererStateSnapshot = {\n    currentTime: this.currentTime,\n    duration: this.duration,\n    isPlaying: this.isPlaying,\n    epochId: this.epochId,\n    totalComments: this.comments.length,\n    activeComments: this.activeComments.size,\n    reservedLanes: this.reservedLanes.size,\n    finalPhaseActive: this.finalPhaseActive,\n    playbackHasBegun: this.playbackHasBegun,\n    isStalled: this.isStalled,\n  };\n\n  dumpRendererState(label, snapshot);\n\n  if (this.eventHooks.onStateSnapshot) {\n    try {\n      this.eventHooks.onStateSnapshot(snapshot);\n    } catch (error) {\n      this.log.error(\"CommentRenderer.emitStateSnapshot.callback\", error as Error);\n    }\n  }\n\n  this.lastSnapshotEmitTime = now;\n};\n\nconst getEffectiveCommentVposImpl = function (this: CommentRenderer, comment: Comment): number {\n  if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n  const override = this.finalPhaseVposOverrides.get(comment);\n  return override ?? comment.vposMs;\n};\n\nconst getFinalPhaseDisplayDurationImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n): number {\n  if (!comment.isScrolling) {\n    return STATIC_VISIBLE_DURATION_MS;\n  }\n\n  const durations: number[] = [];\n  if (Number.isFinite(comment.visibleDurationMs) && comment.visibleDurationMs > 0) {\n    durations.push(comment.visibleDurationMs);\n  }\n  if (Number.isFinite(comment.totalDurationMs) && comment.totalDurationMs > 0) {\n    durations.push(comment.totalDurationMs);\n  }\n\n  if (durations.length > 0) {\n    return Math.max(...durations);\n  }\n\n  return MAX_VISIBLE_DURATION_MS;\n};\n\nconst resolveFinalPhaseVposImpl = function (this: CommentRenderer, comment: Comment): number {\n  if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n    this.finalPhaseVposOverrides.delete(comment);\n    return comment.vposMs;\n  }\n  if (this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n  const override = this.finalPhaseVposOverrides.get(comment);\n  if (override !== undefined) {\n    return override;\n  }\n  const fallback = Math.max(comment.vposMs, this.finalPhaseStartTime);\n  this.finalPhaseVposOverrides.set(comment, fallback);\n  return fallback;\n};\n\nconst recomputeFinalPhaseTimelineImpl = function (this: CommentRenderer): void {\n  if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n    this.finalPhaseVposOverrides.clear();\n    this.finalPhaseScheduleDirty = false;\n    return;\n  }\n\n  const windowStart = this.finalPhaseStartTime;\n  const durationMs = this.duration > 0 ? this.duration : windowStart + FINAL_PHASE_MIN_WINDOW_MS;\n  const windowEnd = Math.max(windowStart + FINAL_PHASE_MIN_WINDOW_MS, durationMs);\n\n  const candidates = this.comments\n    .filter((comment) => {\n      if (comment.hasShown) {\n        return false;\n      }\n      if (comment.isInvisible) {\n        return false;\n      }\n      if (this.isNGComment(comment.text)) {\n        return false;\n      }\n      return comment.vposMs >= windowStart - ACTIVE_WINDOW_MS;\n    })\n    .sort((a, b) => {\n      const diff = a.vposMs - b.vposMs;\n      if (Math.abs(diff) > EDGE_EPSILON) {\n        return diff;\n      }\n      return a.creationIndex - b.creationIndex;\n    });\n\n  this.finalPhaseVposOverrides.clear();\n\n  if (candidates.length === 0) {\n    this.finalPhaseScheduleDirty = false;\n    return;\n  }\n\n  const windowSpan = Math.max(windowEnd - windowStart, FINAL_PHASE_MIN_WINDOW_MS);\n  const baseGap = windowSpan / Math.max(candidates.length, 1);\n  const boundedGap = Number.isFinite(baseGap) ? baseGap : FINAL_PHASE_MIN_GAP_MS;\n  const gap = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(boundedGap, FINAL_PHASE_MAX_GAP_MS));\n\n  let nextStart = windowStart;\n  candidates.forEach((comment, index) => {\n    const durationNeeded = Math.max(1, this.getFinalPhaseDisplayDuration(comment));\n    const availableLatestStart = windowEnd - durationNeeded;\n    let assigned = Math.max(windowStart, Math.min(nextStart, availableLatestStart));\n    if (!Number.isFinite(assigned)) {\n      assigned = windowStart;\n    }\n    const epsilon = FINAL_PHASE_ORDER_EPSILON_MS * index;\n    if (assigned + epsilon <= availableLatestStart) {\n      assigned += epsilon;\n    }\n    this.finalPhaseVposOverrides.set(comment, assigned);\n    const spacing = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(durationNeeded / 2, gap));\n    nextStart = assigned + spacing;\n  });\n\n  this.finalPhaseScheduleDirty = false;\n};\n\nexport const registerFinalPhaseMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.hardReset = hardResetImpl;\n  ctor.prototype.resetFinalPhaseState = resetFinalPhaseStateImpl;\n  ctor.prototype.incrementEpoch = incrementEpochImpl;\n  ctor.prototype.emitStateSnapshot = emitStateSnapshotImpl;\n  ctor.prototype.getEffectiveCommentVpos = getEffectiveCommentVposImpl;\n  ctor.prototype.getFinalPhaseDisplayDuration = getFinalPhaseDisplayDurationImpl;\n  ctor.prototype.resolveFinalPhaseVpos = resolveFinalPhaseVposImpl;\n  ctor.prototype.recomputeFinalPhaseTimeline = recomputeFinalPhaseTimelineImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { SEEK_DIRECTION_EPSILON_MS } from \"@/shared/constants\";\n\nconst shouldSuppressRenderingImpl = function (this: CommentRenderer): boolean {\n  return !this.playbackHasBegun && !this.isPlaying && this.currentTime <= SEEK_DIRECTION_EPSILON_MS;\n};\n\nconst updatePlaybackProgressStateImpl = function (this: CommentRenderer): void {\n  if (this.playbackHasBegun) {\n    return;\n  }\n  if (this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS) {\n    this.playbackHasBegun = true;\n  }\n};\n\nexport const registerPlaybackHelpers = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.shouldSuppressRendering = shouldSuppressRenderingImpl;\n  ctor.prototype.updatePlaybackProgressState = updatePlaybackProgressStateImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { CommentPrepareOptions } from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  BASE_COLLISION_BUFFER_PX,\n  COLLISION_BUFFER_RATIO,\n  ENTRY_BUFFER_PX,\n  FINAL_PHASE_THRESHOLD_MS,\n  MAX_COMMENT_WIDTH_RATIO,\n  MAX_VISIBLE_DURATION_MS,\n  MIN_VISIBLE_DURATION_MS,\n  SEEK_DIRECTION_EPSILON_MS,\n  VIRTUAL_CANVAS_EXTENSION_PX,\n  toMilliseconds,\n} from \"@/shared/constants\";\nimport { formatCommentPreview, debugLog, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst updateCommentsImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas || !context) {\n    return;\n  }\n\n  const referenceTime =\n    typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n  this.currentTime = referenceTime;\n  this.playbackRate = video.playbackRate;\n  this.isPlaying = !video.paused;\n  this.updatePlaybackProgressState();\n  this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n  if (this.skipDrawingForCurrentFrame) {\n    return;\n  }\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const isNearEnd =\n    this.duration > 0 && this.duration - this.currentTime <= FINAL_PHASE_THRESHOLD_MS;\n\n  if (isNearEnd && !this.finalPhaseActive) {\n    this.finalPhaseActive = true;\n    this.finalPhaseStartTime = this.currentTime;\n    this.finalPhaseVposOverrides.clear();\n    this.finalPhaseScheduleDirty = true;\n    context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    this.comments.forEach((comment) => {\n      comment.isActive = false;\n      comment.clearActivation();\n    });\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n  }\n\n  if (!isNearEnd && this.finalPhaseActive) {\n    this.resetFinalPhaseState();\n  }\n\n  if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n\n  this.pruneStaticLaneReservations(this.currentTime);\n\n  // ==== activeComments の定期クリーンアップ（古いコメント回収） ====\n  // 時間窓外のコメント、または画面外に完全に流れたコメントを削除\n  for (const comment of Array.from(this.activeComments)) {\n    const effectiveVpos = this.getEffectiveCommentVpos(comment);\n    const isPastWindow = effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS;\n    const isFutureWindow = effectiveVpos > this.currentTime + ACTIVE_WINDOW_MS;\n\n    // 時間窓外のコメントを削除\n    if (isPastWindow || isFutureWindow) {\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.clearActivation();\n      if (comment.lane >= 0) {\n        if (comment.layout === \"ue\") {\n          this.releaseStaticLane(\"ue\", comment.lane);\n        } else if (comment.layout === \"shita\") {\n          this.releaseStaticLane(\"shita\", comment.lane);\n        }\n      }\n      continue;\n    }\n\n    // スクロール完了したコメントを削除（再生中でなくても実行）\n    if (comment.isScrolling && comment.hasShown) {\n      const isOffScreen =\n        (comment.scrollDirection === \"rtl\" && comment.x <= comment.exitThreshold) ||\n        (comment.scrollDirection === \"ltr\" && comment.x >= comment.exitThreshold);\n\n      if (isOffScreen) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n  }\n\n  const activeWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  for (const comment of activeWindowComments) {\n    const debugActive = isDebugLoggingEnabled();\n    const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n    if (debugActive) {\n      debugLog(\"comment-evaluate\", {\n        stage: \"update\",\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: this.getEffectiveCommentVpos(comment),\n        currentTime: this.currentTime,\n        isActive: comment.isActive,\n        hasShown: comment.hasShown,\n      });\n    }\n\n    if (this.isNGComment(comment.text)) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"ng-runtime\",\n        });\n      }\n      continue;\n    }\n    if (comment.isInvisible) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"invisible\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.hasShown = true;\n      comment.clearActivation();\n      continue;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n    }\n\n    if (comment.isActive) {\n      if (comment.layout !== \"naka\" && comment.hasStaticExpired(this.currentTime)) {\n        const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n        this.releaseStaticLane(staticPosition, comment.lane);\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n        continue;\n      }\n\n      if (\n        comment.layout === \"naka\" &&\n        this.getEffectiveCommentVpos(comment) > this.currentTime + SEEK_DIRECTION_EPSILON_MS\n      ) {\n        comment.x = comment.virtualStartX;\n        comment.lastUpdateTime = this.timeSource.now();\n        continue;\n      }\n\n      comment.hasShown = true;\n      comment.update(this.playbackRate, !this.isPlaying);\n      if (!comment.isScrolling && comment.hasStaticExpired(this.currentTime)) {\n        const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n        this.releaseStaticLane(staticPosition, comment.lane);\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n  }\n};\n\nconst buildPrepareOptionsImpl = function (\n  this: CommentRenderer,\n  visibleWidth: number,\n): CommentPrepareOptions {\n  const overrideDuration = this._settings.scrollVisibleDurationMs;\n  let maxVisibleDurationMs = MAX_VISIBLE_DURATION_MS;\n  let minVisibleDurationMs = MIN_VISIBLE_DURATION_MS;\n\n  if (overrideDuration !== null) {\n    maxVisibleDurationMs = overrideDuration;\n    minVisibleDurationMs = Math.max(1, Math.min(overrideDuration, MIN_VISIBLE_DURATION_MS));\n  }\n\n  return {\n    visibleWidth,\n    virtualExtension: VIRTUAL_CANVAS_EXTENSION_PX,\n    maxVisibleDurationMs,\n    minVisibleDurationMs,\n    maxWidthRatio: MAX_COMMENT_WIDTH_RATIO,\n    bufferRatio: COLLISION_BUFFER_RATIO,\n    baseBufferPx: BASE_COLLISION_BUFFER_PX,\n    entryBufferPx: ENTRY_BUFFER_PX,\n  };\n};\n\nconst findAvailableLaneImpl = function (this: CommentRenderer, comment: Comment): number {\n  const currentTime = this.currentTime;\n  this.pruneLaneReservations(currentTime);\n  this.pruneStaticLaneReservations(currentTime);\n  const laneCandidates = this.getLanePriorityOrder(currentTime);\n  const newReservation = this.createLaneReservation(comment, currentTime);\n\n  for (const lane of laneCandidates) {\n    if (this.isLaneAvailable(lane, newReservation, currentTime)) {\n      this.storeLaneReservation(lane, newReservation);\n      return lane;\n    }\n  }\n\n  const fallbackLane = laneCandidates[0] ?? 0;\n  this.storeLaneReservation(fallbackLane, newReservation);\n  return fallbackLane;\n};\n\nexport const registerActivationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.updateComments = updateCommentsImpl;\n  ctor.prototype.buildPrepareOptions = buildPrepareOptionsImpl;\n  ctor.prototype.findAvailableLane = findAvailableLaneImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { LaneReservation, StaticLaneReservation } from \"@/shared/types\";\nimport { RESERVATION_TIME_MARGIN_MS } from \"@/shared/constants\";\n\nconst findFirstValidReservationIndexImpl = function (\n  this: CommentRenderer,\n  reservations: LaneReservation[],\n  cutoffTime: number,\n): number {\n  let left = 0;\n  let right = reservations.length;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const reservation = reservations[mid];\n    if (\n      reservation !== undefined &&\n      reservation.totalEndTime + RESERVATION_TIME_MARGIN_MS <= cutoffTime\n    ) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return left;\n};\n\nconst pruneLaneReservationsImpl = function (this: CommentRenderer, currentTime: number): void {\n  for (const [lane, reservations] of this.reservedLanes.entries()) {\n    const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n    if (firstValidIndex >= reservations.length) {\n      this.reservedLanes.delete(lane);\n    } else if (firstValidIndex > 0) {\n      this.reservedLanes.set(lane, reservations.slice(firstValidIndex));\n    }\n  }\n};\n\nconst pruneStaticLaneReservationsImpl = function (\n  this: CommentRenderer,\n  currentTime: number,\n): void {\n  const filterValid = (reservations: StaticLaneReservation[]): StaticLaneReservation[] =>\n    reservations.filter((reservation) => reservation.releaseTime > currentTime);\n\n  const topFiltered = filterValid(this.topStaticLaneReservations);\n  const bottomFiltered = filterValid(this.bottomStaticLaneReservations);\n\n  this.topStaticLaneReservations.length = 0;\n  this.topStaticLaneReservations.push(...topFiltered);\n\n  this.bottomStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.push(...bottomFiltered);\n};\n\nexport const registerLanePruneMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.findFirstValidReservationIndex = findFirstValidReservationIndexImpl;\n  ctor.prototype.pruneLaneReservations = pruneLaneReservationsImpl;\n  ctor.prototype.pruneStaticLaneReservations = pruneStaticLaneReservationsImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { Comment } from \"@/comment/comment\";\n\nconst findCommentIndexAtOrAfterImpl = function (\n  this: CommentRenderer,\n  targetVposMs: number,\n): number {\n  let left = 0;\n  let right = this.comments.length;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const comment = this.comments[mid];\n    if (comment !== undefined && comment.vposMs < targetVposMs) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return left;\n};\n\nconst getCommentsInTimeWindowImpl = function (\n  this: CommentRenderer,\n  centerTimeMs: number,\n  windowMs: number,\n): Comment[] {\n  if (this.comments.length === 0) {\n    return [];\n  }\n  const startTime = centerTimeMs - windowMs;\n  const endTime = centerTimeMs + windowMs;\n  const startIndex = this.findCommentIndexAtOrAfter(startTime);\n  const result: Comment[] = [];\n  for (let i = startIndex; i < this.comments.length; i++) {\n    const comment = this.comments[i];\n    if (!comment) {\n      continue;\n    }\n    if (comment.vposMs > endTime) {\n      break;\n    }\n    result.push(comment);\n  }\n  return result;\n};\n\nconst getStaticReservationsImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n): CommentRenderer[\"topStaticLaneReservations\"] {\n  return position === \"ue\" ? this.topStaticLaneReservations : this.bottomStaticLaneReservations;\n};\n\nconst getStaticLaneDepthImpl = function (this: CommentRenderer, position: \"ue\" | \"shita\"): number {\n  return position === \"ue\"\n    ? this.topStaticLaneReservations.length\n    : this.bottomStaticLaneReservations.length;\n};\n\nconst getStaticLaneLimitImpl = function (this: CommentRenderer, position: \"ue\" | \"shita\"): number {\n  const otherPosition = position === \"ue\" ? \"shita\" : \"ue\";\n  const otherDepth = this.getStaticLaneDepth(otherPosition);\n  const available = this.laneCount - otherDepth;\n  if (available <= 0) {\n    return -1;\n  }\n  return available - 1;\n};\n\nconst getGlobalLaneIndexForBottomImpl = function (\n  this: CommentRenderer,\n  localIndex: number,\n): number {\n  return Math.max(0, this.laneCount - 1 - localIndex);\n};\n\nconst resolveStaticCommentOffsetImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  lane: number,\n  displayHeight: number,\n  comment: Comment,\n): number {\n  const effectiveHeight = Math.max(1, displayHeight);\n  const commentHeight = Math.max(comment.height, comment.fontSize);\n  const edgePadding = 5;\n  const stackPadding = 2;\n\n  if (position === \"ue\") {\n    let cumulativeY = edgePadding;\n    const reservations = this.getStaticReservations(position);\n    const laneSortedReservations = reservations\n      .filter((r) => r.lane < lane)\n      .sort((a, b) => a.lane - b.lane);\n\n    for (const reservation of laneSortedReservations) {\n      const reservedHeight = reservation.yEnd - reservation.yStart;\n      cumulativeY += reservedHeight + stackPadding;\n    }\n\n    const maxY = Math.max(edgePadding, effectiveHeight - commentHeight - edgePadding);\n    return Math.max(edgePadding, Math.min(cumulativeY, maxY));\n  }\n\n  let cumulativeY = effectiveHeight - edgePadding;\n  const reservations = this.getStaticReservations(position);\n  const laneSortedReservations = reservations\n    .filter((r) => r.lane < lane)\n    .sort((a, b) => a.lane - b.lane);\n\n  for (const reservation of laneSortedReservations) {\n    const reservedHeight = reservation.yEnd - reservation.yStart;\n    cumulativeY -= reservedHeight + stackPadding;\n  }\n\n  const adjustedY = cumulativeY - commentHeight;\n  return Math.max(edgePadding, adjustedY);\n};\n\nconst getStaticReservedLaneSetImpl = function (this: CommentRenderer): Set<number> {\n  const reserved = new Set<number>();\n  for (const reservation of this.topStaticLaneReservations) {\n    reserved.add(reservation.lane);\n  }\n  for (const reservation of this.bottomStaticLaneReservations) {\n    reserved.add(this.getGlobalLaneIndexForBottom(reservation.lane));\n  }\n  return reserved;\n};\n\nexport const registerLaneStaticMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.findCommentIndexAtOrAfter = findCommentIndexAtOrAfterImpl;\n  ctor.prototype.getCommentsInTimeWindow = getCommentsInTimeWindowImpl;\n  ctor.prototype.getStaticReservations = getStaticReservationsImpl;\n  ctor.prototype.getStaticLaneDepth = getStaticLaneDepthImpl;\n  ctor.prototype.getStaticLaneLimit = getStaticLaneLimitImpl;\n  ctor.prototype.getGlobalLaneIndexForBottom = getGlobalLaneIndexForBottomImpl;\n  ctor.prototype.resolveStaticCommentOffset = resolveStaticCommentOffsetImpl;\n  ctor.prototype.getStaticReservedLaneSet = getStaticReservedLaneSetImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { CommentPrepareOptions } from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  EDGE_EPSILON,\n  FINAL_PHASE_MIN_WINDOW_MS,\n  SEEK_DIRECTION_EPSILON_MS,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"@/shared/constants\";\nimport { calculateStaticCommentVerticalPadding } from \"@/shared/settings\";\nimport { debugLog, formatCommentPreview, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst shouldActivateCommentAtTimeImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n  timeMs: number,\n  preview: string = \"\",\n): boolean {\n  const debugActive = preview.length > 0 && isDebugLoggingEnabled();\n  const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n  if (\n    this.finalPhaseActive &&\n    this.finalPhaseStartTime !== null &&\n    comment.vposMs < this.finalPhaseStartTime - EDGE_EPSILON\n  ) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"final-phase-trimmed\",\n        finalPhaseStartTime: this.finalPhaseStartTime,\n      });\n    }\n    this.finalPhaseVposOverrides.delete(comment);\n    return false;\n  }\n\n  if (comment.isInvisible) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"invisible\",\n      });\n    }\n    return false;\n  }\n  if (comment.isActive) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"already-active\",\n      });\n    }\n    return false;\n  }\n  if (comment.hasShown && effectiveVpos <= timeMs) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"already-shown\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n  if (effectiveVpos > timeMs + SEEK_DIRECTION_EPSILON_MS) {\n    if (debugActive) {\n      debugLog(\"comment-eval-pending\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"future\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n  if (effectiveVpos < timeMs - ACTIVE_WINDOW_MS) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"expired-window\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n\n  if (debugActive) {\n    debugLog(\"comment-eval-ready\", {\n      preview,\n      vposMs: comment.vposMs,\n      effectiveVposMs: effectiveVpos,\n      currentTime: timeMs,\n    });\n  }\n  return true;\n};\n\nconst activateCommentImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n  context: CanvasRenderingContext2D,\n  displayWidth: number,\n  displayHeight: number,\n  options: CommentPrepareOptions,\n  referenceTime: number,\n): void {\n  comment.prepare(context, displayWidth, displayHeight, options);\n  const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n  if (isDebugLoggingEnabled()) {\n    debugLog(\"comment-prepared\", {\n      preview: formatCommentPreview(comment.text),\n      layout: comment.layout,\n      isScrolling: comment.isScrolling,\n      width: comment.width,\n      height: comment.height,\n      bufferWidth: comment.bufferWidth,\n      visibleDurationMs: comment.visibleDurationMs,\n      effectiveVposMs: effectiveVpos,\n    });\n  }\n\n  if (comment.layout === \"naka\") {\n    const elapsedMs = Math.max(0, referenceTime - effectiveVpos);\n    const displacement = comment.speedPixelsPerMs * elapsedMs;\n\n    if (this.finalPhaseActive && this.finalPhaseStartTime !== null) {\n      const videoDuration =\n        this.duration > 0 ? this.duration : this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS;\n      const finalPhaseWindowEnd = Math.max(\n        this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS,\n        videoDuration,\n      );\n      const totalTravelDistance = comment.width + displayWidth;\n      const projectedTravelMs =\n        totalTravelDistance > 0 ? totalTravelDistance / Math.max(comment.speedPixelsPerMs, 1) : 0;\n      const projectedEndTime = effectiveVpos + projectedTravelMs;\n      if (projectedEndTime > finalPhaseWindowEnd) {\n        const remainingTime = finalPhaseWindowEnd - referenceTime;\n        const allowedTravel = Math.max(0, remainingTime) * comment.speedPixelsPerMs;\n        const startX =\n          comment.scrollDirection === \"rtl\"\n            ? Math.max(comment.virtualStartX - displacement, displayWidth - allowedTravel)\n            : Math.min(comment.virtualStartX + displacement, allowedTravel - comment.width);\n        comment.x = startX;\n      } else {\n        comment.x =\n          comment.scrollDirection === \"rtl\"\n            ? comment.virtualStartX - displacement\n            : comment.virtualStartX + displacement;\n      }\n    } else {\n      comment.x =\n        comment.scrollDirection === \"rtl\"\n          ? comment.virtualStartX - displacement\n          : comment.virtualStartX + displacement;\n    }\n    const laneIndex = this.findAvailableLane(comment);\n    comment.lane = laneIndex;\n    const laneHeight = Math.max(1, this.laneHeight);\n    const maxY = Math.max(0, displayHeight - comment.height);\n    const laneY = laneIndex * laneHeight;\n    comment.y = Math.max(0, Math.min(laneY, maxY));\n  } else {\n    const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n    const laneIndex = this.assignStaticLane(staticPosition, comment, displayHeight, referenceTime);\n    const verticalOffset = this.resolveStaticCommentOffset(\n      staticPosition,\n      laneIndex,\n      displayHeight,\n      comment,\n    );\n    comment.x = Math.max(0, Math.min(displayWidth - comment.width, comment.virtualStartX));\n    comment.y = verticalOffset;\n    comment.lane =\n      staticPosition === \"ue\" ? laneIndex : this.getGlobalLaneIndexForBottom(laneIndex);\n    comment.speed = 0;\n    comment.baseSpeed = 0;\n    comment.speedPixelsPerMs = 0;\n    comment.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n    const displayEnd = referenceTime + comment.visibleDurationMs;\n    this.activeComments.add(comment);\n    comment.isActive = true;\n    comment.hasShown = true;\n    comment.isPaused = !this.isPlaying;\n    comment.markActivated(referenceTime);\n    comment.lastUpdateTime = this.timeSource.now();\n    comment.staticExpiryTimeMs = displayEnd;\n    this.reserveStaticLane(staticPosition, comment, laneIndex, displayEnd);\n    if (isDebugLoggingEnabled()) {\n      debugLog(\"comment-activate-static\", {\n        preview: formatCommentPreview(comment.text),\n        lane: comment.lane,\n        position: staticPosition,\n        displayEnd,\n        effectiveVposMs: effectiveVpos,\n      });\n    }\n    return;\n  }\n\n  this.activeComments.add(comment);\n  comment.isActive = true;\n  comment.hasShown = true;\n  comment.isPaused = !this.isPlaying;\n  comment.markActivated(referenceTime);\n  comment.lastUpdateTime = this.timeSource.now();\n};\n\nconst assignStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  comment: Comment,\n  displayHeight: number,\n  currentTime: number,\n): number {\n  const reservations = this.getStaticReservations(position);\n  const limit = this.getStaticLaneLimit(position);\n  const laneCount = limit >= 0 ? limit + 1 : 0;\n  const laneIndices = Array.from({ length: laneCount }, (_, index) => index);\n\n  for (const lane of laneIndices) {\n    const yOffset = this.resolveStaticCommentOffset(position, lane, displayHeight, comment);\n    const commentHeight = Math.max(comment.height, comment.fontSize);\n    const padding = calculateStaticCommentVerticalPadding(comment.fontSize, lane);\n    const yStart = yOffset - padding;\n    const yEnd = yOffset + commentHeight + padding;\n\n    const hasConflict = reservations.some((reservation) => {\n      const timeOverlap = reservation.releaseTime > currentTime;\n      if (!timeOverlap) {\n        return false;\n      }\n      const yOverlap = !(yEnd <= reservation.yStart || yStart >= reservation.yEnd);\n      return yOverlap;\n    });\n\n    if (!hasConflict) {\n      return lane;\n    }\n  }\n\n  let fallbackLane = laneIndices[0] ?? 0;\n  let earliestRelease = Number.POSITIVE_INFINITY;\n  for (const reservation of reservations) {\n    if (reservation.releaseTime < earliestRelease) {\n      earliestRelease = reservation.releaseTime;\n      fallbackLane = reservation.lane;\n    }\n  }\n  return fallbackLane;\n};\n\nconst reserveStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  comment: Comment,\n  lane: number,\n  releaseTime: number,\n): void {\n  const reservations = this.getStaticReservations(position);\n  const commentHeight = Math.max(comment.height, comment.fontSize);\n  const padding = calculateStaticCommentVerticalPadding(comment.fontSize, lane);\n  const yStart = comment.y - padding;\n  const yEnd = comment.y + commentHeight + padding;\n\n  reservations.push({\n    comment,\n    releaseTime,\n    yStart,\n    yEnd,\n    lane,\n  });\n};\n\nconst releaseStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  lane: number,\n): void {\n  if (lane < 0) {\n    return;\n  }\n  const reservations = this.getStaticReservations(position);\n  const index = reservations.findIndex((r) => r.lane === lane);\n  if (index >= 0) {\n    reservations.splice(index, 1);\n  }\n};\n\nexport const registerLaneActivationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.shouldActivateCommentAtTime = shouldActivateCommentAtTimeImpl;\n  ctor.prototype.activateComment = activateCommentImpl;\n  ctor.prototype.assignStaticLane = assignStaticLaneImpl;\n  ctor.prototype.reserveStaticLane = reserveStaticLaneImpl;\n  ctor.prototype.releaseStaticLane = releaseStaticLaneImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { LaneReservation } from \"@/shared/types\";\nimport { EDGE_EPSILON, RESERVATION_TIME_MARGIN_MS } from \"@/shared/constants\";\n\nconst getLanePriorityOrderImpl = function (this: CommentRenderer, currentTime: number): number[] {\n  const indices = Array.from({ length: this.laneCount }, (_, index) => index);\n  const sorted = indices.sort((a, b) => {\n    const nextA = this.getLaneNextAvailableTime(a, currentTime);\n    const nextB = this.getLaneNextAvailableTime(b, currentTime);\n    if (Math.abs(nextA - nextB) <= EDGE_EPSILON) {\n      return a - b;\n    }\n    return nextA - nextB;\n  });\n  const staticReserved = this.getStaticReservedLaneSet();\n  if (staticReserved.size === 0) {\n    return sorted;\n  }\n  const preferred = sorted.filter((lane) => !staticReserved.has(lane));\n  if (preferred.length === 0) {\n    return sorted;\n  }\n  const blocked = sorted.filter((lane) => staticReserved.has(lane));\n  return [...preferred, ...blocked];\n};\n\nconst getLaneNextAvailableTimeImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  currentTime: number,\n): number {\n  const reservations = this.reservedLanes.get(lane);\n  if (!reservations || reservations.length === 0) {\n    return currentTime;\n  }\n  const validIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n  const candidate = reservations[validIndex];\n  if (!candidate) {\n    return currentTime;\n  }\n  return Math.max(currentTime, candidate.endTime + RESERVATION_TIME_MARGIN_MS);\n};\n\nconst createLaneReservationImpl = function (\n  this: CommentRenderer,\n  comment: CommentRenderer[\"comments\"][number],\n  referenceTime: number,\n): LaneReservation {\n  const speed = Math.max(comment.speedPixelsPerMs, EDGE_EPSILON);\n  const effectiveStart = this.getEffectiveCommentVpos(comment);\n  const baseStartTime = Number.isFinite(effectiveStart) ? effectiveStart : referenceTime;\n  const startTime = Math.max(0, baseStartTime);\n  const endTime = startTime + comment.preCollisionDurationMs + RESERVATION_TIME_MARGIN_MS;\n  const totalEndTime = startTime + comment.totalDurationMs + RESERVATION_TIME_MARGIN_MS;\n  return {\n    comment,\n    startTime,\n    endTime: Math.max(startTime, endTime),\n    totalEndTime: Math.max(startTime, totalEndTime),\n    startLeft: comment.virtualStartX,\n    width: comment.width,\n    speed,\n    buffer: comment.bufferWidth,\n    directionSign: comment.getDirectionSign(),\n  };\n};\n\nconst isLaneAvailableImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  candidate: LaneReservation,\n  currentTime: number,\n): boolean {\n  const reservations = this.reservedLanes.get(lane);\n  if (!reservations || reservations.length === 0) {\n    return true;\n  }\n  const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n  for (let i = firstValidIndex; i < reservations.length; i += 1) {\n    const reservation = reservations[i];\n    if (!reservation) {\n      continue;\n    }\n    if (this.areReservationsConflicting(reservation, candidate)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst storeLaneReservationImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  reservation: LaneReservation,\n): void {\n  const existing = this.reservedLanes.get(lane) ?? [];\n  const updated = [...existing, reservation].sort((a, b) => a.totalEndTime - b.totalEndTime);\n  this.reservedLanes.set(lane, updated);\n};\n\nconst areReservationsConflictingImpl = function (\n  this: CommentRenderer,\n  a: LaneReservation,\n  b: LaneReservation,\n): boolean {\n  const overlapStart = Math.max(a.startTime, b.startTime);\n  const overlapEnd = Math.min(a.endTime, b.endTime);\n  if (overlapStart >= overlapEnd) {\n    return false;\n  }\n\n  const evaluationTimes = new Set<number>([\n    overlapStart,\n    overlapEnd,\n    overlapStart + (overlapEnd - overlapStart) / 2,\n  ]);\n\n  const forwardIntersection = this.solveLeftRightEqualityTime(a, b);\n  if (\n    forwardIntersection !== null &&\n    forwardIntersection >= overlapStart - EDGE_EPSILON &&\n    forwardIntersection <= overlapEnd + EDGE_EPSILON\n  ) {\n    evaluationTimes.add(forwardIntersection);\n  }\n\n  const backwardIntersection = this.solveLeftRightEqualityTime(b, a);\n  if (\n    backwardIntersection !== null &&\n    backwardIntersection >= overlapStart - EDGE_EPSILON &&\n    backwardIntersection <= overlapEnd + EDGE_EPSILON\n  ) {\n    evaluationTimes.add(backwardIntersection);\n  }\n\n  for (const time of evaluationTimes) {\n    if (time < overlapStart - EDGE_EPSILON || time > overlapEnd + EDGE_EPSILON) {\n      continue;\n    }\n    const forwardGap = this.computeForwardGap(a, b, time);\n    const backwardGap = this.computeForwardGap(b, a, time);\n    if (forwardGap <= EDGE_EPSILON && backwardGap <= EDGE_EPSILON) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst computeForwardGapImpl = function (\n  this: CommentRenderer,\n  from: LaneReservation,\n  to: LaneReservation,\n  time: number,\n): number {\n  const fromEdges = this.getBufferedEdges(from, time);\n  const toEdges = this.getBufferedEdges(to, time);\n  return fromEdges.left - toEdges.right;\n};\n\nconst getBufferedEdgesImpl = function (\n  this: CommentRenderer,\n  reservation: LaneReservation,\n  time: number,\n): { left: number; right: number } {\n  const elapsed = Math.max(0, time - reservation.startTime);\n  const displacement = reservation.speed * elapsed;\n  const rawLeft = reservation.startLeft + reservation.directionSign * displacement;\n  const left = rawLeft - reservation.buffer;\n  const right = rawLeft + reservation.width + reservation.buffer;\n  return { left, right };\n};\n\nconst solveLeftRightEqualityTimeImpl = function (\n  this: CommentRenderer,\n  left: LaneReservation,\n  right: LaneReservation,\n): number | null {\n  const leftSign = left.directionSign;\n  const rightSign = right.directionSign;\n  const denominator = rightSign * right.speed - leftSign * left.speed;\n  if (Math.abs(denominator) < EDGE_EPSILON) {\n    return null;\n  }\n  const numerator =\n    right.startLeft +\n    rightSign * right.speed * right.startTime +\n    right.width +\n    right.buffer -\n    left.startLeft -\n    leftSign * left.speed * left.startTime +\n    left.buffer;\n  const time = numerator / denominator;\n  if (!Number.isFinite(time)) {\n    return null;\n  }\n  return time;\n};\n\nexport const registerLaneReservationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.getLanePriorityOrder = getLanePriorityOrderImpl;\n  ctor.prototype.getLaneNextAvailableTime = getLaneNextAvailableTimeImpl;\n  ctor.prototype.createLaneReservation = createLaneReservationImpl;\n  ctor.prototype.isLaneAvailable = isLaneAvailableImpl;\n  ctor.prototype.storeLaneReservation = storeLaneReservationImpl;\n  ctor.prototype.areReservationsConflicting = areReservationsConflictingImpl;\n  ctor.prototype.computeForwardGap = computeForwardGapImpl;\n  ctor.prototype.getBufferedEdges = getBufferedEdgesImpl;\n  ctor.prototype.solveLeftRightEqualityTime = solveLeftRightEqualityTimeImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { ACTIVE_WINDOW_MS, EDGE_EPSILON, toMilliseconds } from \"@/shared/constants\";\n\nconst drawImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!canvas || !context) {\n    return;\n  }\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n\n  const now = this.timeSource.now();\n\n  if (this.skipDrawingForCurrentFrame || this.shouldSuppressRendering() || this.isStalled) {\n    context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    this.lastDrawTime = now;\n    return;\n  }\n\n  context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n  const activeComments = Array.from(this.activeComments);\n\n  if (this._settings.isCommentVisible) {\n    const deltaTime = (now - this.lastDrawTime) / (1000 / 60);\n    activeComments.sort((a, b) => {\n      const aVpos = this.getEffectiveCommentVpos(a);\n      const bVpos = this.getEffectiveCommentVpos(b);\n      const vposMsDiff = aVpos - bVpos;\n      if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n        return vposMsDiff;\n      }\n      if (a.isScrolling !== b.isScrolling) {\n        return a.isScrolling ? 1 : -1;\n      }\n      return a.creationIndex - b.creationIndex;\n    });\n    activeComments.forEach((comment) => {\n      const shouldInterpolate = this.isPlaying && !comment.isPaused;\n      const interpolatedX = shouldInterpolate\n        ? comment.x + comment.getDirectionSign() * comment.speed * deltaTime\n        : comment.x;\n      comment.draw(context, interpolatedX);\n    });\n  }\n\n  this.lastDrawTime = now;\n};\n\nconst performInitialSyncImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas || !context) {\n    return;\n  }\n\n  const absoluteTime =\n    typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n  this.currentTime = absoluteTime;\n  this.lastDrawTime = this.timeSource.now();\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const windowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  windowComments.forEach((comment) => {\n    if (this.isNGComment(comment.text) || comment.isInvisible) {\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.clearActivation();\n      return;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n    comment.isActive = false;\n    this.activeComments.delete(comment);\n    comment.lane = -1;\n    comment.clearActivation();\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n      return;\n    }\n\n    const effectiveVpos = this.getEffectiveCommentVpos(comment);\n    if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n      comment.hasShown = true;\n    } else {\n      comment.hasShown = false;\n    }\n  });\n};\n\nexport const registerRenderMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.draw = drawImpl;\n  ctor.prototype.performInitialSync = performInitialSyncImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { ACTIVE_WINDOW_MS, SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\nimport type {\n  RequestVideoFrameCallback,\n  CancelVideoFrameCallback,\n  VideoFrameCallbackMetadataLike,\n} from \"@/shared/types\";\nimport { formatCommentPreview, debugLog, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst processFrameImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  if (!this.videoElement) {\n    return;\n  }\n  if (!this._settings.isCommentVisible) {\n    return;\n  }\n\n  if (this.pendingInitialSync) {\n    this.performInitialSync(frameTimeMs);\n    this.pendingInitialSync = false;\n  }\n\n  this.updateComments(frameTimeMs);\n  this.draw();\n};\n\nconst handleAnimationFrameImpl = function (this: CommentRenderer): void {\n  const pendingId = this.frameId;\n  this.frameId = null;\n  if (pendingId !== null) {\n    this.animationFrameProvider.cancel(pendingId);\n  }\n  this.processFrame();\n  this.scheduleNextFrame();\n};\n\nconst handleVideoFrameImpl = function (\n  this: CommentRenderer,\n  _now: DOMHighResTimeStamp,\n  metadata: VideoFrameCallbackMetadataLike,\n): void {\n  this.videoFrameHandle = null;\n  const mediaTime = typeof metadata?.mediaTime === \"number\" ? metadata.mediaTime * 1000 : undefined;\n  this.processFrame(typeof mediaTime === \"number\" ? mediaTime : undefined);\n  this.scheduleNextFrame();\n};\n\nconst shouldUseVideoFrameCallbackImpl = function (this: CommentRenderer): boolean {\n  if (this._settings.syncMode !== \"video-frame\") {\n    return false;\n  }\n  const video = this.videoElement as HTMLVideoElement & {\n    requestVideoFrameCallback?: RequestVideoFrameCallback;\n    cancelVideoFrameCallback?: CancelVideoFrameCallback;\n  };\n  return (\n    Boolean(video) &&\n    typeof video.requestVideoFrameCallback === \"function\" &&\n    typeof video.cancelVideoFrameCallback === \"function\"\n  );\n};\n\nconst scheduleNextFrameImpl = function (this: CommentRenderer): void {\n  const video = this.videoElement;\n  if (!video) {\n    return;\n  }\n  if (this.shouldUseVideoFrameCallback()) {\n    this.cancelAnimationFrameRequest();\n    this.cancelVideoFrameCallback();\n    const request = (\n      video as HTMLVideoElement & {\n        requestVideoFrameCallback?: RequestVideoFrameCallback;\n      }\n    ).requestVideoFrameCallback;\n    if (typeof request === \"function\") {\n      this.videoFrameHandle = request.call(video, this.handleVideoFrame);\n    }\n    return;\n  }\n  this.cancelVideoFrameCallback();\n  this.frameId = this.animationFrameProvider.request(this.handleAnimationFrame);\n};\n\nconst cancelAnimationFrameRequestImpl = function (this: CommentRenderer): void {\n  if (this.frameId !== null) {\n    this.animationFrameProvider.cancel(this.frameId);\n    this.frameId = null;\n  }\n};\n\nconst cancelVideoFrameCallbackImpl = function (this: CommentRenderer): void {\n  if (this.videoFrameHandle === null) {\n    return;\n  }\n  const video = this.videoElement as HTMLVideoElement & {\n    cancelVideoFrameCallback?: CancelVideoFrameCallback;\n  };\n  if (video && typeof video.cancelVideoFrameCallback === \"function\") {\n    video.cancelVideoFrameCallback(this.videoFrameHandle);\n  }\n  this.videoFrameHandle = null;\n};\n\nconst startAnimationImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  this.scheduleNextFrame();\n};\n\nconst stopAnimationImpl = function (this: CommentRenderer): void {\n  this.cancelAnimationFrameRequest();\n  this.cancelVideoFrameCallback();\n};\n\nconst onSeekImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const context = this.ctx;\n  const video = this.videoElement;\n  if (!canvas || !context || !video) {\n    return;\n  }\n\n  const nextTime = toMilliseconds(video.currentTime);\n  const timeDelta = Math.abs(nextTime - this.currentTime);\n  const now = this.timeSource.now();\n\n  const isRecentPlayResume = now - this.lastPlayResumeTime < this.playResumeSeekIgnoreDurationMs;\n  if (isRecentPlayResume) {\n    this.currentTime = nextTime;\n    if (this._settings.isCommentVisible) {\n      this.lastDrawTime = now;\n      this.draw();\n    }\n    return;\n  }\n\n  const isSignificantSeek = timeDelta > SEEK_DIRECTION_EPSILON_MS;\n\n  this.currentTime = nextTime;\n  this.resetFinalPhaseState();\n  this.updatePlaybackProgressState();\n\n  if (!isSignificantSeek) {\n    if (this._settings.isCommentVisible) {\n      this.lastDrawTime = this.timeSource.now();\n      this.draw();\n    }\n    return;\n  }\n\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const seekWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  seekWindowComments.forEach((comment) => {\n    const debugActive = isDebugLoggingEnabled();\n    const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n    if (debugActive) {\n      debugLog(\"comment-evaluate\", {\n        stage: \"seek\",\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: this.getEffectiveCommentVpos(comment),\n        currentTime: this.currentTime,\n        isActive: comment.isActive,\n        hasShown: comment.hasShown,\n      });\n    }\n\n    if (this.isNGComment(comment.text)) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"ng-runtime\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.clearActivation();\n      return;\n    }\n\n    if (comment.isInvisible) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"invisible\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.hasShown = true;\n      comment.clearActivation();\n      return;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n    comment.isActive = false;\n    this.activeComments.delete(comment);\n    comment.lane = -1;\n    comment.clearActivation();\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n      return;\n    }\n\n    const effectiveVpos = this.getEffectiveCommentVpos(comment);\n    if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n      comment.hasShown = true;\n    } else {\n      comment.hasShown = false;\n    }\n  });\n\n  if (this._settings.isCommentVisible) {\n    this.lastDrawTime = this.timeSource.now();\n    this.draw();\n  }\n};\n\nexport const registerTimingMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.processFrame = processFrameImpl;\n  ctor.prototype.handleAnimationFrame = handleAnimationFrameImpl;\n  ctor.prototype.handleVideoFrame = handleVideoFrameImpl;\n  ctor.prototype.shouldUseVideoFrameCallback = shouldUseVideoFrameCallbackImpl;\n  ctor.prototype.scheduleNextFrame = scheduleNextFrameImpl;\n  ctor.prototype.cancelAnimationFrameRequest = cancelAnimationFrameRequestImpl;\n  ctor.prototype.cancelVideoFrameCallback = cancelVideoFrameCallbackImpl;\n  ctor.prototype.startAnimation = startAnimationImpl;\n  ctor.prototype.stopAnimation = stopAnimationImpl;\n  ctor.prototype.onSeek = onSeekImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nexport type AutoHardResetReason =\n  | \"play-resume\"\n  | \"first-play-delay\"\n  | \"resize\"\n  | \"visibility-restore\"\n  | \"seeked\";\n\nconst shouldAutoHardReset = (renderer: CommentRenderer): boolean =>\n  renderer._settings.enableAutoHardReset;\n\nexport const requestAutoHardReset = (\n  renderer: CommentRenderer,\n  reason: AutoHardResetReason,\n): void => {\n  if (!shouldAutoHardReset(renderer)) {\n    return;\n  }\n  void reason;\n  const now = renderer.timeSource.now();\n  if (now - renderer.lastHardResetAt < renderer.autoHardResetDedupWindowMs) {\n    return;\n  }\n  renderer.hardReset();\n};\n\nexport const scheduleInitialPlaybackAutoReset = (renderer: CommentRenderer): void => {\n  if (!shouldAutoHardReset(renderer)) {\n    return;\n  }\n  if (renderer.initialPlaybackAutoResetTriggered) {\n    return;\n  }\n  if (renderer.initialPlaybackAutoResetTimer !== null) {\n    return;\n  }\n  renderer.initialPlaybackAutoResetTimer = globalThis.setTimeout(() => {\n    renderer.initialPlaybackAutoResetTimer = null;\n    if (!shouldAutoHardReset(renderer)) {\n      return;\n    }\n    renderer.initialPlaybackAutoResetTriggered = true;\n    requestAutoHardReset(renderer, \"first-play-delay\");\n  }, renderer.initialPlaybackAutoResetDelayMs);\n};\n\nexport const resetInitialPlaybackAutoResetState = (renderer: CommentRenderer): void => {\n  if (renderer.initialPlaybackAutoResetTimer !== null) {\n    globalThis.clearTimeout(renderer.initialPlaybackAutoResetTimer);\n    renderer.initialPlaybackAutoResetTimer = null;\n  }\n  renderer.initialPlaybackAutoResetTriggered = false;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { resetInitialPlaybackAutoResetState } from \"@/renderer/auto-hard-reset\";\nimport type { CommentRendererInitializeOptions } from \"@/shared/types\";\nimport { SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\n\nconst resolveContainerImpl = function (\n  this: CommentRenderer,\n  explicit: HTMLElement | null | undefined,\n  video: HTMLVideoElement,\n): HTMLElement {\n  if (explicit) {\n    return explicit;\n  }\n  if (video.parentElement) {\n    return video.parentElement;\n  }\n  if (typeof document !== \"undefined\" && document.body) {\n    return document.body;\n  }\n  throw new Error(\n    \"Cannot resolve container element. Provide container explicitly when DOM is unavailable.\",\n  );\n};\n\nconst ensureContainerPositioningImpl = function (\n  this: CommentRenderer,\n  container: HTMLElement,\n): void {\n  if (typeof getComputedStyle === \"function\") {\n    const style = getComputedStyle(container);\n    if (style.position === \"static\") {\n      container.style.position = \"relative\";\n    }\n    return;\n  }\n  if (!container.style.position) {\n    container.style.position = \"relative\";\n  }\n};\n\nconst initializeImpl = function (\n  this: CommentRenderer,\n  options: HTMLVideoElement | CommentRendererInitializeOptions,\n): void {\n  try {\n    this.destroyCanvasOnly();\n\n    const video = options instanceof HTMLVideoElement ? options : options.video;\n    const containerCandidate =\n      options instanceof HTMLVideoElement\n        ? options.parentElement\n        : (options.container ?? options.video.parentElement);\n    const container = this.resolveContainer(containerCandidate ?? null, video);\n\n    this.videoElement = video;\n    this.containerElement = container;\n    this.lastVideoSource = this.getCurrentVideoSource();\n    this.duration = Number.isFinite(video.duration) ? toMilliseconds(video.duration) : 0;\n    this.currentTime = toMilliseconds(video.currentTime);\n    this.playbackRate = video.playbackRate;\n    this.isPlaying = !video.paused;\n    this.isStalled = false;\n    this.lastDrawTime = this.timeSource.now();\n    this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n    this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n\n    const canvas = this.createCanvasElement();\n    const context = canvas.getContext(\"2d\");\n    if (!context) {\n      throw new Error(\"Failed to acquire 2D canvas context\");\n    }\n\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0\";\n    canvas.style.left = \"0\";\n    canvas.style.pointerEvents = \"none\";\n    canvas.style.zIndex = \"1000\";\n\n    const parent = this.containerElement;\n    if (parent instanceof HTMLElement) {\n      this.ensureContainerPositioning(parent);\n      parent.appendChild(canvas);\n    }\n\n    this.canvas = canvas;\n    this.ctx = context;\n\n    this.resize();\n    this.calculateLaneMetrics();\n    this.setupVideoEventListeners(video);\n    this.setupResizeHandling(video);\n    this.setupFullscreenHandling();\n    this.setupVideoChangeDetection(video, container);\n    this.startAnimation();\n    this.setupVisibilityHandling();\n  } catch (error) {\n    this.log.error(\"CommentRenderer.initialize\", error as Error);\n    throw error;\n  }\n};\n\nconst destroyImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  this.cleanupResizeHandling();\n  this.runCleanupTasks();\n  resetInitialPlaybackAutoResetState(this);\n\n  if (this.canvas) {\n    this.canvas.remove();\n  }\n  this.canvas = null;\n  this.ctx = null;\n  this.videoElement = null;\n  this.containerElement = null;\n  this.comments.length = 0;\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.resetFinalPhaseState();\n  this.displayWidth = 0;\n  this.displayHeight = 0;\n  this.canvasDpr = 1;\n  this.commentSequence = 0;\n  this.playbackHasBegun = false;\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n};\n\nconst destroyCanvasOnlyImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  resetInitialPlaybackAutoResetState(this);\n  if (this.canvas) {\n    this.canvas.remove();\n  }\n  this.canvas = null;\n  this.ctx = null;\n  this.displayWidth = 0;\n  this.displayHeight = 0;\n  this.canvasDpr = 1;\n  this.fullscreenActive = false;\n};\n\nexport const registerLifecycleCoreMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.resolveContainer = resolveContainerImpl;\n  ctor.prototype.ensureContainerPositioning = ensureContainerPositioningImpl;\n  ctor.prototype.initialize = initializeImpl;\n  ctor.prototype.destroy = destroyImpl;\n  ctor.prototype.destroyCanvasOnly = destroyCanvasOnlyImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport {\n  requestAutoHardReset,\n  resetInitialPlaybackAutoResetState,\n  scheduleInitialPlaybackAutoReset,\n} from \"@/renderer/auto-hard-reset\";\nimport { SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\n\nconst setupVideoEventListenersImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  try {\n    const onPlay = (): void => {\n      const wasPlaying = this.isPlaying;\n      this.isPlaying = true;\n      this.playbackHasBegun = true;\n      const now = this.timeSource.now();\n      this.lastDrawTime = now;\n      this.lastPlayResumeTime = now;\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n        comment.isPaused = false;\n      });\n      if (!wasPlaying) {\n        requestAutoHardReset(this, \"play-resume\");\n      }\n      scheduleInitialPlaybackAutoReset(this);\n    };\n    const onPause = (): void => {\n      this.isPlaying = false;\n      const now = this.timeSource.now();\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n        comment.isPaused = true;\n      });\n    };\n    const onSeeking = (): void => {\n      this.onSeek();\n    };\n    const onSeeked = (): void => {\n      this.onSeek();\n      requestAutoHardReset(this, \"seeked\");\n    };\n    const onRateChange = (): void => {\n      this.playbackRate = videoElement.playbackRate;\n      const now = this.timeSource.now();\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n      });\n    };\n    const onLoadedMetadata = (): void => {\n      this.handleVideoMetadataLoaded(videoElement);\n    };\n    const onDurationChange = (): void => {\n      this.duration = Number.isFinite(videoElement.duration)\n        ? toMilliseconds(videoElement.duration)\n        : 0;\n    };\n    const onEmptied = (): void => {\n      this.handleVideoSourceChange();\n    };\n    const onWaiting = (): void => {\n      this.handleVideoStalled();\n    };\n    const onCanPlay = (): void => {\n      this.handleVideoCanPlay();\n    };\n    const onPlaying = (): void => {\n      this.handleVideoCanPlay();\n    };\n\n    videoElement.addEventListener(\"play\", onPlay);\n    videoElement.addEventListener(\"pause\", onPause);\n    videoElement.addEventListener(\"seeking\", onSeeking);\n    videoElement.addEventListener(\"seeked\", onSeeked);\n    videoElement.addEventListener(\"ratechange\", onRateChange);\n    videoElement.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n    videoElement.addEventListener(\"durationchange\", onDurationChange);\n    videoElement.addEventListener(\"emptied\", onEmptied);\n    videoElement.addEventListener(\"waiting\", onWaiting);\n    videoElement.addEventListener(\"canplay\", onCanPlay);\n    videoElement.addEventListener(\"playing\", onPlaying);\n\n    this.addCleanup(() => videoElement.removeEventListener(\"play\", onPlay));\n    this.addCleanup(() => videoElement.removeEventListener(\"pause\", onPause));\n    this.addCleanup(() => videoElement.removeEventListener(\"seeking\", onSeeking));\n    this.addCleanup(() => videoElement.removeEventListener(\"seeked\", onSeeked));\n    this.addCleanup(() => videoElement.removeEventListener(\"ratechange\", onRateChange));\n    this.addCleanup(() => videoElement.removeEventListener(\"loadedmetadata\", onLoadedMetadata));\n    this.addCleanup(() => videoElement.removeEventListener(\"durationchange\", onDurationChange));\n    this.addCleanup(() => videoElement.removeEventListener(\"emptied\", onEmptied));\n    this.addCleanup(() => videoElement.removeEventListener(\"waiting\", onWaiting));\n    this.addCleanup(() => videoElement.removeEventListener(\"canplay\", onCanPlay));\n    this.addCleanup(() => videoElement.removeEventListener(\"playing\", onPlaying));\n  } catch (error) {\n    this.log.error(\"CommentRenderer.setupVideoEventListeners\", error as Error);\n    throw error;\n  }\n};\n\nconst handleVideoMetadataLoadedImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  this.lastVideoSource = this.getCurrentVideoSource();\n  this.incrementEpoch(\"metadata-loaded\");\n  this.handleVideoSourceChange(videoElement);\n  this.resize();\n  this.calculateLaneMetrics();\n  this.hardReset();\n  this.onSeek();\n  this.emitStateSnapshot(\"metadata-loaded\");\n  resetInitialPlaybackAutoResetState(this);\n};\n\nconst handleVideoStalledImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  if (!canvas || !ctx) {\n    return;\n  }\n\n  this.isStalled = true;\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n\n  this.comments.forEach((comment) => {\n    if (comment.isActive) {\n      comment.lastUpdateTime = this.timeSource.now();\n    }\n  });\n};\n\nconst handleVideoCanPlayImpl = function (this: CommentRenderer): void {\n  if (!this.isStalled) {\n    return;\n  }\n\n  this.isStalled = false;\n\n  if (this.videoElement) {\n    this.currentTime = toMilliseconds(this.videoElement.currentTime);\n    this.isPlaying = !this.videoElement.paused;\n  }\n\n  this.lastDrawTime = this.timeSource.now();\n};\n\nconst handleVideoSourceChangeImpl = function (\n  this: CommentRenderer,\n  videoElement?: HTMLVideoElement | null,\n): void {\n  const target = videoElement ?? this.videoElement;\n  if (!target) {\n    this.lastVideoSource = null;\n    this.isPlaying = false;\n    this.resetFinalPhaseState();\n    this.resetCommentActivity();\n    resetInitialPlaybackAutoResetState(this);\n    return;\n  }\n\n  const currentSource = this.getCurrentVideoSource();\n  const sourceChanged = currentSource !== this.lastVideoSource;\n  if (!sourceChanged) {\n    return;\n  }\n\n  this.lastVideoSource = currentSource;\n  this.incrementEpoch(\"source-change\");\n  this.syncVideoState(target);\n  this.resetFinalPhaseState();\n  this.resetCommentActivity();\n  this.emitStateSnapshot(\"source-change\");\n  resetInitialPlaybackAutoResetState(this);\n};\n\nconst syncVideoStateImpl = function (this: CommentRenderer, videoElement: HTMLVideoElement): void {\n  this.duration = Number.isFinite(videoElement.duration)\n    ? toMilliseconds(videoElement.duration)\n    : 0;\n  this.currentTime = toMilliseconds(videoElement.currentTime);\n  this.playbackRate = videoElement.playbackRate;\n  this.isPlaying = !videoElement.paused;\n  this.isStalled = false;\n  this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n  this.lastDrawTime = this.timeSource.now();\n};\n\nconst resetCommentActivityImpl = function (this: CommentRenderer): void {\n  const now = this.timeSource.now();\n  const canvas = this.canvas;\n  const context = this.ctx;\n  this.resetFinalPhaseState();\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n  this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n  if (canvas && context) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const width = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const height = this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    context.clearRect(0, 0, width, height);\n  }\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  this.comments.forEach((comment) => {\n    comment.isActive = false;\n    comment.isPaused = !this.isPlaying;\n    comment.hasShown = false;\n    comment.lane = -1;\n    comment.x = comment.virtualStartX;\n    comment.speed = comment.baseSpeed;\n    comment.lastUpdateTime = now;\n    comment.clearActivation();\n  });\n  this.activeComments.clear();\n};\n\nconst setupVideoChangeDetectionImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n  container: HTMLElement,\n): void {\n  if (typeof MutationObserver === \"undefined\") {\n    this.log.debug(\n      \"MutationObserver is not available in this environment. Video change detection is disabled.\",\n    );\n    return;\n  }\n\n  const videoObserver = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      if (mutation.type === \"attributes\" && mutation.attributeName === \"src\") {\n        const targetNode = mutation.target;\n        let previous: string | null = null;\n        let current: string | null = null;\n        if (targetNode instanceof HTMLVideoElement || targetNode instanceof HTMLSourceElement) {\n          previous = typeof mutation.oldValue === \"string\" ? mutation.oldValue : null;\n          current = targetNode.getAttribute(\"src\");\n        }\n        if (previous === current) {\n          continue;\n        }\n        this.handleVideoSourceChange(videoElement);\n        return;\n      }\n      if (mutation.type === \"childList\") {\n        for (const node of mutation.addedNodes) {\n          if (node instanceof HTMLSourceElement) {\n            this.handleVideoSourceChange(videoElement);\n            return;\n          }\n        }\n        for (const node of mutation.removedNodes) {\n          if (node instanceof HTMLSourceElement) {\n            this.handleVideoSourceChange(videoElement);\n            return;\n          }\n        }\n      }\n    }\n  });\n\n  videoObserver.observe(videoElement, {\n    attributes: true,\n    attributeFilter: [\"src\"],\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  this.addCleanup(() => videoObserver.disconnect());\n\n  const containerObserver = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      if (mutation.type !== \"childList\") {\n        continue;\n      }\n      for (const node of mutation.addedNodes) {\n        const nextVideo = this.extractVideoElement(node);\n        if (nextVideo && nextVideo !== this.videoElement) {\n          this.initialize(nextVideo);\n          return;\n        }\n      }\n      for (const node of mutation.removedNodes) {\n        if (node === this.videoElement) {\n          this.videoElement = null;\n          this.handleVideoSourceChange(null);\n          return;\n        }\n        if (node instanceof Element) {\n          const removedVideo = node.querySelector(\"video\");\n          if (removedVideo && removedVideo === this.videoElement) {\n            this.videoElement = null;\n            this.handleVideoSourceChange(null);\n            return;\n          }\n        }\n      }\n    }\n  });\n\n  containerObserver.observe(container, { childList: true, subtree: true });\n  this.addCleanup(() => containerObserver.disconnect());\n};\n\nconst extractVideoElementImpl = function (\n  this: CommentRenderer,\n  node: Node,\n): HTMLVideoElement | null {\n  if (node instanceof HTMLVideoElement) {\n    return node;\n  }\n  if (node instanceof Element) {\n    const candidate = node.querySelector(\"video\");\n    if (candidate instanceof HTMLVideoElement) {\n      return candidate;\n    }\n  }\n  return null;\n};\n\nexport const registerLifecycleVideoMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupVideoEventListeners = setupVideoEventListenersImpl;\n  ctor.prototype.handleVideoMetadataLoaded = handleVideoMetadataLoadedImpl;\n  ctor.prototype.handleVideoStalled = handleVideoStalledImpl;\n  ctor.prototype.handleVideoCanPlay = handleVideoCanPlayImpl;\n  ctor.prototype.handleVideoSourceChange = handleVideoSourceChangeImpl;\n  ctor.prototype.syncVideoState = syncVideoStateImpl;\n  ctor.prototype.resetCommentActivity = resetCommentActivityImpl;\n  ctor.prototype.setupVideoChangeDetection = setupVideoChangeDetectionImpl;\n  ctor.prototype.extractVideoElement = extractVideoElementImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { requestAutoHardReset } from \"@/renderer/auto-hard-reset\";\nimport { toMilliseconds } from \"@/shared/constants\";\n\nconst setupVisibilityHandlingImpl = function (this: CommentRenderer): void {\n  if (\n    typeof document === \"undefined\" ||\n    typeof document.addEventListener !== \"function\" ||\n    typeof document.removeEventListener !== \"function\"\n  ) {\n    return;\n  }\n\n  const enforceVisibilityState = (): void => {\n    const state = document.visibilityState;\n    if (state !== \"visible\") {\n      this.stopAnimation();\n      return;\n    }\n    if (!this._settings.isCommentVisible) {\n      return;\n    }\n    this.handleVisibilityRestore();\n    this.startAnimation();\n  };\n\n  document.addEventListener(\"visibilitychange\", enforceVisibilityState);\n  this.addCleanup(() => document.removeEventListener(\"visibilitychange\", enforceVisibilityState));\n\n  if (document.visibilityState !== \"visible\") {\n    this.stopAnimation();\n  }\n};\n\nconst handleVisibilityRestoreImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  const video = this.videoElement;\n  if (!canvas || !ctx || !video) {\n    return;\n  }\n\n  this.currentTime = toMilliseconds(video.currentTime);\n  this.lastDrawTime = this.timeSource.now();\n  this.isPlaying = !video.paused;\n  this.isStalled = false;\n  this.pendingInitialSync = true;\n  this.resetFinalPhaseState();\n  this.updatePlaybackProgressState();\n  requestAutoHardReset(this, \"visibility-restore\");\n  this.draw();\n};\n\nexport const registerVisibilityMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupVisibilityHandling = setupVisibilityHandlingImpl;\n  ctor.prototype.handleVisibilityRestore = handleVisibilityRestoreImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { requestAutoHardReset } from \"@/renderer/auto-hard-reset\";\nimport { DEFAULT_LANE_COUNT, MIN_FONT_SIZE_PX, MIN_LANE_COUNT } from \"@/shared/constants\";\n\nconst resizeImpl = function (this: CommentRenderer, width?: number, height?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas) {\n    return;\n  }\n\n  const rect = video.getBoundingClientRect();\n  const currentDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const fallbackWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / currentDpr;\n  const fallbackHeight = this.displayHeight > 0 ? this.displayHeight : canvas.height / currentDpr;\n\n  const measuredWidth = width ?? rect.width ?? fallbackWidth;\n  const measuredHeight = height ?? rect.height ?? fallbackHeight;\n\n  if (\n    !Number.isFinite(measuredWidth) ||\n    !Number.isFinite(measuredHeight) ||\n    measuredWidth <= 0 ||\n    measuredHeight <= 0\n  ) {\n    return;\n  }\n\n  const cssWidth = Math.max(1, Math.floor(measuredWidth));\n  const cssHeight = Math.max(1, Math.floor(measuredHeight));\n  const previousDisplayWidth = this.displayWidth > 0 ? this.displayWidth : cssWidth;\n  const previousDisplayHeight = this.displayHeight > 0 ? this.displayHeight : cssHeight;\n  const nextDpr = this._settings.useDprScaling ? this.resolveDevicePixelRatio() : 1;\n  const pixelWidth = Math.max(1, Math.round(cssWidth * nextDpr));\n  const pixelHeight = Math.max(1, Math.round(cssHeight * nextDpr));\n\n  const needsResize =\n    this.displayWidth !== cssWidth ||\n    this.displayHeight !== cssHeight ||\n    Math.abs(this.canvasDpr - nextDpr) > Number.EPSILON ||\n    canvas.width !== pixelWidth ||\n    canvas.height !== pixelHeight;\n\n  if (!needsResize) {\n    return;\n  }\n\n  this.displayWidth = cssWidth;\n  this.displayHeight = cssHeight;\n  this.canvasDpr = nextDpr;\n\n  canvas.width = pixelWidth;\n  canvas.height = pixelHeight;\n  canvas.style.width = `${cssWidth}px`;\n  canvas.style.height = `${cssHeight}px`;\n\n  if (context) {\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    if (this._settings.useDprScaling) {\n      context.scale(nextDpr, nextDpr);\n    }\n  }\n\n  const scaleX = previousDisplayWidth > 0 ? cssWidth / previousDisplayWidth : 1;\n  const scaleY = previousDisplayHeight > 0 ? cssHeight / previousDisplayHeight : 1;\n\n  if (scaleX !== 1 || scaleY !== 1) {\n    this.comments.forEach((comment) => {\n      if (comment.isActive) {\n        comment.x *= scaleX;\n        comment.y *= scaleY;\n        comment.width *= scaleX;\n        comment.fontSize = Math.max(\n          MIN_FONT_SIZE_PX,\n          Math.floor(Math.max(1, comment.fontSize) * scaleY),\n        );\n        comment.height = comment.fontSize;\n        comment.virtualStartX *= scaleX;\n        comment.exitThreshold *= scaleX;\n        comment.baseSpeed *= scaleX;\n        comment.speed *= scaleX;\n        comment.speedPixelsPerMs *= scaleX;\n        comment.bufferWidth *= scaleX;\n        comment.reservationWidth *= scaleX;\n      }\n    });\n  }\n\n  this.calculateLaneMetrics();\n  requestAutoHardReset(this, \"resize\");\n};\n\nconst resolveDevicePixelRatioImpl = function (this: CommentRenderer): number {\n  if (typeof window === \"undefined\") {\n    return 1;\n  }\n  const ratio = Number(window.devicePixelRatio);\n  if (!Number.isFinite(ratio) || ratio <= 0) {\n    return 1;\n  }\n  return ratio;\n};\n\nconst calculateLaneMetricsImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  if (!canvas) {\n    return;\n  }\n\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / Math.max(this.canvasDpr, 1);\n  const baseHeight = Math.max(MIN_FONT_SIZE_PX, Math.floor(effectiveHeight * 0.05));\n  this.laneHeight = baseHeight * 1.2;\n  const availableLanes = Math.floor(effectiveHeight / Math.max(this.laneHeight, 1));\n  if (this._settings.useFixedLaneCount) {\n    const desired = Number.isFinite(this._settings.fixedLaneCount)\n      ? Math.floor(this._settings.fixedLaneCount)\n      : DEFAULT_LANE_COUNT;\n    const clamped = Math.max(MIN_LANE_COUNT, Math.min(availableLanes, desired));\n    this.laneCount = clamped;\n  } else {\n    this.laneCount = Math.max(MIN_LANE_COUNT, availableLanes);\n  }\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n};\n\nconst setupResizeHandlingImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  this.cleanupResizeHandling();\n\n  if (this._settings.useContainerResizeObserver && this.isResizeObserverAvailable) {\n    const target = this.resolveResizeObserverTarget(videoElement);\n    const observer = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { width, height } = entry.contentRect;\n        if (width > 0 && height > 0) {\n          this.resize(width, height);\n        } else {\n          this.resize();\n        }\n      }\n    });\n    observer.observe(target);\n    this.resizeObserver = observer;\n    this.resizeObserverTarget = target;\n  } else if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\") {\n    const onResize = (): void => {\n      this.resize();\n    };\n    window.addEventListener(\"resize\", onResize);\n    this.addCleanup(() => window.removeEventListener(\"resize\", onResize));\n  } else {\n    this.log.debug(\n      \"Resize handling is disabled because neither ResizeObserver nor window APIs are available.\",\n    );\n  }\n};\n\nconst cleanupResizeHandlingImpl = function (this: CommentRenderer): void {\n  if (this.resizeObserver && this.resizeObserverTarget) {\n    this.resizeObserver.unobserve(this.resizeObserverTarget);\n  }\n  this.resizeObserver?.disconnect();\n  this.resizeObserver = null;\n  this.resizeObserverTarget = null;\n};\n\nexport const registerResizeMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.resize = resizeImpl;\n  ctor.prototype.resolveDevicePixelRatio = resolveDevicePixelRatioImpl;\n  ctor.prototype.calculateLaneMetrics = calculateLaneMetricsImpl;\n  ctor.prototype.setupResizeHandling = setupResizeHandlingImpl;\n  ctor.prototype.cleanupResizeHandling = cleanupResizeHandlingImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nconst setupFullscreenHandlingImpl = function (this: CommentRenderer): void {\n  if (\n    typeof document === \"undefined\" ||\n    typeof document.addEventListener !== \"function\" ||\n    typeof document.removeEventListener !== \"function\"\n  ) {\n    return;\n  }\n\n  const onFullscreenChange = (): void => {\n    void this.handleFullscreenChange();\n  };\n\n  const events = [\n    \"fullscreenchange\",\n    \"webkitfullscreenchange\",\n    \"mozfullscreenchange\",\n    \"MSFullscreenChange\",\n  ];\n\n  events.forEach((eventName) => {\n    document.addEventListener(eventName, onFullscreenChange);\n    this.addCleanup(() => document.removeEventListener(eventName, onFullscreenChange));\n  });\n\n  void this.handleFullscreenChange();\n};\n\nconst resolveResizeObserverTargetImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): Element {\n  const fullscreenContainer = this.resolveFullscreenContainer(videoElement);\n  if (fullscreenContainer) {\n    return fullscreenContainer;\n  }\n  return videoElement.parentElement ?? videoElement;\n};\n\nconst handleFullscreenChangeImpl = async function (this: CommentRenderer): Promise<void> {\n  const canvas = this.canvas;\n  const video = this.videoElement;\n  if (!canvas || !video) {\n    return;\n  }\n\n  const baseContainer = this.containerElement ?? video.parentElement ?? null;\n  const fullscreenElement = this.getFullscreenElement();\n  const nextContainer = this.resolveActiveOverlayContainer(video, baseContainer, fullscreenElement);\n\n  if (!(nextContainer instanceof HTMLElement)) {\n    return;\n  }\n\n  if (canvas.parentElement !== nextContainer) {\n    this.ensureContainerPositioning(nextContainer);\n    nextContainer.appendChild(canvas);\n  } else {\n    this.ensureContainerPositioning(nextContainer);\n  }\n\n  const fullscreenContainer =\n    fullscreenElement instanceof HTMLElement && fullscreenElement.contains(video)\n      ? fullscreenElement\n      : null;\n  const isFullscreenNow = fullscreenContainer !== null;\n  if (this.fullscreenActive !== isFullscreenNow) {\n    this.fullscreenActive = isFullscreenNow;\n    this.setupResizeHandling(video);\n  }\n\n  canvas.style.position = \"absolute\";\n  canvas.style.top = \"0\";\n  canvas.style.left = \"0\";\n\n  this.resize();\n};\n\nconst resolveFullscreenContainerImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): HTMLElement | null {\n  const fullscreenElement = this.getFullscreenElement();\n  if (!(fullscreenElement instanceof HTMLElement)) {\n    return null;\n  }\n  if (fullscreenElement === videoElement) {\n    return fullscreenElement;\n  }\n  if (fullscreenElement.contains(videoElement)) {\n    return fullscreenElement;\n  }\n  return null;\n};\n\nconst resolveActiveOverlayContainerImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n  baseContainer: HTMLElement | null,\n  fullscreenElement: Element | null,\n): HTMLElement | null {\n  if (fullscreenElement instanceof HTMLElement && fullscreenElement.contains(videoElement)) {\n    if (fullscreenElement instanceof HTMLVideoElement) {\n      if (baseContainer instanceof HTMLElement) {\n        return baseContainer;\n      }\n      return fullscreenElement;\n    }\n    return fullscreenElement;\n  }\n  return baseContainer ?? null;\n};\n\nconst getFullscreenElementImpl = function (this: CommentRenderer): Element | null {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const doc = document as Document & {\n    webkitFullscreenElement?: Element | null;\n    msFullscreenElement?: Element | null;\n    mozFullScreenElement?: Element | null;\n  };\n  return (\n    document.fullscreenElement ??\n    doc.webkitFullscreenElement ??\n    doc.mozFullScreenElement ??\n    doc.msFullscreenElement ??\n    null\n  );\n};\n\nexport const registerFullscreenMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupFullscreenHandling = setupFullscreenHandlingImpl;\n  ctor.prototype.resolveResizeObserverTarget = resolveResizeObserverTargetImpl;\n  ctor.prototype.handleFullscreenChange = handleFullscreenChangeImpl;\n  ctor.prototype.resolveFullscreenContainer = resolveFullscreenContainerImpl;\n  ctor.prototype.resolveActiveOverlayContainer = resolveActiveOverlayContainerImpl;\n  ctor.prototype.getFullscreenElement = getFullscreenElementImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nconst addCleanupImpl = function (this: CommentRenderer, task: () => void): void {\n  this.cleanupTasks.push(task);\n};\n\nconst runCleanupTasksImpl = function (this: CommentRenderer): void {\n  while (this.cleanupTasks.length > 0) {\n    const task = this.cleanupTasks.pop();\n    try {\n      task?.();\n    } catch (error) {\n      this.log.error(\"CommentRenderer.cleanupTask\", error as Error);\n    }\n  }\n};\n\nexport const registerCleanupMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.addCleanup = addCleanupImpl;\n  ctor.prototype.runCleanupTasks = runCleanupTasksImpl;\n};\n","import { cloneDefaultSettings } from \"@/config/default-settings\";\nimport type {\n  RendererSettings,\n  CommentRendererEventHooks,\n  CommentDependencies,\n  CommentPrepareOptions,\n  TimeSource,\n} from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport { createDefaultTimeSource } from \"@/comment/time-source\";\nimport { createLogger } from \"@/shared/logger\";\nimport type { Logger } from \"@/shared/types\";\nimport { configureDebugLogging } from \"@/shared/debug\";\nimport {\n  createBrowserCanvasFactory,\n  createDefaultAnimationFrameProvider,\n  isRendererSettings,\n  normalizeSettings,\n} from \"@/shared/settings\";\nexport { createDefaultAnimationFrameProvider } from \"@/shared/settings\";\nimport type {\n  AnimationFrameProvider,\n  CommentRendererConfig,\n  CommentRendererInitializeOptions,\n  LaneReservation,\n  StaticLaneReservation,\n  VideoFrameCallbackMetadataLike,\n} from \"@/shared/types\";\nimport {\n  AUTO_HARD_RESET_DEDUP_WINDOW_MS,\n  AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS,\n  DEFAULT_LANE_COUNT,\n} from \"@/shared/constants\";\nimport { rebuildNgMatchersImpl, registerCommentCollectionMethods } from \"@/renderer/comments\";\nimport { registerFinalPhaseMethods } from \"@/renderer/final-phase\";\nimport { registerPlaybackHelpers } from \"@/renderer/playback\";\nimport { registerActivationMethods } from \"@/renderer/activation\";\nimport { registerLanePruneMethods } from \"@/renderer/lanes-prune\";\nimport { registerLaneStaticMethods } from \"@/renderer/lanes-static\";\nimport { registerLaneActivationMethods } from \"@/renderer/lanes-activation\";\nimport { registerLaneReservationMethods } from \"@/renderer/lanes-reservations\";\nimport { registerRenderMethods } from \"@/renderer/render\";\nimport { registerTimingMethods } from \"@/renderer/timing\";\nimport { registerLifecycleCoreMethods } from \"@/renderer/lifecycle-core\";\nimport { registerLifecycleVideoMethods } from \"@/renderer/lifecycle-video-events\";\nimport { registerVisibilityMethods } from \"@/renderer/visibility\";\nimport { registerResizeMethods } from \"@/renderer/resize\";\nimport { registerFullscreenMethods } from \"@/renderer/fullscreen\";\nimport { registerCleanupMethods } from \"@/renderer/cleanup\";\n\nexport type { CommentRendererConfig, CommentRendererInitializeOptions, AnimationFrameProvider };\n\nexport class CommentRenderer {\n  public _settings: RendererSettings;\n  public readonly comments: Comment[] = [];\n  public readonly activeComments = new Set<Comment>();\n  public readonly reservedLanes = new Map<number, LaneReservation[]>();\n  public readonly topStaticLaneReservations: StaticLaneReservation[] = [];\n  public readonly bottomStaticLaneReservations: StaticLaneReservation[] = [];\n  public readonly log: Logger;\n  public readonly timeSource: TimeSource;\n  public readonly animationFrameProvider: AnimationFrameProvider;\n  public readonly createCanvasElement: () => HTMLCanvasElement;\n  public readonly commentDependencies: CommentDependencies;\n  public settingsVersion = 0;\n  public normalizedNgWords: string[] = [];\n  public compiledNgRegexps: RegExp[] = [];\n  public canvas: HTMLCanvasElement | null = null;\n  public ctx: CanvasRenderingContext2D | null = null;\n  public videoElement: HTMLVideoElement | null = null;\n  public containerElement: HTMLElement | null = null;\n  public fullscreenActive = false;\n  public laneCount = DEFAULT_LANE_COUNT;\n  public laneHeight = 0;\n  public displayWidth = 0;\n  public displayHeight = 0;\n  public canvasDpr = 1;\n  public currentTime = 0;\n  public duration = 0;\n  public playbackRate = 1;\n  public isPlaying = true;\n  public isStalled = false;\n  public lastDrawTime = 0;\n  public finalPhaseActive = false;\n  public finalPhaseStartTime: number | null = null;\n  public finalPhaseScheduleDirty = false;\n  public playbackHasBegun = false;\n  public skipDrawingForCurrentFrame = false;\n  public pendingInitialSync = false;\n  public readonly finalPhaseVposOverrides = new Map<Comment, number>();\n  public frameId: ReturnType<typeof setTimeout> | null = null;\n  public videoFrameHandle: number | null = null;\n  public resizeObserver: ResizeObserver | null = null;\n  public resizeObserverTarget: Element | null = null;\n  public readonly isResizeObserverAvailable = typeof ResizeObserver !== \"undefined\";\n  public readonly cleanupTasks: Array<() => void> = [];\n  public commentSequence = 0;\n  public epochId = 0;\n  public readonly eventHooks: CommentRendererEventHooks;\n  public lastSnapshotEmitTime = 0;\n  public readonly snapshotEmitThrottleMs = 1000;\n  public lastPlayResumeTime = 0;\n  public readonly playResumeSeekIgnoreDurationMs = 500;\n  public lastVideoSource: string | null = null;\n  public lastHardResetAt = 0;\n  public readonly autoHardResetDedupWindowMs = AUTO_HARD_RESET_DEDUP_WINDOW_MS;\n  public readonly initialPlaybackAutoResetDelayMs = AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS;\n  public initialPlaybackAutoResetTimer: ReturnType<typeof setTimeout> | null = null;\n  public initialPlaybackAutoResetTriggered = false;\n\n  declare public initialize: (options: HTMLVideoElement | CommentRendererInitializeOptions) => void;\n  declare public destroy: () => void;\n  declare public destroyCanvasOnly: () => void;\n  declare public resolveContainer: (\n    explicit: HTMLElement | null | undefined,\n    video: HTMLVideoElement,\n  ) => HTMLElement;\n  declare public ensureContainerPositioning: (container: HTMLElement) => void;\n  declare public resize: (width?: number, height?: number) => void;\n  declare public resolveDevicePixelRatio: () => number;\n  declare public calculateLaneMetrics: () => void;\n  declare public setupResizeHandling: (videoElement: HTMLVideoElement) => void;\n  declare public cleanupResizeHandling: () => void;\n  declare public setupVideoEventListeners: (videoElement: HTMLVideoElement) => void;\n  declare public handleVideoMetadataLoaded: (videoElement: HTMLVideoElement) => void;\n  declare public handleVideoStalled: () => void;\n  declare public handleVideoCanPlay: () => void;\n  declare public handleVideoSourceChange: (videoElement?: HTMLVideoElement | null) => void;\n  declare public syncVideoState: (videoElement: HTMLVideoElement) => void;\n  declare public resetCommentActivity: () => void;\n  declare public setupVideoChangeDetection: (\n    video: HTMLVideoElement,\n    container: HTMLElement,\n  ) => void;\n  declare public extractVideoElement: (node: Node) => HTMLVideoElement | null;\n  declare public setupVisibilityHandling: () => void;\n  declare public handleVisibilityRestore: () => void;\n  declare public setupFullscreenHandling: () => void;\n  declare public resolveResizeObserverTarget: (videoElement: HTMLVideoElement) => Element;\n  declare public handleFullscreenChange: () => Promise<void>;\n  declare public resolveFullscreenContainer: (videoElement: HTMLVideoElement) => HTMLElement | null;\n  declare public resolveActiveOverlayContainer: (\n    videoElement: HTMLVideoElement,\n    baseContainer: HTMLElement | null,\n    fullscreenElement: Element | null,\n  ) => HTMLElement | null;\n  declare public getFullscreenElement: () => Element | null;\n  declare public addCleanup: (task: () => void) => void;\n  declare public runCleanupTasks: () => void;\n  public rebuildNgMatchers(): void {\n    rebuildNgMatchersImpl.call(this);\n  }\n  declare public isNGComment: (text: string) => boolean;\n  declare public addComments: (\n    entries: ReadonlyArray<{ text: string; vposMs: number; commands?: string[] }>,\n  ) => Comment[];\n  declare public addComment: (text: string, vposMs: number, commands?: string[]) => Comment | null;\n  declare public clearComments: () => void;\n  declare public resetState: () => void;\n  declare public hardReset: () => void;\n  declare public resetFinalPhaseState: () => void;\n  declare public incrementEpoch: (\n    reason: \"source-change\" | \"metadata-loaded\" | \"manual-reset\",\n  ) => void;\n  declare public emitStateSnapshot: (label: string) => void;\n  declare public getEffectiveCommentVpos: (comment: Comment) => number;\n  declare public getFinalPhaseDisplayDuration: (comment: Comment) => number;\n  declare public resolveFinalPhaseVpos: (comment: Comment) => number;\n  declare public recomputeFinalPhaseTimeline: () => void;\n  declare public shouldSuppressRendering: () => boolean;\n  declare public updatePlaybackProgressState: () => void;\n  declare public updateComments: (frameTimeMs?: number) => void;\n  declare public buildPrepareOptions: (visibleWidth: number) => CommentPrepareOptions;\n  declare public findAvailableLane: (comment: Comment) => number;\n  declare public findFirstValidReservationIndex: (\n    reservations: LaneReservation[],\n    cutoffTime: number,\n  ) => number;\n  declare public pruneLaneReservations: (currentTime: number) => void;\n  declare public pruneStaticLaneReservations: (currentTime: number) => void;\n  declare public findCommentIndexAtOrAfter: (targetVposMs: number) => number;\n  declare public getCommentsInTimeWindow: (centerTimeMs: number, windowMs: number) => Comment[];\n  declare public getStaticReservations: (position: \"ue\" | \"shita\") => StaticLaneReservation[];\n  declare public getStaticLaneDepth: (position: \"ue\" | \"shita\") => number;\n  declare public getStaticLaneLimit: (position: \"ue\" | \"shita\") => number;\n  declare public getGlobalLaneIndexForBottom: (localIndex: number) => number;\n  declare public resolveStaticCommentOffset: (\n    position: \"ue\" | \"shita\",\n    lane: number,\n    displayHeight: number,\n    comment: Comment,\n  ) => number;\n  declare public getStaticReservedLaneSet: () => Set<number>;\n  declare public shouldActivateCommentAtTime: (\n    comment: Comment,\n    timeMs: number,\n    preview?: string,\n  ) => boolean;\n  declare public activateComment: (\n    comment: Comment,\n    context: CanvasRenderingContext2D,\n    displayWidth: number,\n    displayHeight: number,\n    options: CommentPrepareOptions,\n    referenceTime: number,\n  ) => void;\n  declare public assignStaticLane: (\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    displayHeight: number,\n    currentTime: number,\n  ) => number;\n  declare public reserveStaticLane: (\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    lane: number,\n    releaseTime: number,\n  ) => void;\n  declare public releaseStaticLane: (position: \"ue\" | \"shita\", lane: number) => void;\n  declare public getLanePriorityOrder: (currentTime: number) => number[];\n  declare public getLaneNextAvailableTime: (lane: number, currentTime: number) => number;\n  declare public createLaneReservation: (\n    comment: Comment,\n    referenceTime: number,\n  ) => LaneReservation;\n  declare public isLaneAvailable: (\n    lane: number,\n    candidate: LaneReservation,\n    currentTime: number,\n  ) => boolean;\n  declare public storeLaneReservation: (lane: number, reservation: LaneReservation) => void;\n  declare public areReservationsConflicting: (a: LaneReservation, b: LaneReservation) => boolean;\n  declare public computeForwardGap: (\n    from: LaneReservation,\n    to: LaneReservation,\n    time: number,\n  ) => number;\n  declare public getBufferedEdges: (\n    reservation: LaneReservation,\n    time: number,\n  ) => { left: number; right: number };\n  declare public solveLeftRightEqualityTime: (\n    left: LaneReservation,\n    right: LaneReservation,\n  ) => number | null;\n  declare public draw: () => void;\n  declare public performInitialSync: (frameTimeMs?: number) => void;\n  declare public processFrame: (frameTimeMs?: number) => void;\n  declare public handleAnimationFrame: () => void;\n  declare public handleVideoFrame: (\n    now: DOMHighResTimeStamp,\n    metadata: VideoFrameCallbackMetadataLike,\n  ) => void;\n  declare public shouldUseVideoFrameCallback: () => boolean;\n  declare public scheduleNextFrame: () => void;\n  declare public cancelAnimationFrameRequest: () => void;\n  declare public cancelVideoFrameCallback: () => void;\n  declare public startAnimation: () => void;\n  declare public stopAnimation: () => void;\n  declare public onSeek: () => void;\n\n  constructor(settings: RendererSettings | null, config?: CommentRendererConfig);\n  constructor(config?: CommentRendererConfig);\n  constructor(\n    settingsOrConfig: RendererSettings | CommentRendererConfig | null = null,\n    maybeConfig: CommentRendererConfig | undefined = undefined,\n  ) {\n    let baseSettings: RendererSettings;\n    let config: CommentRendererConfig;\n\n    if (isRendererSettings(settingsOrConfig)) {\n      baseSettings = normalizeSettings({ ...(settingsOrConfig as RendererSettings) });\n      config = maybeConfig ?? {};\n    } else {\n      const configCandidate = settingsOrConfig ?? maybeConfig ?? {};\n      config =\n        typeof configCandidate === \"object\" ? (configCandidate as CommentRendererConfig) : {};\n      baseSettings = normalizeSettings(cloneDefaultSettings());\n    }\n\n    this._settings = normalizeSettings(baseSettings);\n    this.timeSource = config.timeSource ?? createDefaultTimeSource();\n    this.animationFrameProvider =\n      config.animationFrameProvider ?? createDefaultAnimationFrameProvider(this.timeSource);\n    this.createCanvasElement = config.createCanvasElement ?? createBrowserCanvasFactory();\n    this.commentDependencies = {\n      timeSource: this.timeSource,\n      settingsVersion: this.settingsVersion,\n    };\n    this.log = createLogger(config.loggerNamespace ?? \"CommentRenderer\");\n    this.eventHooks = config.eventHooks ?? {};\n\n    this.handleAnimationFrame = this.handleAnimationFrame.bind(this);\n    this.handleVideoFrame = this.handleVideoFrame.bind(this);\n\n    this.rebuildNgMatchers();\n\n    if (config.debug) {\n      configureDebugLogging(config.debug);\n    }\n  }\n\n  get settings(): RendererSettings {\n    return this._settings;\n  }\n\n  set settings(value: RendererSettings) {\n    this._settings = normalizeSettings(value);\n    this.settingsVersion += 1;\n    this.commentDependencies.settingsVersion = this.settingsVersion;\n    this.rebuildNgMatchers();\n  }\n\n  getVideoElement(): HTMLVideoElement | null {\n    return this.videoElement;\n  }\n\n  getCurrentVideoSource(): string | null {\n    const video = this.videoElement;\n    if (!video) {\n      return null;\n    }\n    if (typeof video.currentSrc === \"string\" && video.currentSrc.length > 0) {\n      return video.currentSrc;\n    }\n    const attribute = video.getAttribute(\"src\");\n    if (attribute && attribute.length > 0) {\n      return attribute;\n    }\n    const sourceElement = video.querySelector(\"source[src]\") as HTMLSourceElement | null;\n    if (sourceElement && typeof sourceElement.src === \"string\") {\n      return sourceElement.src;\n    }\n    return null;\n  }\n\n  getCommentsSnapshot(): Comment[] {\n    return [...this.comments];\n  }\n}\n\nregisterCommentCollectionMethods(CommentRenderer);\nregisterFinalPhaseMethods(CommentRenderer);\nregisterPlaybackHelpers(CommentRenderer);\nregisterActivationMethods(CommentRenderer);\nregisterLanePruneMethods(CommentRenderer);\nregisterLaneStaticMethods(CommentRenderer);\nregisterLaneActivationMethods(CommentRenderer);\nregisterLaneReservationMethods(CommentRenderer);\nregisterRenderMethods(CommentRenderer);\nregisterTimingMethods(CommentRenderer);\nregisterLifecycleCoreMethods(CommentRenderer);\nregisterLifecycleVideoMethods(CommentRenderer);\nregisterVisibilityMethods(CommentRenderer);\nregisterResizeMethods(CommentRenderer);\nregisterFullscreenMethods(CommentRenderer);\nregisterCleanupMethods(CommentRenderer);\n"],"names":["COMMENT_SIZE_SCALE","FONT_FAMILY_MAP","COLOR_COMMAND_MAP","HEX_COLOR_REGEX","COMMAND_PREFIX_STRIP_REGEX","COMMAND_SUFFIX_STRIP_REGEX","normalizeCommandToken","value","trimmed","normalizeHexColor","command","parseNumericCommandValue","withoutPx","parsed","parseLineHeightValue","numeric","clampLetterSpacing","clampLineHeight","isLayoutCommand","isSizeCommand","isFontCommand","isColorCommand","parseCommentCommands","commands","context","layout","size","font","colorOverride","opacityMultiplier","opacityOverride","isInvisible","letterSpacing","lineHeight","rawCommand","normalizedToken","normalized","lower","separatorIndex","numericValue","clampedOpacityMultiplier","resolvedColor","resolvedOpacityOverride","HEX_COLOR_PATTERN","expandHex","fragment","parseHexComponent","component","clampOpacity","resolveFillStyleWithOpacity","color","opacity","match","body","red","green","blue","alpha","combinedAlpha","createPerformanceTimeSource","createDefaultTimeSource","toMilliseconds","seconds","sanitizeVposMs","MAX_VISIBLE_DURATION_MS","MIN_VISIBLE_DURATION_MS","MAX_COMMENT_WIDTH_RATIO","COLLISION_BUFFER_RATIO","BASE_COLLISION_BUFFER_PX","ENTRY_BUFFER_PX","RESERVATION_TIME_MARGIN_MS","FINAL_PHASE_THRESHOLD_MS","FINAL_PHASE_MIN_GAP_MS","FINAL_PHASE_MAX_GAP_MS","FINAL_PHASE_ORDER_EPSILON_MS","FINAL_PHASE_MIN_WINDOW_MS","STATIC_VISIBLE_DURATION_MS","ACTIVE_WINDOW_MS","VIRTUAL_CANVAS_EXTENSION_PX","MIN_LANE_COUNT","DEFAULT_LANE_COUNT","MIN_FONT_SIZE_PX","EDGE_EPSILON","SEEK_DIRECTION_EPSILON_MS","STATIC_COMMENT_EDGE_PADDING_PX","STATIC_COMMENT_STACKING_PADDING_PX","STATIC_COMMENT_SIDE_MARGIN_PX","MIN_STATIC_FONT_SIZE_PX","AUTO_HARD_RESET_DEDUP_WINDOW_MS","AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS","LEVEL_PRIORITY","fallbackEmitter","level","namespace","args","consoleArgs","createLogger","options","emitter","threshold","emit","logLevel","messages","commentLogger","textMeasurementCaches","getTextMeasurementCache","ctx","cache","measureTextWidth","text","cacheKey","cached","width","ensureLines","rawLines","clampFontSize","updateTextMetrics","comment","maxLineWidth","effectiveLetterSpacing","line","baseWidth","extraSpacing","totalWidth","computedLineHeightPx","additionalHeight","prepareComment","visibleWidth","canvasHeight","safeVisibleWidth","baseFontSize","scaledFontSize","isStaticTopOrBottom","maxStaticWidth","minimumFontSize","shrinkFactor","initialShrink","iteration","currentShrink","proposedSize","margin","centeredX","maxStart","clampedX","maxReservationWidth","bufferFromWidth","entryBuffer","direction","startLeft","exitLeft","trailingBoundary","trailingEdgeAtStart","widthRatio","hasFixedDuration","visibleDurationMs","clampedRatio","adjustedDuration","visibleDistance","safeVisibleDuration","pixelsPerMs","pixelsPerFrame","travelDistance","preCollisionDistance","safePixelsPerMs","reservationBase","error","logger","DEFAULT_MAX_LOGS_PER_CATEGORY","state","categoryCounters","normalizeLimit","limit","rounded","configureDebugLogging","resetDebugCounters","isDebugLoggingEnabled","shouldEmitLog","category","currentCount","debugLog","payload","formatCommentPreview","maxLength","dumpRendererState","label","snapshot","logEpochChange","previousEpochId","newEpochId","reason","cacheStats","reportCacheStats","now","total","hitRate","avgCharsPerComment","totalOutlineCalls","totalFillCalls","isOffscreenCanvasSupported","getShadowParams","intensity","fontSize","baseOpacity","blurRatio","alphaMultiplier","blur","createSegmentDrawer","targetCtx","measurementCtx","statsTarget","baseDrawX","baselineY","mode","offsetX","effectiveDrawX","recordDraw","cursorX","index","char","advance","generateTextureCacheKey","createTextureCanvas","hasLetterSpacing","isMultiLine","padding","textureWidth","textureHeight","offscreen","offscreenCtx","effectiveOpacity","drawX","linesToRender","lineAdvance","baselineStart","drawSegment","resolvedFillStyle","shadowParams","baseline","drawWithFallback","interpolatedX","drawComment","currentCacheKey","cachedTexture","created","texture","resolveScrollDirection","input","getDirectionSign","Comment","vposMs","settings","dependencies","parsedCommands","playbackRate","isPaused","currentTime","deltaTime","settingsVersion","defaultColor","candidate","defaultOpacity","scaled","atTimeMs","currentTimeMs","resolved","NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS","BASE_SETTINGS","DEFAULT_RENDERER_SETTINGS","cloneDefaultSettings","COMMENT_OVERLAY_VERSION","calculateStaticCommentVerticalPadding","_fontSize","laneIndex","normalizeSettings","rawDuration","normalizedDuration","createDefaultAnimationFrameProvider","timeSource","callback","handle","createBrowserCanvasFactory","isRendererSettings","addCommentsImpl","entries","addedComments","entry","preview","normalizedVposMs","a","b","vposMsDiff","addCommentImpl","clearCommentsImpl","effectiveDpr","height","resetStateImpl","rebuildNgMatchersImpl","ngWords","word","sourcePatterns","isNgCommentImpl","regexp","registerCommentCollectionMethods","ctor","hardResetImpl","canvas","effectiveWidth","effectiveHeight","resetFinalPhaseStateImpl","incrementEpochImpl","info","emitStateSnapshotImpl","getEffectiveCommentVposImpl","getFinalPhaseDisplayDurationImpl","durations","resolveFinalPhaseVposImpl","override","fallback","recomputeFinalPhaseTimelineImpl","windowStart","durationMs","windowEnd","candidates","diff","baseGap","boundedGap","gap","nextStart","durationNeeded","availableLatestStart","assigned","epsilon","spacing","registerFinalPhaseMethods","shouldSuppressRenderingImpl","updatePlaybackProgressStateImpl","registerPlaybackHelpers","updateCommentsImpl","frameTimeMs","video","referenceTime","prepareOptions","isNearEnd","effectiveVpos","isPastWindow","isFutureWindow","activeWindowComments","debugActive","staticPosition","buildPrepareOptionsImpl","overrideDuration","maxVisibleDurationMs","minVisibleDurationMs","findAvailableLaneImpl","laneCandidates","newReservation","lane","fallbackLane","registerActivationMethods","findFirstValidReservationIndexImpl","reservations","cutoffTime","left","right","mid","reservation","pruneLaneReservationsImpl","firstValidIndex","pruneStaticLaneReservationsImpl","filterValid","topFiltered","bottomFiltered","registerLanePruneMethods","findCommentIndexAtOrAfterImpl","targetVposMs","getCommentsInTimeWindowImpl","centerTimeMs","windowMs","startTime","endTime","startIndex","result","i","getStaticReservationsImpl","position","getStaticLaneDepthImpl","getStaticLaneLimitImpl","otherPosition","otherDepth","available","getGlobalLaneIndexForBottomImpl","localIndex","resolveStaticCommentOffsetImpl","displayHeight","commentHeight","edgePadding","stackPadding","cumulativeY","laneSortedReservations","r","reservedHeight","maxY","adjustedY","getStaticReservedLaneSetImpl","reserved","registerLaneStaticMethods","shouldActivateCommentAtTimeImpl","timeMs","activateCommentImpl","displayWidth","elapsedMs","displacement","videoDuration","finalPhaseWindowEnd","totalTravelDistance","projectedTravelMs","remainingTime","allowedTravel","startX","laneHeight","laneY","verticalOffset","displayEnd","assignStaticLaneImpl","laneCount","laneIndices","_","yOffset","yStart","yEnd","earliestRelease","reserveStaticLaneImpl","releaseTime","releaseStaticLaneImpl","registerLaneActivationMethods","getLanePriorityOrderImpl","sorted","nextA","nextB","staticReserved","preferred","blocked","getLaneNextAvailableTimeImpl","validIndex","createLaneReservationImpl","speed","effectiveStart","baseStartTime","totalEndTime","isLaneAvailableImpl","storeLaneReservationImpl","updated","areReservationsConflictingImpl","overlapStart","overlapEnd","evaluationTimes","forwardIntersection","backwardIntersection","time","forwardGap","backwardGap","computeForwardGapImpl","from","to","fromEdges","toEdges","getBufferedEdgesImpl","elapsed","rawLeft","solveLeftRightEqualityTimeImpl","leftSign","rightSign","denominator","registerLaneReservationMethods","drawImpl","activeComments","aVpos","bVpos","performInitialSyncImpl","absoluteTime","registerRenderMethods","processFrameImpl","handleAnimationFrameImpl","pendingId","handleVideoFrameImpl","_now","metadata","mediaTime","shouldUseVideoFrameCallbackImpl","scheduleNextFrameImpl","request","cancelAnimationFrameRequestImpl","cancelVideoFrameCallbackImpl","startAnimationImpl","stopAnimationImpl","onSeekImpl","nextTime","timeDelta","isSignificantSeek","registerTimingMethods","shouldAutoHardReset","renderer","requestAutoHardReset","scheduleInitialPlaybackAutoReset","resetInitialPlaybackAutoResetState","resolveContainerImpl","explicit","ensureContainerPositioningImpl","container","initializeImpl","containerCandidate","parent","destroyImpl","destroyCanvasOnlyImpl","registerLifecycleCoreMethods","setupVideoEventListenersImpl","videoElement","onPlay","wasPlaying","onPause","onSeeking","onSeeked","onRateChange","onLoadedMetadata","onDurationChange","onEmptied","onWaiting","onCanPlay","onPlaying","handleVideoMetadataLoadedImpl","handleVideoStalledImpl","handleVideoCanPlayImpl","handleVideoSourceChangeImpl","target","currentSource","syncVideoStateImpl","resetCommentActivityImpl","setupVideoChangeDetectionImpl","videoObserver","mutations","mutation","targetNode","previous","current","node","containerObserver","nextVideo","removedVideo","extractVideoElementImpl","registerLifecycleVideoMethods","setupVisibilityHandlingImpl","enforceVisibilityState","handleVisibilityRestoreImpl","registerVisibilityMethods","resizeImpl","rect","currentDpr","fallbackWidth","fallbackHeight","measuredWidth","measuredHeight","cssWidth","cssHeight","previousDisplayWidth","previousDisplayHeight","nextDpr","pixelWidth","pixelHeight","scaleX","scaleY","resolveDevicePixelRatioImpl","ratio","calculateLaneMetricsImpl","baseHeight","availableLanes","desired","clamped","setupResizeHandlingImpl","observer","onResize","cleanupResizeHandlingImpl","registerResizeMethods","setupFullscreenHandlingImpl","onFullscreenChange","eventName","resolveResizeObserverTargetImpl","fullscreenContainer","handleFullscreenChangeImpl","baseContainer","fullscreenElement","nextContainer","isFullscreenNow","resolveFullscreenContainerImpl","resolveActiveOverlayContainerImpl","getFullscreenElementImpl","doc","registerFullscreenMethods","addCleanupImpl","task","runCleanupTasksImpl","registerCleanupMethods","CommentRenderer","settingsOrConfig","maybeConfig","baseSettings","config","configCandidate","attribute","sourceElement"],"mappings":"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"}