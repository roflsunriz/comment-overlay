{"version":3,"file":"comment-overlay.cjs.js","sources":["../src/comment/comment-commands.ts","../src/comment/color.ts","../src/comment/time-source.ts","../src/shared/constants.ts","../src/shared/logger.ts","../src/comment/logger.ts","../src/comment/text-measure.ts","../src/comment/prepare.ts","../src/shared/debug.ts","../src/comment/render.ts","../src/comment/direction.ts","../src/comment/comment.ts","../src/config/default-settings.ts","../src/shared/settings.ts","../src/renderer/comments.ts","../src/renderer/final-phase.ts","../src/renderer/playback.ts","../src/renderer/activation.ts","../src/renderer/lanes-prune.ts","../src/renderer/lanes-static.ts","../src/renderer/lanes-activation.ts","../src/renderer/lanes-reservations.ts","../src/renderer/render.ts","../src/renderer/timing.ts","../src/renderer/auto-hard-reset.ts","../src/renderer/lifecycle-core.ts","../src/renderer/lifecycle-video-events.ts","../src/renderer/visibility.ts","../src/renderer/resize.ts","../src/renderer/fullscreen.ts","../src/renderer/cleanup.ts","../src/renderer/comment-renderer.ts"],"sourcesContent":["import {\n  type CommentColorCommand,\n  type CommentCommandParseContext,\n  type CommentCommandParseResult,\n  type CommentFontCommand,\n  type CommentHexColorCommand,\n  type CommentLayoutCommand,\n  type CommentSizeCommand,\n} from \"@/shared/types\";\n\nconst COMMENT_SIZE_SCALE: Record<CommentSizeCommand, number> = {\n  small: 0.8,\n  medium: 1,\n  big: 1.4,\n};\n\nconst FONT_FAMILY_MAP: Record<CommentFontCommand, string> = {\n  defont:\n    '\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Hiragino Kaku Gothic Pro\",\"Yu Gothic UI\",\"Yu Gothic\",\"Meiryo\",\"Segoe UI\",\"Osaka\",\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"IPAPGothic\",\"TakaoPGothic\",\"Roboto\",\"Helvetica Neue\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  gothic:\n    '\"Noto Sans CJK JP\",\"Noto Sans JP\",\"Source Han Sans JP\",\"Yu Gothic\",\"Yu Gothic Medium\",\"Meiryo\",\"MS PGothic\",\"Hiragino Kaku Gothic ProN\",\"Segoe UI\",\"Helvetica\",\"Arial\",\"sans-serif\"',\n  mincho:\n    '\"MS PMincho\",\"MS Mincho\",\"Hiragino Mincho ProN\",\"Hiragino Mincho Pro\",\"Yu Mincho\",\"Noto Serif CJK JP\",\"Noto Serif JP\",\"Source Han Serif JP\",\"Times New Roman\",\"serif\"',\n};\n\nconst COLOR_COMMAND_MAP: Record<CommentColorCommand, string> = {\n  white: \"#FFFFFC\",\n  red: \"#FF8888\",\n  pink: \"#FFA5CC\",\n  orange: \"#FFBA66\",\n  yellow: \"#FFFFAA\",\n  green: \"#88FF88\",\n  cyan: \"#88FFFF\",\n  blue: \"#8899FF\",\n  purple: \"#D9A5FF\",\n  black: \"#444444\",\n  white2: \"#CC9\",\n  red2: \"#C03\",\n  pink2: \"#F3C\",\n  orange2: \"#F60\",\n  yellow2: \"#990\",\n  green2: \"#0C6\",\n  cyan2: \"#0CC\",\n  blue2: \"#39F\",\n  purple2: \"#63C\",\n  black2: \"#666\",\n};\n\nconst HEX_COLOR_REGEX = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;\n\nconst COMMAND_PREFIX_STRIP_REGEX = /^[,.:;]+/;\nconst COMMAND_SUFFIX_STRIP_REGEX = /[,.:;]+$/;\n\nconst normalizeCommandToken = (value: string): string => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return \"\";\n  }\n  if (HEX_COLOR_REGEX.test(trimmed)) {\n    return trimmed;\n  }\n  const withoutPrefix = trimmed.replace(COMMAND_PREFIX_STRIP_REGEX, \"\");\n  const withoutSuffix = withoutPrefix.replace(COMMAND_SUFFIX_STRIP_REGEX, \"\");\n  return withoutSuffix;\n};\n\nconst normalizeHexColor = (command: CommentHexColorCommand): string | null => {\n  if (!HEX_COLOR_REGEX.test(command)) {\n    return null;\n  }\n  return command.toUpperCase();\n};\n\nconst parseNumericCommandValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  const withoutPx = trimmed.toLowerCase().endsWith(\"px\") ? trimmed.slice(0, -2) : trimmed;\n  const parsed = Number.parseFloat(withoutPx);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst parseLineHeightValue = (value: string): number | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  if (trimmed.endsWith(\"%\")) {\n    const numeric = Number.parseFloat(trimmed.slice(0, -1));\n    if (!Number.isFinite(numeric)) {\n      return null;\n    }\n    return numeric / 100;\n  }\n  return parseNumericCommandValue(trimmed);\n};\n\nconst clampLetterSpacing = (value: number): number => {\n  const maxSpacing = 100;\n  const minSpacing = -100;\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  return Math.min(maxSpacing, Math.max(minSpacing, value));\n};\n\nconst clampLineHeight = (value: number): number => {\n  const minHeight = 0.25;\n  const maxHeight = 5;\n  if (!Number.isFinite(value) || value === 0) {\n    return 1;\n  }\n  return Math.min(maxHeight, Math.max(minHeight, value));\n};\n\nconst isLayoutCommand = (command: string): command is CommentLayoutCommand =>\n  command === \"naka\" || command === \"ue\" || command === \"shita\";\n\nconst isSizeCommand = (command: string): command is CommentSizeCommand =>\n  command === \"small\" || command === \"medium\" || command === \"big\";\n\nconst isFontCommand = (command: string): command is CommentFontCommand =>\n  command === \"defont\" || command === \"gothic\" || command === \"mincho\";\n\nconst isColorCommand = (command: string): command is CommentColorCommand =>\n  command in COLOR_COMMAND_MAP;\n\nexport const parseCommentCommands = (\n  commands: readonly string[],\n  context: CommentCommandParseContext,\n): CommentCommandParseResult => {\n  let layout: CommentLayoutCommand = \"naka\";\n  let size: CommentSizeCommand = \"medium\";\n  let font: CommentFontCommand = \"defont\";\n  let colorOverride: string | null = null;\n  let opacityMultiplier = 1;\n  let opacityOverride: number | null = null;\n  let isInvisible = false;\n  let letterSpacing = 0;\n  let lineHeight = 1;\n\n  for (const rawCommand of commands) {\n    const normalizedToken = normalizeCommandToken(typeof rawCommand === \"string\" ? rawCommand : \"\");\n    if (!normalizedToken) {\n      continue;\n    }\n\n    if (HEX_COLOR_REGEX.test(normalizedToken)) {\n      const normalized = normalizeHexColor(normalizedToken as CommentHexColorCommand);\n      if (normalized) {\n        colorOverride = normalized;\n        continue;\n      }\n    }\n\n    const lower = normalizedToken.toLowerCase();\n\n    if (isLayoutCommand(lower)) {\n      layout = lower;\n      continue;\n    }\n\n    if (isSizeCommand(lower)) {\n      size = lower;\n      continue;\n    }\n\n    if (isFontCommand(lower)) {\n      font = lower;\n      continue;\n    }\n\n    if (isColorCommand(lower)) {\n      colorOverride = COLOR_COMMAND_MAP[lower].toUpperCase();\n      continue;\n    }\n\n    if (lower === \"_live\") {\n      opacityOverride = 0.5;\n      continue;\n    }\n\n    if (lower === \"invisible\") {\n      opacityMultiplier = 0;\n      isInvisible = true;\n      continue;\n    }\n\n    if (lower.startsWith(\"ls:\") || lower.startsWith(\"letterspacing:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseNumericCommandValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          letterSpacing = clampLetterSpacing(numericValue);\n        }\n      }\n      continue;\n    }\n\n    if (lower.startsWith(\"lh:\") || lower.startsWith(\"lineheight:\")) {\n      const separatorIndex = normalizedToken.indexOf(\":\");\n      if (separatorIndex >= 0) {\n        const numericValue = parseLineHeightValue(normalizedToken.slice(separatorIndex + 1));\n        if (numericValue !== null) {\n          lineHeight = clampLineHeight(numericValue);\n        }\n      }\n      continue;\n    }\n  }\n\n  const clampedOpacityMultiplier = Math.max(0, Math.min(1, opacityMultiplier));\n  const resolvedColor = (colorOverride ?? context.defaultColor).toUpperCase();\n  const resolvedOpacityOverride =\n    typeof opacityOverride === \"number\" ? Math.max(0, Math.min(1, opacityOverride)) : null;\n\n  return {\n    layout,\n    size,\n    sizeScale: COMMENT_SIZE_SCALE[size],\n    font,\n    fontFamily: FONT_FAMILY_MAP[font],\n    resolvedColor,\n    colorOverride,\n    opacityMultiplier: clampedOpacityMultiplier,\n    opacityOverride: resolvedOpacityOverride,\n    isInvisible,\n    letterSpacing,\n    lineHeight,\n  };\n};\n","const HEX_COLOR_PATTERN = /^#([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;\n\nconst expandHex = (fragment: string): string =>\n  fragment.length === 1 ? fragment.repeat(2) : fragment;\n\nconst parseHexComponent = (component: string): number => Number.parseInt(component, 16);\n\nexport const clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 0;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nexport const resolveFillStyleWithOpacity = (color: string, opacity: number): string => {\n  const match = HEX_COLOR_PATTERN.exec(color);\n  if (!match) {\n    return color;\n  }\n  const body = match[1];\n  let red: number;\n  let green: number;\n  let blue: number;\n  let alpha = 1;\n\n  if (body.length === 3 || body.length === 4) {\n    red = parseHexComponent(expandHex(body[0]));\n    green = parseHexComponent(expandHex(body[1]));\n    blue = parseHexComponent(expandHex(body[2]));\n    if (body.length === 4) {\n      alpha = parseHexComponent(expandHex(body[3])) / 255;\n    }\n  } else {\n    red = parseHexComponent(body.slice(0, 2));\n    green = parseHexComponent(body.slice(2, 4));\n    blue = parseHexComponent(body.slice(4, 6));\n    if (body.length === 8) {\n      alpha = parseHexComponent(body.slice(6, 8)) / 255;\n    }\n  }\n\n  const combinedAlpha = clampOpacity(alpha * clampOpacity(opacity));\n  return `rgba(${red}, ${green}, ${blue}, ${combinedAlpha})`;\n};\n","import type { TimeSource } from \"@/shared/types\";\n\nconst createPerformanceTimeSource = (): TimeSource => ({\n  now: () => {\n    if (typeof performance !== \"undefined\" && typeof performance.now === \"function\") {\n      return performance.now();\n    }\n    return Date.now();\n  },\n});\n\nexport const createDefaultTimeSource = (): TimeSource => createPerformanceTimeSource();\n","export const toMilliseconds = (seconds: number): number => seconds * 1000;\n\nexport const sanitizeVposMs = (value: number): number | null => {\n  if (!Number.isFinite(value)) {\n    return null;\n  }\n  if (value < 0) {\n    return null;\n  }\n  return Math.round(value);\n};\n\nexport const MAX_VISIBLE_DURATION_MS = 4_000;\nexport const MIN_VISIBLE_DURATION_MS = 1_800;\nexport const MAX_COMMENT_WIDTH_RATIO = 3;\nexport const COLLISION_BUFFER_RATIO = 0.25;\nexport const BASE_COLLISION_BUFFER_PX = 32;\nexport const ENTRY_BUFFER_PX = 48;\nexport const RESERVATION_TIME_MARGIN_MS = 120;\nexport const FINAL_PHASE_THRESHOLD_MS = 4_000;\nexport const FINAL_PHASE_MIN_GAP_MS = 120;\nexport const FINAL_PHASE_MAX_GAP_MS = 800;\nexport const FINAL_PHASE_ORDER_EPSILON_MS = 2;\nexport const FINAL_PHASE_MIN_WINDOW_MS = 4_000;\nexport const STATIC_VISIBLE_DURATION_MS = 4_000;\nexport const ACTIVE_WINDOW_MS = STATIC_VISIBLE_DURATION_MS + MAX_VISIBLE_DURATION_MS;\nexport const VIRTUAL_CANVAS_EXTENSION_PX = 1_000;\nexport const MIN_LANE_COUNT = 1;\nexport const DEFAULT_LANE_COUNT = 12;\nexport const MIN_FONT_SIZE_PX = 24;\nexport const EDGE_EPSILON = 1e-3;\nexport const SEEK_DIRECTION_EPSILON_MS = 50;\nexport const STATIC_COMMENT_VERTICAL_PADDING_RATIO = 0.05;\nexport const STATIC_COMMENT_MIN_VERTICAL_PADDING_PX = 10;\nexport const STATIC_COMMENT_SIDE_MARGIN_PX = 8;\nexport const MIN_STATIC_FONT_SIZE_PX = 12;\nexport const AUTO_HARD_RESET_DEDUP_WINDOW_MS = 500;\nexport const AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS = 3_000;\n","import type { LogLevel, Logger, LoggerOptions } from \"@/shared/types\";\n\nconst LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\nconst fallbackEmitter = (level: LogLevel, namespace: string, args: unknown[]): void => {\n  const prefix = `[${namespace}]`;\n  const consoleArgs: unknown[] = [prefix, ...args];\n  switch (level) {\n    case \"debug\":\n      console.debug(...consoleArgs);\n      break;\n    case \"info\":\n      console.info(...consoleArgs);\n      break;\n    case \"warn\":\n      console.warn(...consoleArgs);\n      break;\n    case \"error\":\n      console.error(...consoleArgs);\n      break;\n    default:\n      console.log(...consoleArgs);\n  }\n};\n\nexport const createLogger = (namespace: string, options: LoggerOptions = {}): Logger => {\n  const { level = \"info\", emitter = fallbackEmitter } = options;\n  const threshold = LEVEL_PRIORITY[level];\n\n  const emit = (logLevel: LogLevel, args: unknown[]): void => {\n    if (LEVEL_PRIORITY[logLevel] < threshold) {\n      return;\n    }\n    emitter(logLevel, namespace, args);\n  };\n\n  return {\n    debug: (...messages: unknown[]) => emit(\"debug\", messages),\n    info: (...messages: unknown[]) => emit(\"info\", messages),\n    warn: (...messages: unknown[]) => emit(\"warn\", messages),\n    error: (...messages: unknown[]) => emit(\"error\", messages),\n  };\n};\n\nexport type { LogLevel, Logger, LoggerOptions } from \"@/shared/types\";\n","import { createLogger } from \"@/shared/logger\";\n\nexport const commentLogger = createLogger(\"CommentEngine:Comment\");\n","import type { TextMeasurementCache } from \"@/shared/types\";\n\nconst textMeasurementCaches = new WeakMap<CanvasRenderingContext2D, TextMeasurementCache>();\n\nconst getTextMeasurementCache = (ctx: CanvasRenderingContext2D): TextMeasurementCache => {\n  let cache = textMeasurementCaches.get(ctx);\n  if (!cache) {\n    cache = new Map();\n    textMeasurementCaches.set(ctx, cache);\n  }\n  return cache;\n};\n\nexport const measureTextWidth = (ctx: CanvasRenderingContext2D, text: string): number => {\n  if (!ctx) {\n    return 0;\n  }\n  const fontKey = ctx.font ?? \"\";\n  const cacheKey = `${fontKey}::${text}`;\n  const cache = getTextMeasurementCache(ctx);\n  const cached = cache.get(cacheKey);\n  if (cached !== undefined) {\n    return cached;\n  }\n  const width = ctx.measureText(text).width;\n  cache.set(cacheKey, width);\n  return width;\n};\n","import type { CommentPrepareOptions } from \"@/shared/types\";\nimport type { Comment } from \"@/comment/comment\";\nimport {\n  STATIC_VISIBLE_DURATION_MS,\n  STATIC_COMMENT_SIDE_MARGIN_PX,\n  MIN_STATIC_FONT_SIZE_PX,\n} from \"@/shared/constants\";\nimport { commentLogger as logger } from \"@/comment/logger\";\nimport { measureTextWidth } from \"@/comment/text-measure\";\n\nconst ensureLines = (text: string): string[] => {\n  if (text.includes(\"\\n\")) {\n    const rawLines = text.split(/\\r?\\n/);\n    return rawLines.length > 0 ? rawLines : [\"\"];\n  }\n  return [text];\n};\n\nconst clampFontSize = (value: number): number => Math.max(24, value);\n\nconst updateTextMetrics = (comment: Comment, ctx: CanvasRenderingContext2D): void => {\n  let maxLineWidth = 0;\n  const effectiveLetterSpacing = comment.letterSpacing;\n  for (const line of comment.lines) {\n    const baseWidth = measureTextWidth(ctx, line);\n    const extraSpacing = line.length > 1 ? effectiveLetterSpacing * (line.length - 1) : 0;\n    const totalWidth = Math.max(0, baseWidth + extraSpacing);\n    if (totalWidth > maxLineWidth) {\n      maxLineWidth = totalWidth;\n    }\n  }\n  comment.width = maxLineWidth;\n  const computedLineHeightPx = Math.max(\n    1,\n    Math.floor(comment.fontSize * comment.lineHeightMultiplier),\n  );\n  comment.lineHeightPx = computedLineHeightPx;\n  const additionalHeight =\n    comment.lines.length > 1 ? (comment.lines.length - 1) * computedLineHeightPx : 0;\n  comment.height = comment.fontSize + additionalHeight;\n};\n\nexport const prepareComment = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  visibleWidth: number,\n  canvasHeight: number,\n  options: CommentPrepareOptions,\n): void => {\n  try {\n    if (!ctx) {\n      throw new Error(\"Canvas context is required\");\n    }\n    if (!Number.isFinite(visibleWidth) || !Number.isFinite(canvasHeight)) {\n      throw new Error(\"Canvas dimensions must be numbers\");\n    }\n    if (!options) {\n      throw new Error(\"Prepare options are required\");\n    }\n\n    const safeVisibleWidth = Math.max(visibleWidth, 1);\n    const baseFontSize = clampFontSize(Math.floor(canvasHeight * 0.05));\n    const scaledFontSize = clampFontSize(Math.floor(baseFontSize * comment.sizeScale));\n    comment.fontSize = scaledFontSize;\n    ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n    comment.lines = ensureLines(comment.text);\n    updateTextMetrics(comment, ctx);\n\n    const isStaticTopOrBottom =\n      !comment.isScrolling && (comment.layout === \"ue\" || comment.layout === \"shita\");\n    if (isStaticTopOrBottom) {\n      const maxStaticWidth = Math.max(1, safeVisibleWidth - STATIC_COMMENT_SIDE_MARGIN_PX * 2);\n      if (comment.width > maxStaticWidth) {\n        const minimumFontSize = Math.max(\n          MIN_STATIC_FONT_SIZE_PX,\n          Math.min(comment.fontSize, Math.floor(baseFontSize * 0.6)),\n        );\n        const shrinkFactor = maxStaticWidth / Math.max(comment.width, 1);\n        const initialShrink = Math.max(\n          minimumFontSize,\n          Math.floor(comment.fontSize * Math.min(shrinkFactor, 1)),\n        );\n        if (initialShrink < comment.fontSize) {\n          comment.fontSize = initialShrink;\n          ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n          updateTextMetrics(comment, ctx);\n        }\n        let iteration = 0;\n        while (\n          comment.width > maxStaticWidth &&\n          comment.fontSize > minimumFontSize &&\n          iteration < 5\n        ) {\n          const currentShrink = maxStaticWidth / Math.max(comment.width, 1);\n          const proposedSize = Math.max(\n            minimumFontSize,\n            Math.floor(comment.fontSize * Math.max(currentShrink, 0.7)),\n          );\n          if (proposedSize >= comment.fontSize) {\n            comment.fontSize = Math.max(minimumFontSize, comment.fontSize - 1);\n          } else {\n            comment.fontSize = proposedSize;\n          }\n          ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n          updateTextMetrics(comment, ctx);\n          iteration += 1;\n        }\n      }\n    }\n\n    if (!comment.isScrolling) {\n      comment.bufferWidth = 0;\n      const margin = isStaticTopOrBottom ? STATIC_COMMENT_SIDE_MARGIN_PX : 0;\n      const centeredX = Math.max((safeVisibleWidth - comment.width) / 2, margin);\n      const maxStart = Math.max(margin, safeVisibleWidth - comment.width - margin);\n      const clampedX = Math.min(centeredX, Math.max(maxStart, margin));\n      comment.virtualStartX = clampedX;\n      comment.x = clampedX;\n      comment.baseSpeed = 0;\n      comment.speed = 0;\n      comment.speedPixelsPerMs = 0;\n      comment.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.preCollisionDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.totalDurationMs = STATIC_VISIBLE_DURATION_MS;\n      comment.reservationWidth = comment.width;\n      comment.staticExpiryTimeMs = comment.vposMs + STATIC_VISIBLE_DURATION_MS;\n      comment.lastUpdateTime = comment.getTimeSource().now();\n      comment.isPaused = false;\n      return;\n    }\n\n    comment.staticExpiryTimeMs = null;\n    const maxReservationWidth = measureTextWidth(ctx, \"??\".repeat(150));\n\n    const bufferFromWidth = comment.width * Math.max(options.bufferRatio, 0);\n    comment.bufferWidth = Math.max(options.baseBufferPx, bufferFromWidth);\n    const entryBuffer = Math.max(options.entryBufferPx, comment.bufferWidth);\n\n    const direction = comment.scrollDirection;\n\n    const startLeft =\n      direction === \"rtl\"\n        ? safeVisibleWidth + options.virtualExtension\n        : -comment.width - comment.bufferWidth - options.virtualExtension;\n    const exitLeft =\n      direction === \"rtl\"\n        ? -comment.width - comment.bufferWidth - entryBuffer\n        : safeVisibleWidth + entryBuffer;\n    const trailingBoundary = direction === \"rtl\" ? safeVisibleWidth + entryBuffer : -entryBuffer;\n    const trailingEdgeAtStart =\n      direction === \"rtl\"\n        ? startLeft + comment.width + comment.bufferWidth\n        : startLeft - comment.bufferWidth;\n\n    comment.virtualStartX = startLeft;\n    comment.x = startLeft;\n    comment.exitThreshold = exitLeft;\n\n    const widthRatio = safeVisibleWidth > 0 ? comment.width / safeVisibleWidth : 0;\n    const hasFixedDuration = options.maxVisibleDurationMs === options.minVisibleDurationMs;\n    let visibleDurationMs = options.maxVisibleDurationMs;\n    if (!hasFixedDuration && widthRatio > 1) {\n      const clampedRatio = Math.min(widthRatio, options.maxWidthRatio);\n      const adjustedDuration = options.maxVisibleDurationMs / Math.max(clampedRatio, 1);\n      visibleDurationMs = Math.max(options.minVisibleDurationMs, Math.floor(adjustedDuration));\n    }\n\n    const visibleDistance = safeVisibleWidth + comment.width + comment.bufferWidth + entryBuffer;\n    const safeVisibleDuration = Math.max(visibleDurationMs, 1);\n    const pixelsPerMs = visibleDistance / safeVisibleDuration;\n    const pixelsPerFrame = (pixelsPerMs * 1000) / 60;\n    comment.baseSpeed = pixelsPerFrame;\n    comment.speed = comment.baseSpeed;\n    comment.speedPixelsPerMs = pixelsPerMs;\n\n    const travelDistance = Math.abs(exitLeft - startLeft);\n    const preCollisionDistance =\n      direction === \"rtl\"\n        ? Math.max(0, trailingEdgeAtStart - trailingBoundary)\n        : Math.max(0, trailingBoundary - trailingEdgeAtStart);\n    const safePixelsPerMs = Math.max(pixelsPerMs, Number.EPSILON);\n\n    comment.visibleDurationMs = visibleDurationMs;\n    comment.preCollisionDurationMs = Math.max(0, Math.ceil(preCollisionDistance / safePixelsPerMs));\n    comment.totalDurationMs = Math.max(\n      comment.preCollisionDurationMs,\n      Math.ceil(travelDistance / safePixelsPerMs),\n    );\n\n    const reservationBase = comment.width + comment.bufferWidth + entryBuffer;\n    comment.reservationWidth = Math.min(maxReservationWidth, reservationBase);\n    comment.lastUpdateTime = comment.getTimeSource().now();\n    comment.isPaused = false;\n  } catch (error) {\n    logger.error(\"Comment.prepare\", error as Error, {\n      text: comment.text,\n      visibleWidth,\n      canvasHeight,\n      hasContext: Boolean(ctx),\n    });\n    throw error;\n  }\n};\n\nexport { updateTextMetrics };\n","import type { DebugLoggingOptions, DebugState } from \"@/shared/types\";\nexport type { DebugLoggingOptions } from \"@/shared/types\";\n\nconst DEFAULT_MAX_LOGS_PER_CATEGORY = 5;\n\nconst state: DebugState = {\n  enabled: false,\n  maxLogsPerCategory: DEFAULT_MAX_LOGS_PER_CATEGORY,\n};\n\nconst categoryCounters = new Map<string, number>();\n\nconst normalizeLimit = (limit: number | undefined): number => {\n  if (limit === undefined) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  if (!Number.isFinite(limit)) {\n    return DEFAULT_MAX_LOGS_PER_CATEGORY;\n  }\n  const rounded = Math.max(1, Math.floor(limit));\n  return Math.min(10_000, rounded);\n};\n\nexport const configureDebugLogging = (options: DebugLoggingOptions): void => {\n  state.enabled = Boolean(options.enabled);\n  state.maxLogsPerCategory = normalizeLimit(options.maxLogsPerCategory);\n  if (!state.enabled) {\n    categoryCounters.clear();\n  }\n};\n\nexport const resetDebugCounters = (): void => {\n  categoryCounters.clear();\n};\n\nexport const isDebugLoggingEnabled = (): boolean => state.enabled;\n\nconst shouldEmitLog = (category: string): boolean => {\n  const currentCount = categoryCounters.get(category) ?? 0;\n  if (currentCount >= state.maxLogsPerCategory) {\n    if (currentCount === state.maxLogsPerCategory) {\n      console.debug(`[CommentOverlay][${category}]`, \"Further logs suppressed.\");\n      categoryCounters.set(category, currentCount + 1);\n    }\n    return false;\n  }\n  categoryCounters.set(category, currentCount + 1);\n  return true;\n};\n\nexport const debugLog = (category: string, ...payload: unknown[]): void => {\n  if (!state.enabled) {\n    return;\n  }\n  if (!shouldEmitLog(category)) {\n    return;\n  }\n  console.debug(`[CommentOverlay][${category}]`, ...payload);\n};\n\nexport const formatCommentPreview = (text: string, maxLength = 32): string => {\n  if (text.length <= maxLength) {\n    return text;\n  }\n  return `${text.slice(0, maxLength)}…`;\n};\n\n// 内部状態ダンプ\nexport const dumpRendererState = (\n  label: string,\n  snapshot: {\n    currentTime: number;\n    duration: number;\n    isPlaying: boolean;\n    epochId: number;\n    totalComments: number;\n    activeComments: number;\n    reservedLanes: number;\n    finalPhaseActive: boolean;\n    playbackHasBegun: boolean;\n    isStalled: boolean;\n  },\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  console.group(`[CommentOverlay][state-dump] ${label}`);\n  console.table({\n    \"Current Time\": `${snapshot.currentTime.toFixed(2)}ms`,\n    Duration: `${snapshot.duration.toFixed(2)}ms`,\n    \"Is Playing\": snapshot.isPlaying,\n    \"Epoch ID\": snapshot.epochId,\n    \"Total Comments\": snapshot.totalComments,\n    \"Active Comments\": snapshot.activeComments,\n    \"Reserved Lanes\": snapshot.reservedLanes,\n    \"Final Phase\": snapshot.finalPhaseActive,\n    \"Playback Begun\": snapshot.playbackHasBegun,\n    \"Is Stalled\": snapshot.isStalled,\n  });\n  console.groupEnd();\n};\n\n// エポック変更のログ\nexport const logEpochChange = (\n  previousEpochId: number,\n  newEpochId: number,\n  reason: string,\n): void => {\n  if (!state.enabled) {\n    return;\n  }\n  debugLog(\"epoch-change\", `Epoch changed: ${previousEpochId} → ${newEpochId} (reason: ${reason})`);\n};\n","import type { Comment } from \"@/comment/comment\";\nimport type { DrawMode } from \"@/shared/types\";\nimport { clampOpacity, resolveFillStyleWithOpacity } from \"@/comment/color\";\nimport { commentLogger as logger } from \"@/comment/logger\";\nimport { isDebugLoggingEnabled } from \"@/shared/debug\";\nimport { measureTextWidth } from \"@/comment/text-measure\";\n\nconst cacheStats = {\n  hits: 0,\n  misses: 0,\n  creates: 0,\n  fallbacks: 0,\n  outlineCallsInCache: 0,\n  fillCallsInCache: 0,\n  outlineCallsInFallback: 0,\n  fillCallsInFallback: 0,\n  letterSpacingComments: 0,\n  normalComments: 0,\n  multiLineComments: 0,\n  totalCharactersDrawn: 0,\n  lastReported: 0,\n};\n\nconst reportCacheStats = (): void => {\n  if (!isDebugLoggingEnabled()) {\n    return;\n  }\n  const now = performance.now();\n  if (now - cacheStats.lastReported <= 5000) {\n    return;\n  }\n  const total = cacheStats.hits + cacheStats.misses;\n  const hitRate = total > 0 ? (cacheStats.hits / total) * 100 : 0;\n  const avgCharsPerComment =\n    cacheStats.creates > 0\n      ? (cacheStats.totalCharactersDrawn / cacheStats.creates).toFixed(1)\n      : \"0\";\n  const totalOutlineCalls = cacheStats.outlineCallsInCache + cacheStats.outlineCallsInFallback;\n  const totalFillCalls = cacheStats.fillCallsInCache + cacheStats.fillCallsInFallback;\n  console.log(\n    `[TextureCache Stats]`,\n    `\\n  Cache: Hits=${cacheStats.hits}, Misses=${cacheStats.misses}, Hit Rate=${hitRate.toFixed(1)}%`,\n    `\\n  Creates: ${cacheStats.creates}, Fallbacks: ${cacheStats.fallbacks}`,\n    `\\n  Comments: Normal=${cacheStats.normalComments}, LetterSpacing=${cacheStats.letterSpacingComments}, MultiLine=${cacheStats.multiLineComments}`,\n    `\\n  Draw Calls: Outline=${totalOutlineCalls}, Fill=${totalFillCalls}`,\n    `\\n  Avg Characters/Comment: ${avgCharsPerComment}`,\n  );\n  cacheStats.lastReported = now;\n};\n\nconst isOffscreenCanvasSupported = (): boolean => typeof OffscreenCanvas !== \"undefined\";\n\nconst getOutlineOffsets = (fontSize: number): Array<[number, number]> => {\n  const outlineThickness = Math.max(1, Math.round(fontSize * 0.08));\n  const offsets: Array<[number, number]> = [\n    [-outlineThickness, 0],\n    [outlineThickness, 0],\n    [0, -outlineThickness],\n    [0, outlineThickness],\n  ];\n  if (outlineThickness > 1) {\n    const diagonal = Math.max(1, Math.round(outlineThickness * 0.7));\n    offsets.push(\n      [-diagonal, -diagonal],\n      [-diagonal, diagonal],\n      [diagonal, -diagonal],\n      [diagonal, diagonal],\n    );\n  }\n  return offsets;\n};\n\nconst createSegmentDrawer = (\n  comment: Comment,\n  targetCtx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  measurementCtx: CanvasRenderingContext2D,\n  statsTarget: \"cache\" | \"fallback\",\n  baseDrawX: number,\n): ((line: string, baselineY: number, mode: DrawMode, offsetX?: number) => void) => {\n  return (line, baselineY, mode, offsetX = 0) => {\n    if (line.length === 0) {\n      return;\n    }\n    const leadingSpaces = line.match(/^[\\u3000\\u00A0]+/);\n    const leadingSpaceCount = leadingSpaces ? leadingSpaces[0].length : 0;\n    const leadingSpaceOffset =\n      leadingSpaceCount > 0 ? measureTextWidth(measurementCtx, leadingSpaces![0]) : 0;\n    const effectiveDrawX = baseDrawX + leadingSpaceOffset + offsetX;\n    const trimmedLine = leadingSpaceCount > 0 ? line.substring(leadingSpaceCount) : line;\n\n    const recordDraw = (): void => {\n      if (statsTarget === \"cache\") {\n        if (mode === \"outline\") {\n          cacheStats.outlineCallsInCache++;\n        } else {\n          cacheStats.fillCallsInCache++;\n        }\n      } else if (mode === \"outline\") {\n        cacheStats.outlineCallsInFallback++;\n      } else {\n        cacheStats.fillCallsInFallback++;\n      }\n    };\n\n    if (Math.abs(comment.letterSpacing) < Number.EPSILON) {\n      recordDraw();\n      targetCtx.fillText(trimmedLine, effectiveDrawX, baselineY);\n      return;\n    }\n\n    let cursorX = effectiveDrawX;\n    for (let index = 0; index < trimmedLine.length; index += 1) {\n      const char = trimmedLine[index];\n      recordDraw();\n      targetCtx.fillText(char, cursorX, baselineY);\n      const advance = measureTextWidth(measurementCtx, char);\n      cursorX += advance;\n      if (index < trimmedLine.length - 1) {\n        cursorX += comment.letterSpacing;\n      }\n    }\n  };\n};\n\nconst generateTextureCacheKey = (comment: Comment): string => {\n  return `v2::${comment.text}::${comment.fontSize}::${comment.fontFamily}::${comment.color}::${comment.opacity}::${comment.renderStyle}::${comment.letterSpacing}::${comment.lines.length}`;\n};\n\nconst createTextureCanvas = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n): OffscreenCanvas | null => {\n  if (!isOffscreenCanvasSupported()) {\n    return null;\n  }\n\n  const hasLetterSpacing = Math.abs(comment.letterSpacing) >= Number.EPSILON;\n  const isMultiLine = comment.lines.length > 1;\n  if (hasLetterSpacing) {\n    cacheStats.letterSpacingComments++;\n  }\n  if (isMultiLine) {\n    cacheStats.multiLineComments++;\n  }\n  if (!hasLetterSpacing && !isMultiLine) {\n    cacheStats.normalComments++;\n  }\n  cacheStats.totalCharactersDrawn += comment.text.length;\n\n  const padding = Math.max(10, comment.fontSize * 0.5);\n  const textureWidth = Math.ceil(comment.width + padding * 2);\n  const textureHeight = Math.ceil(comment.height + padding * 2);\n\n  const offscreen = new OffscreenCanvas(textureWidth, textureHeight);\n  const offscreenCtx = offscreen.getContext(\"2d\");\n  if (!offscreenCtx) {\n    return null;\n  }\n\n  offscreenCtx.save();\n  offscreenCtx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n  const effectiveOpacity = clampOpacity(comment.opacity);\n  const drawX = padding;\n  const linesToRender = comment.lines.length > 0 ? comment.lines : [comment.text];\n  const lineAdvance =\n    comment.lines.length > 1 && comment.lineHeightPx > 0 ? comment.lineHeightPx : comment.fontSize;\n  const baselineStart = padding + comment.fontSize;\n  const drawSegment = createSegmentDrawer(comment, offscreenCtx, ctx, \"cache\", drawX);\n  const outlineOffsets = getOutlineOffsets(comment.fontSize);\n\n  const drawOutline = (): void => {\n    const outlineAlpha = clampOpacity(effectiveOpacity * 0.6);\n    offscreenCtx.save();\n    offscreenCtx.fillStyle = `rgba(0, 0, 0, ${outlineAlpha})`;\n    for (const [offsetX, offsetY] of outlineOffsets) {\n      linesToRender.forEach((line: string, index: number) => {\n        const baseline = baselineStart + index * lineAdvance + offsetY;\n        drawSegment(line, baseline, \"outline\", offsetX);\n      });\n    }\n    offscreenCtx.restore();\n  };\n\n  const drawFill = (fillStyle: string): void => {\n    offscreenCtx.save();\n    offscreenCtx.fillStyle = fillStyle;\n    linesToRender.forEach((line: string, index: number) => {\n      const baseline = baselineStart + index * lineAdvance;\n      drawSegment(line, baseline, \"fill\");\n    });\n    offscreenCtx.restore();\n  };\n\n  drawOutline();\n\n  if (comment.renderStyle === \"classic\") {\n    const baseShadowOffset = Math.max(1, comment.fontSize * 0.04);\n    const baseShadowBlur = comment.fontSize * 0.18;\n    type ShadowLayer = Readonly<{\n      offsetXMultiplier: number;\n      offsetYMultiplier: number;\n      blurMultiplier: number;\n      alpha: number;\n      rgb: string;\n    }>;\n    const shadowLayers: ReadonlyArray<ShadowLayer> = [\n      {\n        offsetXMultiplier: 0.9,\n        offsetYMultiplier: 1.1,\n        blurMultiplier: 0.55,\n        alpha: 0.52,\n        rgb: \"20, 28, 40\",\n      },\n      {\n        offsetXMultiplier: 2.4,\n        offsetYMultiplier: 2.7,\n        blurMultiplier: 1.45,\n        alpha: 0.32,\n        rgb: \"0, 0, 0\",\n      },\n      {\n        offsetXMultiplier: -0.7,\n        offsetYMultiplier: -0.6,\n        blurMultiplier: 0.4,\n        alpha: 0.42,\n        rgb: \"255, 255, 255\",\n      },\n    ];\n\n    shadowLayers.forEach((layer) => {\n      const effectiveShadowAlpha = clampOpacity(layer.alpha * effectiveOpacity);\n      offscreenCtx.save();\n      offscreenCtx.shadowColor = `rgba(${layer.rgb}, ${effectiveShadowAlpha})`;\n      offscreenCtx.shadowBlur = baseShadowBlur * layer.blurMultiplier;\n      offscreenCtx.shadowOffsetX = baseShadowOffset * layer.offsetXMultiplier;\n      offscreenCtx.shadowOffsetY = baseShadowOffset * layer.offsetYMultiplier;\n      offscreenCtx.fillStyle = \"rgba(0, 0, 0, 0)\";\n      linesToRender.forEach((line: string, index: number) => {\n        const baseline = baselineStart + index * lineAdvance;\n        drawSegment(line, baseline, \"fill\");\n      });\n      offscreenCtx.restore();\n    });\n  }\n\n  const resolvedFillStyle = resolveFillStyleWithOpacity(comment.color, effectiveOpacity);\n  drawFill(resolvedFillStyle);\n\n  offscreenCtx.restore();\n  return offscreen;\n};\n\nconst drawWithFallback = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  interpolatedX: number | null,\n): void => {\n  cacheStats.fallbacks++;\n  ctx.save();\n  ctx.font = `${comment.fontSize}px ${comment.fontFamily}`;\n  const effectiveOpacity = clampOpacity(comment.opacity);\n  const drawX = interpolatedX ?? comment.x;\n  const linesToRender = comment.lines.length > 0 ? comment.lines : [comment.text];\n  const lineAdvance =\n    comment.lines.length > 1 && comment.lineHeightPx > 0 ? comment.lineHeightPx : comment.fontSize;\n  const baselineStart = comment.y + comment.fontSize;\n  const drawSegment = createSegmentDrawer(comment, ctx, ctx, \"fallback\", drawX);\n  const outlineOffsets = getOutlineOffsets(comment.fontSize);\n\n  const drawOutline = (): void => {\n    const outlineAlpha = clampOpacity(effectiveOpacity * 0.6);\n    ctx.save();\n    ctx.fillStyle = `rgba(0, 0, 0, ${outlineAlpha})`;\n    for (const [offsetX, offsetY] of outlineOffsets) {\n      linesToRender.forEach((line: string, index: number) => {\n        const baseline = baselineStart + index * lineAdvance + offsetY;\n        drawSegment(line, baseline, \"outline\", offsetX);\n      });\n    }\n    ctx.restore();\n  };\n\n  const drawFill = (fillStyle: string): void => {\n    ctx.save();\n    ctx.fillStyle = fillStyle;\n    linesToRender.forEach((line: string, index: number) => {\n      const baseline = baselineStart + index * lineAdvance;\n      drawSegment(line, baseline, \"fill\");\n    });\n    ctx.restore();\n  };\n\n  drawOutline();\n\n  if (comment.renderStyle === \"classic\") {\n    const baseShadowOffset = Math.max(1, comment.fontSize * 0.04);\n    const baseShadowBlur = comment.fontSize * 0.18;\n    type ShadowLayer = Readonly<{\n      offsetXMultiplier: number;\n      offsetYMultiplier: number;\n      blurMultiplier: number;\n      alpha: number;\n      rgb: string;\n    }>;\n    const shadowLayers: ReadonlyArray<ShadowLayer> = [\n      {\n        offsetXMultiplier: 0.9,\n        offsetYMultiplier: 1.1,\n        blurMultiplier: 0.55,\n        alpha: 0.52,\n        rgb: \"20, 28, 40\",\n      },\n      {\n        offsetXMultiplier: 2.4,\n        offsetYMultiplier: 2.7,\n        blurMultiplier: 1.45,\n        alpha: 0.32,\n        rgb: \"0, 0, 0\",\n      },\n      {\n        offsetXMultiplier: -0.7,\n        offsetYMultiplier: -0.6,\n        blurMultiplier: 0.4,\n        alpha: 0.42,\n        rgb: \"255, 255, 255\",\n      },\n    ];\n\n    shadowLayers.forEach((layer) => {\n      const effectiveShadowAlpha = clampOpacity(layer.alpha * effectiveOpacity);\n      ctx.save();\n      ctx.shadowColor = `rgba(${layer.rgb}, ${effectiveShadowAlpha})`;\n      ctx.shadowBlur = baseShadowBlur * layer.blurMultiplier;\n      ctx.shadowOffsetX = baseShadowOffset * layer.offsetXMultiplier;\n      ctx.shadowOffsetY = baseShadowOffset * layer.offsetYMultiplier;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n      linesToRender.forEach((line: string, index: number) => {\n        const baseline = baselineStart + index * lineAdvance;\n        drawSegment(line, baseline, \"fill\");\n      });\n      ctx.restore();\n    });\n  }\n\n  const resolvedFillStyle = resolveFillStyleWithOpacity(comment.color, effectiveOpacity);\n  drawFill(resolvedFillStyle);\n  ctx.restore();\n};\n\nexport const drawComment = (\n  comment: Comment,\n  ctx: CanvasRenderingContext2D,\n  interpolatedX: number | null,\n): void => {\n  try {\n    if (!comment.isActive || !ctx) {\n      return;\n    }\n    const currentCacheKey = generateTextureCacheKey(comment);\n    const cachedTexture = comment.getCachedTexture();\n    if (comment.getTextureCacheKey() !== currentCacheKey || !cachedTexture) {\n      cacheStats.misses++;\n      cacheStats.creates++;\n      const created = createTextureCanvas(comment, ctx);\n      comment.setCachedTexture(created);\n      comment.setTextureCacheKey(currentCacheKey);\n    } else {\n      cacheStats.hits++;\n    }\n\n    const texture = comment.getCachedTexture();\n    if (texture) {\n      const drawX = interpolatedX ?? comment.x;\n      const padding = Math.max(10, comment.fontSize * 0.5);\n      ctx.drawImage(texture, drawX - padding, comment.y - padding);\n      reportCacheStats();\n      return;\n    }\n\n    drawWithFallback(comment, ctx, interpolatedX);\n    reportCacheStats();\n  } catch (error) {\n    logger.error(\"Comment.draw\", error as Error, {\n      text: comment.text,\n      isActive: comment.isActive,\n      hasContext: Boolean(ctx),\n      interpolatedX,\n    });\n  }\n};\n","import type { ScrollDirection } from \"@/shared/types\";\n\nexport const resolveScrollDirection = (input: ScrollDirection | string): ScrollDirection =>\n  input === \"ltr\" ? \"ltr\" : \"rtl\";\n\nexport const getDirectionSign = (direction: ScrollDirection): -1 | 1 =>\n  direction === \"ltr\" ? 1 : -1;\n","import type {\n  CommentLayoutCommand,\n  RenderStyle,\n  RendererSettings,\n  ScrollDirection,\n  CommentDependencies,\n  CommentPrepareOptions,\n  TimeSource,\n} from \"@/shared/types\";\nimport { parseCommentCommands } from \"@/comment/comment-commands\";\nimport { clampOpacity } from \"@/comment/color\";\nimport { createDefaultTimeSource } from \"@/comment/time-source\";\nimport { prepareComment } from \"@/comment/prepare\";\nimport { drawComment } from \"@/comment/render\";\nimport { resolveScrollDirection, getDirectionSign } from \"@/comment/direction\";\nimport { commentLogger as logger } from \"@/comment/logger\";\n\nexport class Comment {\n  readonly text: string;\n  readonly vposMs: number;\n  readonly commands: string[];\n  readonly layout: CommentLayoutCommand;\n  readonly isScrolling: boolean;\n  readonly sizeScale: number;\n  readonly opacityMultiplier: number;\n  readonly opacityOverride: number | null;\n  readonly colorOverride: string | null;\n  readonly isInvisible: boolean;\n\n  x = 0;\n  y = 0;\n  width = 0;\n  height = 0;\n  baseSpeed = 0;\n  speed = 0;\n  lane = -1;\n  color: string;\n  fontSize = 0;\n  fontFamily: string;\n  opacity: number;\n  activationTimeMs: number | null = null;\n  staticExpiryTimeMs: number | null = null;\n  isActive = false;\n  hasShown = false;\n  isPaused = false;\n  lastUpdateTime = 0;\n  reservationWidth = 0;\n  bufferWidth = 0;\n  visibleDurationMs = 0;\n  totalDurationMs = 0;\n  preCollisionDurationMs = 0;\n  speedPixelsPerMs = 0;\n  virtualStartX = 0;\n  exitThreshold = 0;\n  scrollDirection: ScrollDirection = \"rtl\";\n  renderStyle: RenderStyle = \"outline-only\";\n  creationIndex = 0;\n  letterSpacing = 0;\n  lineHeightMultiplier = 1;\n  lineHeightPx = 0;\n  lines: string[] = [];\n  epochId = 0;\n  private directionSign: -1 | 1 = -1;\n  private readonly timeSource: TimeSource;\n  private lastSyncedSettingsVersion = -1;\n  private cachedTexture: OffscreenCanvas | null = null;\n  private textureCacheKey = \"\";\n\n  constructor(\n    text: string,\n    vposMs: number,\n    commands: string[] | undefined,\n    settings: RendererSettings,\n    dependencies: CommentDependencies = {},\n  ) {\n    if (typeof text !== \"string\") {\n      throw new Error(\"Comment text must be a string\");\n    }\n    if (!Number.isFinite(vposMs) || vposMs < 0) {\n      throw new Error(\"Comment vposMs must be a non-negative number\");\n    }\n\n    this.text = text;\n    this.vposMs = vposMs;\n    this.commands = Array.isArray(commands) ? [...commands] : [];\n\n    const parsedCommands = parseCommentCommands(this.commands, {\n      defaultColor: settings.commentColor,\n    });\n\n    this.layout = parsedCommands.layout;\n    this.isScrolling = this.layout === \"naka\";\n    this.sizeScale = parsedCommands.sizeScale;\n    this.opacityMultiplier = parsedCommands.opacityMultiplier;\n    this.opacityOverride = parsedCommands.opacityOverride;\n    this.colorOverride = parsedCommands.colorOverride;\n    this.isInvisible = parsedCommands.isInvisible;\n    this.fontFamily = parsedCommands.fontFamily;\n    this.color = parsedCommands.resolvedColor;\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.renderStyle = settings.renderStyle;\n    this.letterSpacing = parsedCommands.letterSpacing;\n    this.lineHeightMultiplier = parsedCommands.lineHeight;\n\n    this.timeSource = dependencies.timeSource ?? createDefaultTimeSource();\n    this.applyScrollDirection(settings.scrollDirection);\n    this.syncWithSettings(settings, dependencies.settingsVersion);\n  }\n\n  prepare(\n    ctx: CanvasRenderingContext2D,\n    visibleWidth: number,\n    canvasHeight: number,\n    options: CommentPrepareOptions,\n  ): void {\n    prepareComment(this, ctx, visibleWidth, canvasHeight, options);\n  }\n\n  draw(ctx: CanvasRenderingContext2D, interpolatedX: number | null = null): void {\n    drawComment(this, ctx, interpolatedX);\n  }\n\n  update(playbackRate = 1.0, isPaused = false): void {\n    try {\n      if (!this.isActive) {\n        this.isPaused = isPaused;\n        return;\n      }\n\n      const currentTime = this.timeSource.now();\n\n      if (!this.isScrolling) {\n        this.isPaused = isPaused;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      if (isPaused) {\n        this.isPaused = true;\n        this.lastUpdateTime = currentTime;\n        return;\n      }\n\n      const deltaTime = (currentTime - this.lastUpdateTime) / (1000 / 60);\n      this.speed = this.baseSpeed * playbackRate;\n      this.x += this.speed * deltaTime * this.directionSign;\n      const hasExited =\n        (this.scrollDirection === \"rtl\" && this.x <= this.exitThreshold) ||\n        (this.scrollDirection === \"ltr\" && this.x >= this.exitThreshold);\n      if (hasExited) {\n        this.isActive = false;\n      }\n      this.lastUpdateTime = currentTime;\n      this.isPaused = false;\n    } catch (error) {\n      logger.error(\"Comment.update\", error as Error, {\n        text: this.text,\n        playbackRate,\n        isPaused,\n        isActive: this.isActive,\n      });\n    }\n  }\n\n  syncWithSettings(settings: RendererSettings, settingsVersion?: number): void {\n    const hasSyncedVersion =\n      typeof settingsVersion === \"number\" && settingsVersion === this.lastSyncedSettingsVersion;\n    if (hasSyncedVersion) {\n      return;\n    }\n    this.color = this.getEffectiveColor(settings.commentColor);\n    this.opacity = this.getEffectiveOpacity(settings.commentOpacity);\n    this.applyScrollDirection(settings.scrollDirection);\n    this.renderStyle = settings.renderStyle;\n    if (typeof settingsVersion === \"number\") {\n      this.lastSyncedSettingsVersion = settingsVersion;\n    }\n  }\n\n  getEffectiveColor(defaultColor: string): string {\n    const candidate = this.colorOverride ?? defaultColor;\n    if (typeof candidate !== \"string\" || candidate.length === 0) {\n      return defaultColor;\n    }\n    return candidate.toUpperCase();\n  }\n\n  getEffectiveOpacity(defaultOpacity: number): number {\n    if (typeof this.opacityOverride === \"number\") {\n      return clampOpacity(this.opacityOverride);\n    }\n    const scaled = defaultOpacity * this.opacityMultiplier;\n    if (!Number.isFinite(scaled)) {\n      return 0;\n    }\n    return clampOpacity(scaled);\n  }\n\n  markActivated(atTimeMs: number): void {\n    this.activationTimeMs = atTimeMs;\n  }\n\n  clearActivation(): void {\n    this.activationTimeMs = null;\n    if (!this.isScrolling) {\n      this.staticExpiryTimeMs = null;\n    }\n    this.resetTextureCache();\n  }\n\n  hasStaticExpired(currentTimeMs: number): boolean {\n    if (this.isScrolling) {\n      return false;\n    }\n    if (this.staticExpiryTimeMs === null) {\n      return false;\n    }\n    return currentTimeMs >= this.staticExpiryTimeMs;\n  }\n\n  getDirectionSign(): -1 | 1 {\n    return this.directionSign;\n  }\n\n  getTimeSource(): TimeSource {\n    return this.timeSource;\n  }\n\n  getTextureCacheKey(): string {\n    return this.textureCacheKey;\n  }\n\n  setTextureCacheKey(value: string): void {\n    this.textureCacheKey = value;\n  }\n\n  getCachedTexture(): OffscreenCanvas | null {\n    return this.cachedTexture;\n  }\n\n  setCachedTexture(texture: OffscreenCanvas | null): void {\n    this.cachedTexture = texture;\n  }\n\n  resetTextureCache(): void {\n    this.cachedTexture = null;\n    this.textureCacheKey = \"\";\n  }\n\n  private applyScrollDirection(direction: ScrollDirection | string): void {\n    const resolved = resolveScrollDirection(direction);\n    this.scrollDirection = resolved;\n    this.directionSign = getDirectionSign(resolved);\n  }\n}\n","import type { RendererSettings, ReadonlyRendererSettings } from \"@/shared/types\";\n\nexport const NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS = 4_000;\n\nconst BASE_SETTINGS: RendererSettings = {\n  commentColor: \"#FFFFFF\",\n  commentOpacity: 1,\n  isCommentVisible: true,\n  useContainerResizeObserver: true,\n  ngWords: [],\n  ngRegexps: [],\n  scrollDirection: \"rtl\",\n  renderStyle: \"outline-only\",\n  syncMode: \"raf\",\n  scrollVisibleDurationMs: NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS,\n  useFixedLaneCount: false,\n  fixedLaneCount: 12,\n  useDprScaling: true,\n  enableAutoHardReset: true,\n};\n\nexport const DEFAULT_RENDERER_SETTINGS: ReadonlyRendererSettings = BASE_SETTINGS;\n\nexport const cloneDefaultSettings = (): RendererSettings => ({\n  ...BASE_SETTINGS,\n  ngWords: [...BASE_SETTINGS.ngWords],\n  ngRegexps: [...BASE_SETTINGS.ngRegexps],\n});\n\nexport const COMMENT_OVERLAY_VERSION = \"v2.6.0\";\n","import type { RendererSettings, AnimationFrameProvider, TimeSource } from \"@/shared/types\";\nimport {\n  STATIC_COMMENT_MIN_VERTICAL_PADDING_PX,\n  STATIC_COMMENT_VERTICAL_PADDING_RATIO,\n} from \"@/shared/constants\";\n\nexport const clampOpacity = (value: number): number => {\n  if (!Number.isFinite(value)) {\n    return 1;\n  }\n  if (value <= 0) {\n    return 0;\n  }\n  if (value >= 1) {\n    return 1;\n  }\n  return value;\n};\n\nexport const calculateStaticCommentVerticalPadding = (fontSize: number): number =>\n  Math.max(\n    STATIC_COMMENT_MIN_VERTICAL_PADDING_PX,\n    Math.floor(fontSize * STATIC_COMMENT_VERTICAL_PADDING_RATIO),\n  );\n\nexport const normalizeSettings = (settings: RendererSettings): RendererSettings => {\n  const rawDuration = settings.scrollVisibleDurationMs;\n  const normalizedDuration =\n    rawDuration === null || rawDuration === undefined\n      ? null\n      : Number.isFinite(rawDuration)\n        ? Math.max(1, Math.floor(rawDuration))\n        : null;\n\n  return {\n    ...settings,\n    scrollDirection: settings.scrollDirection === \"ltr\" ? \"ltr\" : \"rtl\",\n    commentOpacity: clampOpacity(settings.commentOpacity),\n    renderStyle: settings.renderStyle === \"classic\" ? \"classic\" : \"outline-only\",\n    scrollVisibleDurationMs: normalizedDuration,\n    syncMode: settings.syncMode === \"video-frame\" ? \"video-frame\" : \"raf\",\n    useDprScaling: Boolean(settings.useDprScaling),\n    enableAutoHardReset: settings.enableAutoHardReset !== false,\n  };\n};\n\nexport const createDefaultAnimationFrameProvider = (\n  timeSource: TimeSource,\n): AnimationFrameProvider => {\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.requestAnimationFrame === \"function\" &&\n    typeof window.cancelAnimationFrame === \"function\"\n  ) {\n    return {\n      request: (callback) => window.requestAnimationFrame(callback),\n      cancel: (handle) => window.cancelAnimationFrame(handle),\n    };\n  }\n  return {\n    request: (callback) => {\n      const timeoutId = globalThis.setTimeout(() => {\n        callback(timeSource.now());\n      }, 16);\n      return timeoutId;\n    },\n    cancel: (handle) => {\n      globalThis.clearTimeout(handle);\n    },\n  };\n};\n\nexport const createBrowserCanvasFactory = (): (() => HTMLCanvasElement) => {\n  if (typeof document === \"undefined\") {\n    return () => {\n      throw new Error(\n        \"Document is not available. Provide a custom createCanvasElement implementation.\",\n      );\n    };\n  }\n  return () => document.createElement(\"canvas\");\n};\n\nexport const isRendererSettings = (input: unknown): input is RendererSettings => {\n  if (!input || typeof input !== \"object\") {\n    return false;\n  }\n  const candidate = input as Record<string, unknown>;\n  return (\n    typeof candidate.commentColor === \"string\" &&\n    typeof candidate.commentOpacity === \"number\" &&\n    typeof candidate.isCommentVisible === \"boolean\"\n  );\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { Comment } from \"@/comment/comment\";\nimport { formatCommentPreview, debugLog } from \"@/shared/debug\";\nimport { EDGE_EPSILON, sanitizeVposMs } from \"@/shared/constants\";\n\nconst addCommentsImpl = function (\n  this: CommentRenderer,\n  entries: ReadonlyArray<{ text: string; vposMs: number; commands?: string[] }>,\n): Comment[] {\n  if (!Array.isArray(entries) || entries.length === 0) {\n    return [];\n  }\n\n  const addedComments: Comment[] = [];\n  this.commentDependencies.settingsVersion = this.settingsVersion;\n\n  for (const entry of entries) {\n    const { text, vposMs, commands = [] } = entry;\n    const preview = formatCommentPreview(text);\n\n    if (this.isNGComment(text)) {\n      debugLog(\"comment-skip-ng\", { preview, vposMs });\n      continue;\n    }\n\n    const normalizedVposMs = sanitizeVposMs(vposMs);\n    if (normalizedVposMs === null) {\n      this.log.warn(\"CommentRenderer.addComment.invalidVpos\", { text, vposMs });\n      debugLog(\"comment-skip-invalid-vpos\", { preview, vposMs });\n      continue;\n    }\n\n    const duplicate =\n      this.comments.some(\n        (comment) => comment.text === text && comment.vposMs === normalizedVposMs,\n      ) ||\n      addedComments.some((comment) => comment.text === text && comment.vposMs === normalizedVposMs);\n    if (duplicate) {\n      debugLog(\"comment-skip-duplicate\", { preview, vposMs: normalizedVposMs });\n      continue;\n    }\n\n    const comment = new Comment(\n      text,\n      normalizedVposMs,\n      commands,\n      this._settings,\n      this.commentDependencies,\n    );\n    comment.creationIndex = this.commentSequence++;\n    comment.epochId = this.epochId;\n    addedComments.push(comment);\n    debugLog(\"comment-added\", {\n      preview,\n      vposMs: normalizedVposMs,\n      commands: comment.commands.length,\n      layout: comment.layout,\n      isScrolling: comment.isScrolling,\n      invisible: comment.isInvisible,\n    });\n  }\n\n  if (addedComments.length === 0) {\n    return [];\n  }\n\n  this.comments.push(...addedComments);\n  if (this.finalPhaseActive) {\n    this.finalPhaseScheduleDirty = true;\n  }\n  this.comments.sort((a, b) => {\n    const vposMsDiff = a.vposMs - b.vposMs;\n    if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n      return vposMsDiff;\n    }\n    return a.creationIndex - b.creationIndex;\n  });\n\n  return addedComments;\n};\n\nconst addCommentImpl = function (\n  this: CommentRenderer,\n  text: string,\n  vposMs: number,\n  commands: string[] = [],\n): Comment | null {\n  const [comment] = this.addComments([{ text, vposMs, commands }]);\n  return comment ?? null;\n};\n\nconst clearCommentsImpl = function (this: CommentRenderer): void {\n  this.comments.length = 0;\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  this.commentSequence = 0;\n  if (this.ctx && this.canvas) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const width = this.displayWidth > 0 ? this.displayWidth : this.canvas.width / effectiveDpr;\n    const height = this.displayHeight > 0 ? this.displayHeight : this.canvas.height / effectiveDpr;\n    this.ctx.clearRect(0, 0, width, height);\n  }\n};\n\nconst resetStateImpl = function (this: CommentRenderer): void {\n  this.clearComments();\n  this.currentTime = 0;\n  this.resetFinalPhaseState();\n  this.playbackHasBegun = false;\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n};\n\nexport const rebuildNgMatchersImpl = function (this: CommentRenderer): void {\n  const settings = this._settings;\n  const ngWords = Array.isArray(settings.ngWords) ? settings.ngWords : [];\n  this.normalizedNgWords = ngWords.filter((word): word is string => typeof word === \"string\");\n  const sourcePatterns = Array.isArray(settings.ngRegexps) ? settings.ngRegexps : [];\n  this.compiledNgRegexps = sourcePatterns\n    .map((entry): RegExp | null => {\n      if (typeof entry !== \"string\") {\n        return null;\n      }\n      try {\n        return new RegExp(entry, \"i\");\n      } catch (error) {\n        this.log.warn(\"CommentRenderer.invalidNgRegexp\", error as Error, { entry });\n        return null;\n      }\n    })\n    .filter((entry): entry is RegExp => Boolean(entry));\n};\n\nconst isNgCommentImpl = function (this: CommentRenderer, text: string): boolean {\n  if (typeof text !== \"string\" || text.length === 0) {\n    return false;\n  }\n  if (this.normalizedNgWords.some((word) => word.length > 0 && text.includes(word))) {\n    return true;\n  }\n  return this.compiledNgRegexps.some((regexp) => regexp.test(text));\n};\n\nexport const registerCommentCollectionMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.addComments = addCommentsImpl;\n  ctor.prototype.addComment = addCommentImpl;\n  ctor.prototype.clearComments = clearCommentsImpl;\n  ctor.prototype.resetState = resetStateImpl;\n  ctor.prototype.rebuildNgMatchers = rebuildNgMatchersImpl;\n  ctor.prototype.isNGComment = isNgCommentImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  EDGE_EPSILON,\n  FINAL_PHASE_MIN_GAP_MS,\n  FINAL_PHASE_MAX_GAP_MS,\n  FINAL_PHASE_ORDER_EPSILON_MS,\n  FINAL_PHASE_MIN_WINDOW_MS,\n  MAX_VISIBLE_DURATION_MS,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"@/shared/constants\";\nimport { dumpRendererState, logEpochChange } from \"@/shared/debug\";\nimport type { EpochChangeInfo, RendererStateSnapshot } from \"@/shared/types\";\n\nconst hardResetImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  const now = this.timeSource.now();\n  this.lastHardResetAt = now;\n\n  this.incrementEpoch(\"manual-reset\");\n\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n\n  this.comments.forEach((comment) => {\n    comment.isActive = false;\n    comment.hasShown = false;\n    comment.lane = -1;\n    comment.clearActivation();\n    comment.epochId = this.epochId;\n  });\n\n  if (canvas && ctx) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const effectiveHeight =\n      this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n  }\n\n  this.pendingInitialSync = true;\n  this.resetFinalPhaseState();\n  this.emitStateSnapshot(\"hardReset\");\n};\n\nconst resetFinalPhaseStateImpl = function (this: CommentRenderer): void {\n  this.finalPhaseActive = false;\n  this.finalPhaseStartTime = null;\n  this.finalPhaseScheduleDirty = false;\n  this.finalPhaseVposOverrides.clear();\n};\n\nconst incrementEpochImpl = function (\n  this: CommentRenderer,\n  reason: \"source-change\" | \"metadata-loaded\" | \"manual-reset\",\n): void {\n  const previousEpochId = this.epochId;\n  this.epochId += 1;\n\n  logEpochChange(previousEpochId, this.epochId, reason);\n\n  if (this.eventHooks.onEpochChange) {\n    const info: EpochChangeInfo = {\n      previousEpochId,\n      newEpochId: this.epochId,\n      reason,\n      timestamp: this.timeSource.now(),\n    };\n    try {\n      this.eventHooks.onEpochChange(info);\n    } catch (error) {\n      this.log.error(\"CommentRenderer.incrementEpoch.callback\", error as Error, { info });\n    }\n  }\n\n  this.comments.forEach((comment) => {\n    comment.epochId = this.epochId;\n  });\n};\n\nconst emitStateSnapshotImpl = function (this: CommentRenderer, label: string): void {\n  const now = this.timeSource.now();\n  if (now - this.lastSnapshotEmitTime < this.snapshotEmitThrottleMs) {\n    return;\n  }\n\n  const snapshot: RendererStateSnapshot = {\n    currentTime: this.currentTime,\n    duration: this.duration,\n    isPlaying: this.isPlaying,\n    epochId: this.epochId,\n    totalComments: this.comments.length,\n    activeComments: this.activeComments.size,\n    reservedLanes: this.reservedLanes.size,\n    finalPhaseActive: this.finalPhaseActive,\n    playbackHasBegun: this.playbackHasBegun,\n    isStalled: this.isStalled,\n  };\n\n  dumpRendererState(label, snapshot);\n\n  if (this.eventHooks.onStateSnapshot) {\n    try {\n      this.eventHooks.onStateSnapshot(snapshot);\n    } catch (error) {\n      this.log.error(\"CommentRenderer.emitStateSnapshot.callback\", error as Error);\n    }\n  }\n\n  this.lastSnapshotEmitTime = now;\n};\n\nconst getEffectiveCommentVposImpl = function (this: CommentRenderer, comment: Comment): number {\n  if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n  const override = this.finalPhaseVposOverrides.get(comment);\n  return override ?? comment.vposMs;\n};\n\nconst getFinalPhaseDisplayDurationImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n): number {\n  if (!comment.isScrolling) {\n    return STATIC_VISIBLE_DURATION_MS;\n  }\n\n  const durations: number[] = [];\n  if (Number.isFinite(comment.visibleDurationMs) && comment.visibleDurationMs > 0) {\n    durations.push(comment.visibleDurationMs);\n  }\n  if (Number.isFinite(comment.totalDurationMs) && comment.totalDurationMs > 0) {\n    durations.push(comment.totalDurationMs);\n  }\n\n  if (durations.length > 0) {\n    return Math.max(...durations);\n  }\n\n  return MAX_VISIBLE_DURATION_MS;\n};\n\nconst resolveFinalPhaseVposImpl = function (this: CommentRenderer, comment: Comment): number {\n  if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n    this.finalPhaseVposOverrides.delete(comment);\n    return comment.vposMs;\n  }\n  if (this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n  const override = this.finalPhaseVposOverrides.get(comment);\n  if (override !== undefined) {\n    return override;\n  }\n  const fallback = Math.max(comment.vposMs, this.finalPhaseStartTime);\n  this.finalPhaseVposOverrides.set(comment, fallback);\n  return fallback;\n};\n\nconst recomputeFinalPhaseTimelineImpl = function (this: CommentRenderer): void {\n  if (!this.finalPhaseActive || this.finalPhaseStartTime === null) {\n    this.finalPhaseVposOverrides.clear();\n    this.finalPhaseScheduleDirty = false;\n    return;\n  }\n\n  const windowStart = this.finalPhaseStartTime;\n  const durationMs = this.duration > 0 ? this.duration : windowStart + FINAL_PHASE_MIN_WINDOW_MS;\n  const windowEnd = Math.max(windowStart + FINAL_PHASE_MIN_WINDOW_MS, durationMs);\n\n  const candidates = this.comments\n    .filter((comment) => {\n      if (comment.hasShown) {\n        return false;\n      }\n      if (comment.isInvisible) {\n        return false;\n      }\n      if (this.isNGComment(comment.text)) {\n        return false;\n      }\n      return comment.vposMs >= windowStart - ACTIVE_WINDOW_MS;\n    })\n    .sort((a, b) => {\n      const diff = a.vposMs - b.vposMs;\n      if (Math.abs(diff) > EDGE_EPSILON) {\n        return diff;\n      }\n      return a.creationIndex - b.creationIndex;\n    });\n\n  this.finalPhaseVposOverrides.clear();\n\n  if (candidates.length === 0) {\n    this.finalPhaseScheduleDirty = false;\n    return;\n  }\n\n  const windowSpan = Math.max(windowEnd - windowStart, FINAL_PHASE_MIN_WINDOW_MS);\n  const baseGap = windowSpan / Math.max(candidates.length, 1);\n  const boundedGap = Number.isFinite(baseGap) ? baseGap : FINAL_PHASE_MIN_GAP_MS;\n  const gap = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(boundedGap, FINAL_PHASE_MAX_GAP_MS));\n\n  let nextStart = windowStart;\n  candidates.forEach((comment, index) => {\n    const durationNeeded = Math.max(1, this.getFinalPhaseDisplayDuration(comment));\n    const availableLatestStart = windowEnd - durationNeeded;\n    let assigned = Math.max(windowStart, Math.min(nextStart, availableLatestStart));\n    if (!Number.isFinite(assigned)) {\n      assigned = windowStart;\n    }\n    const epsilon = FINAL_PHASE_ORDER_EPSILON_MS * index;\n    if (assigned + epsilon <= availableLatestStart) {\n      assigned += epsilon;\n    }\n    this.finalPhaseVposOverrides.set(comment, assigned);\n    const spacing = Math.max(FINAL_PHASE_MIN_GAP_MS, Math.min(durationNeeded / 2, gap));\n    nextStart = assigned + spacing;\n  });\n\n  this.finalPhaseScheduleDirty = false;\n};\n\nexport const registerFinalPhaseMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.hardReset = hardResetImpl;\n  ctor.prototype.resetFinalPhaseState = resetFinalPhaseStateImpl;\n  ctor.prototype.incrementEpoch = incrementEpochImpl;\n  ctor.prototype.emitStateSnapshot = emitStateSnapshotImpl;\n  ctor.prototype.getEffectiveCommentVpos = getEffectiveCommentVposImpl;\n  ctor.prototype.getFinalPhaseDisplayDuration = getFinalPhaseDisplayDurationImpl;\n  ctor.prototype.resolveFinalPhaseVpos = resolveFinalPhaseVposImpl;\n  ctor.prototype.recomputeFinalPhaseTimeline = recomputeFinalPhaseTimelineImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { SEEK_DIRECTION_EPSILON_MS } from \"@/shared/constants\";\n\nconst shouldSuppressRenderingImpl = function (this: CommentRenderer): boolean {\n  return !this.playbackHasBegun && !this.isPlaying && this.currentTime <= SEEK_DIRECTION_EPSILON_MS;\n};\n\nconst updatePlaybackProgressStateImpl = function (this: CommentRenderer): void {\n  if (this.playbackHasBegun) {\n    return;\n  }\n  if (this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS) {\n    this.playbackHasBegun = true;\n  }\n};\n\nexport const registerPlaybackHelpers = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.shouldSuppressRendering = shouldSuppressRenderingImpl;\n  ctor.prototype.updatePlaybackProgressState = updatePlaybackProgressStateImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { CommentPrepareOptions } from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  BASE_COLLISION_BUFFER_PX,\n  COLLISION_BUFFER_RATIO,\n  ENTRY_BUFFER_PX,\n  FINAL_PHASE_THRESHOLD_MS,\n  MAX_COMMENT_WIDTH_RATIO,\n  MAX_VISIBLE_DURATION_MS,\n  MIN_VISIBLE_DURATION_MS,\n  SEEK_DIRECTION_EPSILON_MS,\n  VIRTUAL_CANVAS_EXTENSION_PX,\n  toMilliseconds,\n} from \"@/shared/constants\";\nimport { formatCommentPreview, debugLog, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst updateCommentsImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas || !context) {\n    return;\n  }\n\n  const referenceTime =\n    typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n  this.currentTime = referenceTime;\n  this.playbackRate = video.playbackRate;\n  this.isPlaying = !video.paused;\n  this.updatePlaybackProgressState();\n  this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n  if (this.skipDrawingForCurrentFrame) {\n    return;\n  }\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const isNearEnd =\n    this.duration > 0 && this.duration - this.currentTime <= FINAL_PHASE_THRESHOLD_MS;\n\n  if (isNearEnd && !this.finalPhaseActive) {\n    this.finalPhaseActive = true;\n    this.finalPhaseStartTime = this.currentTime;\n    this.finalPhaseVposOverrides.clear();\n    this.finalPhaseScheduleDirty = true;\n    context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    this.comments.forEach((comment) => {\n      comment.isActive = false;\n      comment.clearActivation();\n    });\n    this.activeComments.clear();\n    this.reservedLanes.clear();\n    this.topStaticLaneReservations.length = 0;\n    this.bottomStaticLaneReservations.length = 0;\n  }\n\n  if (!isNearEnd && this.finalPhaseActive) {\n    this.resetFinalPhaseState();\n  }\n\n  if (this.finalPhaseActive && this.finalPhaseScheduleDirty) {\n    this.recomputeFinalPhaseTimeline();\n  }\n\n  this.pruneStaticLaneReservations(this.currentTime);\n\n  const activeWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  for (const comment of activeWindowComments) {\n    const debugActive = isDebugLoggingEnabled();\n    const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n    if (debugActive) {\n      debugLog(\"comment-evaluate\", {\n        stage: \"update\",\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: this.getEffectiveCommentVpos(comment),\n        currentTime: this.currentTime,\n        isActive: comment.isActive,\n        hasShown: comment.hasShown,\n      });\n    }\n\n    if (this.isNGComment(comment.text)) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"ng-runtime\",\n        });\n      }\n      continue;\n    }\n    if (comment.isInvisible) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"invisible\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.hasShown = true;\n      comment.clearActivation();\n      continue;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n    }\n\n    if (comment.isActive) {\n      if (comment.layout !== \"naka\" && comment.hasStaticExpired(this.currentTime)) {\n        const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n        this.releaseStaticLane(staticPosition, comment.lane);\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n        continue;\n      }\n\n      if (\n        comment.layout === \"naka\" &&\n        this.getEffectiveCommentVpos(comment) > this.currentTime + SEEK_DIRECTION_EPSILON_MS\n      ) {\n        comment.x = comment.virtualStartX;\n        comment.lastUpdateTime = this.timeSource.now();\n        continue;\n      }\n\n      comment.hasShown = true;\n      comment.update(this.playbackRate, !this.isPlaying);\n      if (!comment.isScrolling && comment.hasStaticExpired(this.currentTime)) {\n        const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n        this.releaseStaticLane(staticPosition, comment.lane);\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n  }\n\n  if (this.isPlaying) {\n    for (const comment of this.comments) {\n      if (\n        comment.isActive &&\n        comment.isScrolling &&\n        ((comment.scrollDirection === \"rtl\" && comment.x <= comment.exitThreshold) ||\n          (comment.scrollDirection === \"ltr\" && comment.x >= comment.exitThreshold))\n      ) {\n        comment.isActive = false;\n        this.activeComments.delete(comment);\n        comment.clearActivation();\n      }\n    }\n  }\n};\n\nconst buildPrepareOptionsImpl = function (\n  this: CommentRenderer,\n  visibleWidth: number,\n): CommentPrepareOptions {\n  const overrideDuration = this._settings.scrollVisibleDurationMs;\n  let maxVisibleDurationMs = MAX_VISIBLE_DURATION_MS;\n  let minVisibleDurationMs = MIN_VISIBLE_DURATION_MS;\n\n  if (overrideDuration !== null) {\n    maxVisibleDurationMs = overrideDuration;\n    minVisibleDurationMs = Math.max(1, Math.min(overrideDuration, MIN_VISIBLE_DURATION_MS));\n  }\n\n  return {\n    visibleWidth,\n    virtualExtension: VIRTUAL_CANVAS_EXTENSION_PX,\n    maxVisibleDurationMs,\n    minVisibleDurationMs,\n    maxWidthRatio: MAX_COMMENT_WIDTH_RATIO,\n    bufferRatio: COLLISION_BUFFER_RATIO,\n    baseBufferPx: BASE_COLLISION_BUFFER_PX,\n    entryBufferPx: ENTRY_BUFFER_PX,\n  };\n};\n\nconst findAvailableLaneImpl = function (this: CommentRenderer, comment: Comment): number {\n  const currentTime = this.currentTime;\n  this.pruneLaneReservations(currentTime);\n  this.pruneStaticLaneReservations(currentTime);\n  const laneCandidates = this.getLanePriorityOrder(currentTime);\n  const newReservation = this.createLaneReservation(comment, currentTime);\n\n  for (const lane of laneCandidates) {\n    if (this.isLaneAvailable(lane, newReservation, currentTime)) {\n      this.storeLaneReservation(lane, newReservation);\n      return lane;\n    }\n  }\n\n  const fallbackLane = laneCandidates[0] ?? 0;\n  this.storeLaneReservation(fallbackLane, newReservation);\n  return fallbackLane;\n};\n\nexport const registerActivationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.updateComments = updateCommentsImpl;\n  ctor.prototype.buildPrepareOptions = buildPrepareOptionsImpl;\n  ctor.prototype.findAvailableLane = findAvailableLaneImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { LaneReservation, StaticLaneReservation } from \"@/shared/types\";\nimport { RESERVATION_TIME_MARGIN_MS } from \"@/shared/constants\";\n\nconst findFirstValidReservationIndexImpl = function (\n  this: CommentRenderer,\n  reservations: LaneReservation[],\n  cutoffTime: number,\n): number {\n  let left = 0;\n  let right = reservations.length;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const reservation = reservations[mid];\n    if (\n      reservation !== undefined &&\n      reservation.totalEndTime + RESERVATION_TIME_MARGIN_MS <= cutoffTime\n    ) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return left;\n};\n\nconst pruneLaneReservationsImpl = function (this: CommentRenderer, currentTime: number): void {\n  for (const [lane, reservations] of this.reservedLanes.entries()) {\n    const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n    if (firstValidIndex >= reservations.length) {\n      this.reservedLanes.delete(lane);\n    } else if (firstValidIndex > 0) {\n      this.reservedLanes.set(lane, reservations.slice(firstValidIndex));\n    }\n  }\n};\n\nconst pruneStaticLaneReservationsImpl = function (\n  this: CommentRenderer,\n  currentTime: number,\n): void {\n  const filterValid = (reservations: StaticLaneReservation[]): StaticLaneReservation[] =>\n    reservations.filter((reservation) => reservation.releaseTime > currentTime);\n\n  const topFiltered = filterValid(this.topStaticLaneReservations);\n  const bottomFiltered = filterValid(this.bottomStaticLaneReservations);\n\n  this.topStaticLaneReservations.length = 0;\n  this.topStaticLaneReservations.push(...topFiltered);\n\n  this.bottomStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.push(...bottomFiltered);\n};\n\nexport const registerLanePruneMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.findFirstValidReservationIndex = findFirstValidReservationIndexImpl;\n  ctor.prototype.pruneLaneReservations = pruneLaneReservationsImpl;\n  ctor.prototype.pruneStaticLaneReservations = pruneStaticLaneReservationsImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { Comment } from \"@/comment/comment\";\n\nconst findCommentIndexAtOrAfterImpl = function (\n  this: CommentRenderer,\n  targetVposMs: number,\n): number {\n  let left = 0;\n  let right = this.comments.length;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const comment = this.comments[mid];\n    if (comment !== undefined && comment.vposMs < targetVposMs) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return left;\n};\n\nconst getCommentsInTimeWindowImpl = function (\n  this: CommentRenderer,\n  centerTimeMs: number,\n  windowMs: number,\n): Comment[] {\n  if (this.comments.length === 0) {\n    return [];\n  }\n  const startTime = centerTimeMs - windowMs;\n  const endTime = centerTimeMs + windowMs;\n  const startIndex = this.findCommentIndexAtOrAfter(startTime);\n  const result: Comment[] = [];\n  for (let i = startIndex; i < this.comments.length; i++) {\n    const comment = this.comments[i];\n    if (!comment) {\n      continue;\n    }\n    if (comment.vposMs > endTime) {\n      break;\n    }\n    result.push(comment);\n  }\n  return result;\n};\n\nconst getStaticReservationsImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n): CommentRenderer[\"topStaticLaneReservations\"] {\n  return position === \"ue\" ? this.topStaticLaneReservations : this.bottomStaticLaneReservations;\n};\n\nconst getStaticLaneDepthImpl = function (this: CommentRenderer, position: \"ue\" | \"shita\"): number {\n  return position === \"ue\"\n    ? this.topStaticLaneReservations.length\n    : this.bottomStaticLaneReservations.length;\n};\n\nconst getStaticLaneLimitImpl = function (this: CommentRenderer, position: \"ue\" | \"shita\"): number {\n  const otherPosition = position === \"ue\" ? \"shita\" : \"ue\";\n  const otherDepth = this.getStaticLaneDepth(otherPosition);\n  const available = this.laneCount - otherDepth;\n  if (available <= 0) {\n    return -1;\n  }\n  return available - 1;\n};\n\nconst getGlobalLaneIndexForBottomImpl = function (\n  this: CommentRenderer,\n  localIndex: number,\n): number {\n  return Math.max(0, this.laneCount - 1 - localIndex);\n};\n\nconst resolveStaticCommentOffsetImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  lane: number,\n  displayHeight: number,\n  comment: Comment,\n): number {\n  const effectiveHeight = Math.max(1, displayHeight);\n  const commentHeight = Math.max(comment.height, comment.fontSize);\n  const padding = Math.max(1, Math.floor(comment.fontSize * 0.05));\n\n  if (position === \"ue\") {\n    const baseY = lane * this.laneHeight;\n    const minY = padding;\n    const maxY = Math.max(padding, effectiveHeight - commentHeight - padding);\n    return Math.max(minY, Math.min(baseY, maxY));\n  }\n\n  const targetBottomY = effectiveHeight - lane * this.laneHeight;\n  const adjustedY = targetBottomY - commentHeight - padding;\n  return Math.max(padding, adjustedY);\n};\n\nconst getStaticReservedLaneSetImpl = function (this: CommentRenderer): Set<number> {\n  const reserved = new Set<number>();\n  for (const reservation of this.topStaticLaneReservations) {\n    reserved.add(reservation.lane);\n  }\n  for (const reservation of this.bottomStaticLaneReservations) {\n    reserved.add(this.getGlobalLaneIndexForBottom(reservation.lane));\n  }\n  return reserved;\n};\n\nexport const registerLaneStaticMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.findCommentIndexAtOrAfter = findCommentIndexAtOrAfterImpl;\n  ctor.prototype.getCommentsInTimeWindow = getCommentsInTimeWindowImpl;\n  ctor.prototype.getStaticReservations = getStaticReservationsImpl;\n  ctor.prototype.getStaticLaneDepth = getStaticLaneDepthImpl;\n  ctor.prototype.getStaticLaneLimit = getStaticLaneLimitImpl;\n  ctor.prototype.getGlobalLaneIndexForBottom = getGlobalLaneIndexForBottomImpl;\n  ctor.prototype.resolveStaticCommentOffset = resolveStaticCommentOffsetImpl;\n  ctor.prototype.getStaticReservedLaneSet = getStaticReservedLaneSetImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { CommentPrepareOptions } from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport {\n  ACTIVE_WINDOW_MS,\n  EDGE_EPSILON,\n  FINAL_PHASE_MIN_WINDOW_MS,\n  SEEK_DIRECTION_EPSILON_MS,\n  STATIC_VISIBLE_DURATION_MS,\n} from \"@/shared/constants\";\nimport { calculateStaticCommentVerticalPadding } from \"@/shared/settings\";\nimport { debugLog, formatCommentPreview, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst shouldActivateCommentAtTimeImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n  timeMs: number,\n  preview: string = \"\",\n): boolean {\n  const debugActive = preview.length > 0 && isDebugLoggingEnabled();\n  const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n  if (\n    this.finalPhaseActive &&\n    this.finalPhaseStartTime !== null &&\n    comment.vposMs < this.finalPhaseStartTime - EDGE_EPSILON\n  ) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"final-phase-trimmed\",\n        finalPhaseStartTime: this.finalPhaseStartTime,\n      });\n    }\n    this.finalPhaseVposOverrides.delete(comment);\n    return false;\n  }\n\n  if (comment.isInvisible) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"invisible\",\n      });\n    }\n    return false;\n  }\n  if (comment.isActive) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"already-active\",\n      });\n    }\n    return false;\n  }\n  if (comment.hasShown && effectiveVpos <= timeMs) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"already-shown\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n  if (effectiveVpos > timeMs + SEEK_DIRECTION_EPSILON_MS) {\n    if (debugActive) {\n      debugLog(\"comment-eval-pending\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"future\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n  if (effectiveVpos < timeMs - ACTIVE_WINDOW_MS) {\n    if (debugActive) {\n      debugLog(\"comment-eval-skip\", {\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: effectiveVpos,\n        reason: \"expired-window\",\n        currentTime: timeMs,\n      });\n    }\n    return false;\n  }\n\n  if (debugActive) {\n    debugLog(\"comment-eval-ready\", {\n      preview,\n      vposMs: comment.vposMs,\n      effectiveVposMs: effectiveVpos,\n      currentTime: timeMs,\n    });\n  }\n  return true;\n};\n\nconst activateCommentImpl = function (\n  this: CommentRenderer,\n  comment: Comment,\n  context: CanvasRenderingContext2D,\n  displayWidth: number,\n  displayHeight: number,\n  options: CommentPrepareOptions,\n  referenceTime: number,\n): void {\n  comment.prepare(context, displayWidth, displayHeight, options);\n  const effectiveVpos = this.resolveFinalPhaseVpos(comment);\n\n  if (isDebugLoggingEnabled()) {\n    debugLog(\"comment-prepared\", {\n      preview: formatCommentPreview(comment.text),\n      layout: comment.layout,\n      isScrolling: comment.isScrolling,\n      width: comment.width,\n      height: comment.height,\n      bufferWidth: comment.bufferWidth,\n      visibleDurationMs: comment.visibleDurationMs,\n      effectiveVposMs: effectiveVpos,\n    });\n  }\n\n  if (comment.layout === \"naka\") {\n    const elapsedMs = Math.max(0, referenceTime - effectiveVpos);\n    const displacement = comment.speedPixelsPerMs * elapsedMs;\n\n    if (this.finalPhaseActive && this.finalPhaseStartTime !== null) {\n      const videoDuration =\n        this.duration > 0 ? this.duration : this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS;\n      const finalPhaseWindowEnd = Math.max(\n        this.finalPhaseStartTime + FINAL_PHASE_MIN_WINDOW_MS,\n        videoDuration,\n      );\n      const totalTravelDistance = comment.width + displayWidth;\n      const projectedTravelMs =\n        totalTravelDistance > 0 ? totalTravelDistance / Math.max(comment.speedPixelsPerMs, 1) : 0;\n      const projectedEndTime = effectiveVpos + projectedTravelMs;\n      if (projectedEndTime > finalPhaseWindowEnd) {\n        const remainingTime = finalPhaseWindowEnd - referenceTime;\n        const allowedTravel = Math.max(0, remainingTime) * comment.speedPixelsPerMs;\n        const startX =\n          comment.scrollDirection === \"rtl\"\n            ? Math.max(comment.virtualStartX - displacement, displayWidth - allowedTravel)\n            : Math.min(comment.virtualStartX + displacement, allowedTravel - comment.width);\n        comment.x = startX;\n      } else {\n        comment.x =\n          comment.scrollDirection === \"rtl\"\n            ? comment.virtualStartX - displacement\n            : comment.virtualStartX + displacement;\n      }\n    } else {\n      comment.x =\n        comment.scrollDirection === \"rtl\"\n          ? comment.virtualStartX - displacement\n          : comment.virtualStartX + displacement;\n    }\n    const laneIndex = this.findAvailableLane(comment);\n    comment.lane = laneIndex;\n    const laneHeight = Math.max(1, this.laneHeight);\n    const maxY = Math.max(0, displayHeight - comment.height);\n    const laneY = laneIndex * laneHeight;\n    comment.y = Math.max(0, Math.min(laneY, maxY));\n  } else {\n    const staticPosition = comment.layout === \"ue\" ? \"ue\" : \"shita\";\n    const laneIndex = this.assignStaticLane(staticPosition, comment, displayHeight, referenceTime);\n    const verticalOffset = this.resolveStaticCommentOffset(\n      staticPosition,\n      laneIndex,\n      displayHeight,\n      comment,\n    );\n    comment.x = Math.max(0, Math.min(displayWidth - comment.width, comment.virtualStartX));\n    comment.y = verticalOffset;\n    comment.lane =\n      staticPosition === \"ue\" ? laneIndex : this.getGlobalLaneIndexForBottom(laneIndex);\n    comment.speed = 0;\n    comment.baseSpeed = 0;\n    comment.speedPixelsPerMs = 0;\n    comment.visibleDurationMs = STATIC_VISIBLE_DURATION_MS;\n    const displayEnd = referenceTime + comment.visibleDurationMs;\n    this.activeComments.add(comment);\n    comment.isActive = true;\n    comment.hasShown = true;\n    comment.isPaused = !this.isPlaying;\n    comment.markActivated(referenceTime);\n    comment.lastUpdateTime = this.timeSource.now();\n    comment.staticExpiryTimeMs = displayEnd;\n    this.reserveStaticLane(staticPosition, comment, laneIndex, displayEnd);\n    if (isDebugLoggingEnabled()) {\n      debugLog(\"comment-activate-static\", {\n        preview: formatCommentPreview(comment.text),\n        lane: comment.lane,\n        position: staticPosition,\n        displayEnd,\n        effectiveVposMs: effectiveVpos,\n      });\n    }\n    return;\n  }\n\n  this.activeComments.add(comment);\n  comment.isActive = true;\n  comment.hasShown = true;\n  comment.isPaused = !this.isPlaying;\n  comment.markActivated(referenceTime);\n  comment.lastUpdateTime = this.timeSource.now();\n};\n\nconst assignStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  comment: Comment,\n  displayHeight: number,\n  currentTime: number,\n): number {\n  const reservations = this.getStaticReservations(position);\n  const limit = this.getStaticLaneLimit(position);\n  const laneCount = limit >= 0 ? limit + 1 : 0;\n  const laneIndices = Array.from({ length: laneCount }, (_, index) => index);\n\n  for (const lane of laneIndices) {\n    const yOffset = this.resolveStaticCommentOffset(position, lane, displayHeight, comment);\n    const commentHeight = Math.max(comment.height, comment.fontSize);\n    const padding = calculateStaticCommentVerticalPadding(comment.fontSize);\n    const yStart = yOffset - padding;\n    const yEnd = yOffset + commentHeight + padding;\n\n    const hasConflict = reservations.some((reservation) => {\n      const timeOverlap = reservation.releaseTime > currentTime;\n      if (!timeOverlap) {\n        return false;\n      }\n      const yOverlap = !(yEnd <= reservation.yStart || yStart >= reservation.yEnd);\n      return yOverlap;\n    });\n\n    if (!hasConflict) {\n      return lane;\n    }\n  }\n\n  let fallbackLane = laneIndices[0] ?? 0;\n  let earliestRelease = Number.POSITIVE_INFINITY;\n  for (const reservation of reservations) {\n    if (reservation.releaseTime < earliestRelease) {\n      earliestRelease = reservation.releaseTime;\n      fallbackLane = reservation.lane;\n    }\n  }\n  return fallbackLane;\n};\n\nconst reserveStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  comment: Comment,\n  lane: number,\n  releaseTime: number,\n): void {\n  const reservations = this.getStaticReservations(position);\n  const commentHeight = Math.max(comment.height, comment.fontSize);\n  const padding = calculateStaticCommentVerticalPadding(comment.fontSize);\n  const yStart = comment.y - padding;\n  const yEnd = comment.y + commentHeight + padding;\n\n  reservations.push({\n    comment,\n    releaseTime,\n    yStart,\n    yEnd,\n    lane,\n  });\n};\n\nconst releaseStaticLaneImpl = function (\n  this: CommentRenderer,\n  position: \"ue\" | \"shita\",\n  lane: number,\n): void {\n  if (lane < 0) {\n    return;\n  }\n  const reservations = this.getStaticReservations(position);\n  const index = reservations.findIndex((r) => r.lane === lane);\n  if (index >= 0) {\n    reservations.splice(index, 1);\n  }\n};\n\nexport const registerLaneActivationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.shouldActivateCommentAtTime = shouldActivateCommentAtTimeImpl;\n  ctor.prototype.activateComment = activateCommentImpl;\n  ctor.prototype.assignStaticLane = assignStaticLaneImpl;\n  ctor.prototype.reserveStaticLane = reserveStaticLaneImpl;\n  ctor.prototype.releaseStaticLane = releaseStaticLaneImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport type { LaneReservation } from \"@/shared/types\";\nimport { EDGE_EPSILON, RESERVATION_TIME_MARGIN_MS } from \"@/shared/constants\";\n\nconst getLanePriorityOrderImpl = function (this: CommentRenderer, currentTime: number): number[] {\n  const indices = Array.from({ length: this.laneCount }, (_, index) => index);\n  const sorted = indices.sort((a, b) => {\n    const nextA = this.getLaneNextAvailableTime(a, currentTime);\n    const nextB = this.getLaneNextAvailableTime(b, currentTime);\n    if (Math.abs(nextA - nextB) <= EDGE_EPSILON) {\n      return a - b;\n    }\n    return nextA - nextB;\n  });\n  const staticReserved = this.getStaticReservedLaneSet();\n  if (staticReserved.size === 0) {\n    return sorted;\n  }\n  const preferred = sorted.filter((lane) => !staticReserved.has(lane));\n  if (preferred.length === 0) {\n    return sorted;\n  }\n  const blocked = sorted.filter((lane) => staticReserved.has(lane));\n  return [...preferred, ...blocked];\n};\n\nconst getLaneNextAvailableTimeImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  currentTime: number,\n): number {\n  const reservations = this.reservedLanes.get(lane);\n  if (!reservations || reservations.length === 0) {\n    return currentTime;\n  }\n  const validIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n  const candidate = reservations[validIndex];\n  if (!candidate) {\n    return currentTime;\n  }\n  return Math.max(currentTime, candidate.endTime + RESERVATION_TIME_MARGIN_MS);\n};\n\nconst createLaneReservationImpl = function (\n  this: CommentRenderer,\n  comment: CommentRenderer[\"comments\"][number],\n  referenceTime: number,\n): LaneReservation {\n  const speed = Math.max(comment.speedPixelsPerMs, EDGE_EPSILON);\n  const effectiveStart = this.getEffectiveCommentVpos(comment);\n  const baseStartTime = Number.isFinite(effectiveStart) ? effectiveStart : referenceTime;\n  const startTime = Math.max(0, baseStartTime);\n  const endTime = startTime + comment.preCollisionDurationMs + RESERVATION_TIME_MARGIN_MS;\n  const totalEndTime = startTime + comment.totalDurationMs + RESERVATION_TIME_MARGIN_MS;\n  return {\n    comment,\n    startTime,\n    endTime: Math.max(startTime, endTime),\n    totalEndTime: Math.max(startTime, totalEndTime),\n    startLeft: comment.virtualStartX,\n    width: comment.width,\n    speed,\n    buffer: comment.bufferWidth,\n    directionSign: comment.getDirectionSign(),\n  };\n};\n\nconst isLaneAvailableImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  candidate: LaneReservation,\n  currentTime: number,\n): boolean {\n  const reservations = this.reservedLanes.get(lane);\n  if (!reservations || reservations.length === 0) {\n    return true;\n  }\n  const firstValidIndex = this.findFirstValidReservationIndex(reservations, currentTime);\n  for (let i = firstValidIndex; i < reservations.length; i += 1) {\n    const reservation = reservations[i];\n    if (!reservation) {\n      continue;\n    }\n    if (this.areReservationsConflicting(reservation, candidate)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst storeLaneReservationImpl = function (\n  this: CommentRenderer,\n  lane: number,\n  reservation: LaneReservation,\n): void {\n  const existing = this.reservedLanes.get(lane) ?? [];\n  const updated = [...existing, reservation].sort((a, b) => a.totalEndTime - b.totalEndTime);\n  this.reservedLanes.set(lane, updated);\n};\n\nconst areReservationsConflictingImpl = function (\n  this: CommentRenderer,\n  a: LaneReservation,\n  b: LaneReservation,\n): boolean {\n  const overlapStart = Math.max(a.startTime, b.startTime);\n  const overlapEnd = Math.min(a.endTime, b.endTime);\n  if (overlapStart >= overlapEnd) {\n    return false;\n  }\n\n  const evaluationTimes = new Set<number>([\n    overlapStart,\n    overlapEnd,\n    overlapStart + (overlapEnd - overlapStart) / 2,\n  ]);\n\n  const forwardIntersection = this.solveLeftRightEqualityTime(a, b);\n  if (\n    forwardIntersection !== null &&\n    forwardIntersection >= overlapStart - EDGE_EPSILON &&\n    forwardIntersection <= overlapEnd + EDGE_EPSILON\n  ) {\n    evaluationTimes.add(forwardIntersection);\n  }\n\n  const backwardIntersection = this.solveLeftRightEqualityTime(b, a);\n  if (\n    backwardIntersection !== null &&\n    backwardIntersection >= overlapStart - EDGE_EPSILON &&\n    backwardIntersection <= overlapEnd + EDGE_EPSILON\n  ) {\n    evaluationTimes.add(backwardIntersection);\n  }\n\n  for (const time of evaluationTimes) {\n    if (time < overlapStart - EDGE_EPSILON || time > overlapEnd + EDGE_EPSILON) {\n      continue;\n    }\n    const forwardGap = this.computeForwardGap(a, b, time);\n    const backwardGap = this.computeForwardGap(b, a, time);\n    if (forwardGap <= EDGE_EPSILON && backwardGap <= EDGE_EPSILON) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst computeForwardGapImpl = function (\n  this: CommentRenderer,\n  from: LaneReservation,\n  to: LaneReservation,\n  time: number,\n): number {\n  const fromEdges = this.getBufferedEdges(from, time);\n  const toEdges = this.getBufferedEdges(to, time);\n  return fromEdges.left - toEdges.right;\n};\n\nconst getBufferedEdgesImpl = function (\n  this: CommentRenderer,\n  reservation: LaneReservation,\n  time: number,\n): { left: number; right: number } {\n  const elapsed = Math.max(0, time - reservation.startTime);\n  const displacement = reservation.speed * elapsed;\n  const rawLeft = reservation.startLeft + reservation.directionSign * displacement;\n  const left = rawLeft - reservation.buffer;\n  const right = rawLeft + reservation.width + reservation.buffer;\n  return { left, right };\n};\n\nconst solveLeftRightEqualityTimeImpl = function (\n  this: CommentRenderer,\n  left: LaneReservation,\n  right: LaneReservation,\n): number | null {\n  const leftSign = left.directionSign;\n  const rightSign = right.directionSign;\n  const denominator = rightSign * right.speed - leftSign * left.speed;\n  if (Math.abs(denominator) < EDGE_EPSILON) {\n    return null;\n  }\n  const numerator =\n    right.startLeft +\n    rightSign * right.speed * right.startTime +\n    right.width +\n    right.buffer -\n    left.startLeft -\n    leftSign * left.speed * left.startTime +\n    left.buffer;\n  const time = numerator / denominator;\n  if (!Number.isFinite(time)) {\n    return null;\n  }\n  return time;\n};\n\nexport const registerLaneReservationMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.getLanePriorityOrder = getLanePriorityOrderImpl;\n  ctor.prototype.getLaneNextAvailableTime = getLaneNextAvailableTimeImpl;\n  ctor.prototype.createLaneReservation = createLaneReservationImpl;\n  ctor.prototype.isLaneAvailable = isLaneAvailableImpl;\n  ctor.prototype.storeLaneReservation = storeLaneReservationImpl;\n  ctor.prototype.areReservationsConflicting = areReservationsConflictingImpl;\n  ctor.prototype.computeForwardGap = computeForwardGapImpl;\n  ctor.prototype.getBufferedEdges = getBufferedEdgesImpl;\n  ctor.prototype.solveLeftRightEqualityTime = solveLeftRightEqualityTimeImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { ACTIVE_WINDOW_MS, EDGE_EPSILON, toMilliseconds } from \"@/shared/constants\";\n\nconst drawImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!canvas || !context) {\n    return;\n  }\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n\n  const now = this.timeSource.now();\n\n  if (this.skipDrawingForCurrentFrame || this.shouldSuppressRendering() || this.isStalled) {\n    context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n    this.lastDrawTime = now;\n    return;\n  }\n\n  context.clearRect(0, 0, effectiveWidth, effectiveHeight);\n  const activeComments = Array.from(this.activeComments);\n\n  if (this._settings.isCommentVisible) {\n    const deltaTime = (now - this.lastDrawTime) / (1000 / 60);\n    activeComments.sort((a, b) => {\n      const aVpos = this.getEffectiveCommentVpos(a);\n      const bVpos = this.getEffectiveCommentVpos(b);\n      const vposMsDiff = aVpos - bVpos;\n      if (Math.abs(vposMsDiff) > EDGE_EPSILON) {\n        return vposMsDiff;\n      }\n      if (a.isScrolling !== b.isScrolling) {\n        return a.isScrolling ? 1 : -1;\n      }\n      return a.creationIndex - b.creationIndex;\n    });\n    activeComments.forEach((comment) => {\n      const shouldInterpolate = this.isPlaying && !comment.isPaused;\n      const interpolatedX = shouldInterpolate\n        ? comment.x + comment.getDirectionSign() * comment.speed * deltaTime\n        : comment.x;\n      comment.draw(context, interpolatedX);\n    });\n  }\n\n  this.lastDrawTime = now;\n};\n\nconst performInitialSyncImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas || !context) {\n    return;\n  }\n\n  const absoluteTime =\n    typeof frameTimeMs === \"number\" ? frameTimeMs : toMilliseconds(video.currentTime);\n  this.currentTime = absoluteTime;\n  this.lastDrawTime = this.timeSource.now();\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const windowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  windowComments.forEach((comment) => {\n    if (this.isNGComment(comment.text) || comment.isInvisible) {\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.clearActivation();\n      return;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n    comment.isActive = false;\n    this.activeComments.delete(comment);\n    comment.lane = -1;\n    comment.clearActivation();\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n      return;\n    }\n\n    const effectiveVpos = this.getEffectiveCommentVpos(comment);\n    if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n      comment.hasShown = true;\n    } else {\n      comment.hasShown = false;\n    }\n  });\n};\n\nexport const registerRenderMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.draw = drawImpl;\n  ctor.prototype.performInitialSync = performInitialSyncImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { ACTIVE_WINDOW_MS, SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\nimport type {\n  RequestVideoFrameCallback,\n  CancelVideoFrameCallback,\n  VideoFrameCallbackMetadataLike,\n} from \"@/shared/types\";\nimport { formatCommentPreview, debugLog, isDebugLoggingEnabled } from \"@/shared/debug\";\n\nconst processFrameImpl = function (this: CommentRenderer, frameTimeMs?: number): void {\n  if (!this.videoElement) {\n    return;\n  }\n  if (!this._settings.isCommentVisible) {\n    return;\n  }\n\n  if (this.pendingInitialSync) {\n    this.performInitialSync(frameTimeMs);\n    this.pendingInitialSync = false;\n  }\n\n  this.updateComments(frameTimeMs);\n  this.draw();\n};\n\nconst handleAnimationFrameImpl = function (this: CommentRenderer): void {\n  const pendingId = this.frameId;\n  this.frameId = null;\n  if (pendingId !== null) {\n    this.animationFrameProvider.cancel(pendingId);\n  }\n  this.processFrame();\n  this.scheduleNextFrame();\n};\n\nconst handleVideoFrameImpl = function (\n  this: CommentRenderer,\n  _now: DOMHighResTimeStamp,\n  metadata: VideoFrameCallbackMetadataLike,\n): void {\n  this.videoFrameHandle = null;\n  const mediaTime = typeof metadata?.mediaTime === \"number\" ? metadata.mediaTime * 1000 : undefined;\n  this.processFrame(typeof mediaTime === \"number\" ? mediaTime : undefined);\n  this.scheduleNextFrame();\n};\n\nconst shouldUseVideoFrameCallbackImpl = function (this: CommentRenderer): boolean {\n  if (this._settings.syncMode !== \"video-frame\") {\n    return false;\n  }\n  const video = this.videoElement as HTMLVideoElement & {\n    requestVideoFrameCallback?: RequestVideoFrameCallback;\n    cancelVideoFrameCallback?: CancelVideoFrameCallback;\n  };\n  return (\n    Boolean(video) &&\n    typeof video.requestVideoFrameCallback === \"function\" &&\n    typeof video.cancelVideoFrameCallback === \"function\"\n  );\n};\n\nconst scheduleNextFrameImpl = function (this: CommentRenderer): void {\n  const video = this.videoElement;\n  if (!video) {\n    return;\n  }\n  if (this.shouldUseVideoFrameCallback()) {\n    this.cancelAnimationFrameRequest();\n    this.cancelVideoFrameCallback();\n    const request = (\n      video as HTMLVideoElement & {\n        requestVideoFrameCallback?: RequestVideoFrameCallback;\n      }\n    ).requestVideoFrameCallback;\n    if (typeof request === \"function\") {\n      this.videoFrameHandle = request.call(video, this.handleVideoFrame);\n    }\n    return;\n  }\n  this.cancelVideoFrameCallback();\n  this.frameId = this.animationFrameProvider.request(this.handleAnimationFrame);\n};\n\nconst cancelAnimationFrameRequestImpl = function (this: CommentRenderer): void {\n  if (this.frameId !== null) {\n    this.animationFrameProvider.cancel(this.frameId);\n    this.frameId = null;\n  }\n};\n\nconst cancelVideoFrameCallbackImpl = function (this: CommentRenderer): void {\n  if (this.videoFrameHandle === null) {\n    return;\n  }\n  const video = this.videoElement as HTMLVideoElement & {\n    cancelVideoFrameCallback?: CancelVideoFrameCallback;\n  };\n  if (video && typeof video.cancelVideoFrameCallback === \"function\") {\n    video.cancelVideoFrameCallback(this.videoFrameHandle);\n  }\n  this.videoFrameHandle = null;\n};\n\nconst startAnimationImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  this.scheduleNextFrame();\n};\n\nconst stopAnimationImpl = function (this: CommentRenderer): void {\n  this.cancelAnimationFrameRequest();\n  this.cancelVideoFrameCallback();\n};\n\nconst onSeekImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const context = this.ctx;\n  const video = this.videoElement;\n  if (!canvas || !context || !video) {\n    return;\n  }\n\n  const nextTime = toMilliseconds(video.currentTime);\n  const timeDelta = Math.abs(nextTime - this.currentTime);\n  const now = this.timeSource.now();\n\n  const isRecentPlayResume = now - this.lastPlayResumeTime < this.playResumeSeekIgnoreDurationMs;\n  if (isRecentPlayResume) {\n    this.currentTime = nextTime;\n    if (this._settings.isCommentVisible) {\n      this.lastDrawTime = now;\n      this.draw();\n    }\n    return;\n  }\n\n  const isSignificantSeek = timeDelta > SEEK_DIRECTION_EPSILON_MS;\n\n  this.currentTime = nextTime;\n  this.resetFinalPhaseState();\n  this.updatePlaybackProgressState();\n\n  if (!isSignificantSeek) {\n    if (this._settings.isCommentVisible) {\n      this.lastDrawTime = this.timeSource.now();\n      this.draw();\n    }\n    return;\n  }\n\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  const prepareOptions = this.buildPrepareOptions(effectiveWidth);\n\n  const seekWindowComments = this.getCommentsInTimeWindow(this.currentTime, ACTIVE_WINDOW_MS);\n\n  seekWindowComments.forEach((comment) => {\n    const debugActive = isDebugLoggingEnabled();\n    const preview = debugActive ? formatCommentPreview(comment.text) : \"\";\n    if (debugActive) {\n      debugLog(\"comment-evaluate\", {\n        stage: \"seek\",\n        preview,\n        vposMs: comment.vposMs,\n        effectiveVposMs: this.getEffectiveCommentVpos(comment),\n        currentTime: this.currentTime,\n        isActive: comment.isActive,\n        hasShown: comment.hasShown,\n      });\n    }\n\n    if (this.isNGComment(comment.text)) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"ng-runtime\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.clearActivation();\n      return;\n    }\n\n    if (comment.isInvisible) {\n      if (debugActive) {\n        debugLog(\"comment-eval-skip\", {\n          preview,\n          vposMs: comment.vposMs,\n          effectiveVposMs: this.getEffectiveCommentVpos(comment),\n          reason: \"invisible\",\n        });\n      }\n      comment.isActive = false;\n      this.activeComments.delete(comment);\n      comment.hasShown = true;\n      comment.clearActivation();\n      return;\n    }\n\n    comment.syncWithSettings(this._settings, this.settingsVersion);\n    comment.isActive = false;\n    this.activeComments.delete(comment);\n    comment.lane = -1;\n    comment.clearActivation();\n\n    if (this.shouldActivateCommentAtTime(comment, this.currentTime, preview)) {\n      this.activateComment(\n        comment,\n        context,\n        effectiveWidth,\n        effectiveHeight,\n        prepareOptions,\n        this.currentTime,\n      );\n      return;\n    }\n\n    const effectiveVpos = this.getEffectiveCommentVpos(comment);\n    if (effectiveVpos < this.currentTime - ACTIVE_WINDOW_MS) {\n      comment.hasShown = true;\n    } else {\n      comment.hasShown = false;\n    }\n  });\n\n  if (this._settings.isCommentVisible) {\n    this.lastDrawTime = this.timeSource.now();\n    this.draw();\n  }\n};\n\nexport const registerTimingMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.processFrame = processFrameImpl;\n  ctor.prototype.handleAnimationFrame = handleAnimationFrameImpl;\n  ctor.prototype.handleVideoFrame = handleVideoFrameImpl;\n  ctor.prototype.shouldUseVideoFrameCallback = shouldUseVideoFrameCallbackImpl;\n  ctor.prototype.scheduleNextFrame = scheduleNextFrameImpl;\n  ctor.prototype.cancelAnimationFrameRequest = cancelAnimationFrameRequestImpl;\n  ctor.prototype.cancelVideoFrameCallback = cancelVideoFrameCallbackImpl;\n  ctor.prototype.startAnimation = startAnimationImpl;\n  ctor.prototype.stopAnimation = stopAnimationImpl;\n  ctor.prototype.onSeek = onSeekImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nexport type AutoHardResetReason =\n  | \"play-resume\"\n  | \"first-play-delay\"\n  | \"resize\"\n  | \"visibility-restore\"\n  | \"seeked\";\n\nconst shouldAutoHardReset = (renderer: CommentRenderer): boolean =>\n  renderer._settings.enableAutoHardReset;\n\nexport const requestAutoHardReset = (\n  renderer: CommentRenderer,\n  reason: AutoHardResetReason,\n): void => {\n  if (!shouldAutoHardReset(renderer)) {\n    return;\n  }\n  void reason;\n  const now = renderer.timeSource.now();\n  if (now - renderer.lastHardResetAt < renderer.autoHardResetDedupWindowMs) {\n    return;\n  }\n  renderer.hardReset();\n};\n\nexport const scheduleInitialPlaybackAutoReset = (renderer: CommentRenderer): void => {\n  if (!shouldAutoHardReset(renderer)) {\n    return;\n  }\n  if (renderer.initialPlaybackAutoResetTriggered) {\n    return;\n  }\n  if (renderer.initialPlaybackAutoResetTimer !== null) {\n    return;\n  }\n  renderer.initialPlaybackAutoResetTimer = globalThis.setTimeout(() => {\n    renderer.initialPlaybackAutoResetTimer = null;\n    if (!shouldAutoHardReset(renderer)) {\n      return;\n    }\n    renderer.initialPlaybackAutoResetTriggered = true;\n    requestAutoHardReset(renderer, \"first-play-delay\");\n  }, renderer.initialPlaybackAutoResetDelayMs);\n};\n\nexport const resetInitialPlaybackAutoResetState = (renderer: CommentRenderer): void => {\n  if (renderer.initialPlaybackAutoResetTimer !== null) {\n    globalThis.clearTimeout(renderer.initialPlaybackAutoResetTimer);\n    renderer.initialPlaybackAutoResetTimer = null;\n  }\n  renderer.initialPlaybackAutoResetTriggered = false;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { resetInitialPlaybackAutoResetState } from \"@/renderer/auto-hard-reset\";\nimport type { CommentRendererInitializeOptions } from \"@/shared/types\";\nimport { SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\n\nconst resolveContainerImpl = function (\n  this: CommentRenderer,\n  explicit: HTMLElement | null | undefined,\n  video: HTMLVideoElement,\n): HTMLElement {\n  if (explicit) {\n    return explicit;\n  }\n  if (video.parentElement) {\n    return video.parentElement;\n  }\n  if (typeof document !== \"undefined\" && document.body) {\n    return document.body;\n  }\n  throw new Error(\n    \"Cannot resolve container element. Provide container explicitly when DOM is unavailable.\",\n  );\n};\n\nconst ensureContainerPositioningImpl = function (\n  this: CommentRenderer,\n  container: HTMLElement,\n): void {\n  if (typeof getComputedStyle === \"function\") {\n    const style = getComputedStyle(container);\n    if (style.position === \"static\") {\n      container.style.position = \"relative\";\n    }\n    return;\n  }\n  if (!container.style.position) {\n    container.style.position = \"relative\";\n  }\n};\n\nconst initializeImpl = function (\n  this: CommentRenderer,\n  options: HTMLVideoElement | CommentRendererInitializeOptions,\n): void {\n  try {\n    this.destroyCanvasOnly();\n\n    const video = options instanceof HTMLVideoElement ? options : options.video;\n    const containerCandidate =\n      options instanceof HTMLVideoElement\n        ? options.parentElement\n        : (options.container ?? options.video.parentElement);\n    const container = this.resolveContainer(containerCandidate ?? null, video);\n\n    this.videoElement = video;\n    this.containerElement = container;\n    this.lastVideoSource = this.getCurrentVideoSource();\n    this.duration = Number.isFinite(video.duration) ? toMilliseconds(video.duration) : 0;\n    this.currentTime = toMilliseconds(video.currentTime);\n    this.playbackRate = video.playbackRate;\n    this.isPlaying = !video.paused;\n    this.isStalled = false;\n    this.lastDrawTime = this.timeSource.now();\n    this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n    this.skipDrawingForCurrentFrame = this.shouldSuppressRendering();\n\n    const canvas = this.createCanvasElement();\n    const context = canvas.getContext(\"2d\");\n    if (!context) {\n      throw new Error(\"Failed to acquire 2D canvas context\");\n    }\n\n    canvas.style.position = \"absolute\";\n    canvas.style.top = \"0\";\n    canvas.style.left = \"0\";\n    canvas.style.pointerEvents = \"none\";\n    canvas.style.zIndex = \"1000\";\n\n    const parent = this.containerElement;\n    if (parent instanceof HTMLElement) {\n      this.ensureContainerPositioning(parent);\n      parent.appendChild(canvas);\n    }\n\n    this.canvas = canvas;\n    this.ctx = context;\n\n    this.resize();\n    this.calculateLaneMetrics();\n    this.setupVideoEventListeners(video);\n    this.setupResizeHandling(video);\n    this.setupFullscreenHandling();\n    this.setupVideoChangeDetection(video, container);\n    this.startAnimation();\n    this.setupVisibilityHandling();\n  } catch (error) {\n    this.log.error(\"CommentRenderer.initialize\", error as Error);\n    throw error;\n  }\n};\n\nconst destroyImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  this.cleanupResizeHandling();\n  this.runCleanupTasks();\n  resetInitialPlaybackAutoResetState(this);\n\n  if (this.canvas) {\n    this.canvas.remove();\n  }\n  this.canvas = null;\n  this.ctx = null;\n  this.videoElement = null;\n  this.containerElement = null;\n  this.comments.length = 0;\n  this.activeComments.clear();\n  this.reservedLanes.clear();\n  this.resetFinalPhaseState();\n  this.displayWidth = 0;\n  this.displayHeight = 0;\n  this.canvasDpr = 1;\n  this.commentSequence = 0;\n  this.playbackHasBegun = false;\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n};\n\nconst destroyCanvasOnlyImpl = function (this: CommentRenderer): void {\n  this.stopAnimation();\n  resetInitialPlaybackAutoResetState(this);\n  if (this.canvas) {\n    this.canvas.remove();\n  }\n  this.canvas = null;\n  this.ctx = null;\n  this.displayWidth = 0;\n  this.displayHeight = 0;\n  this.canvasDpr = 1;\n  this.fullscreenActive = false;\n};\n\nexport const registerLifecycleCoreMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.resolveContainer = resolveContainerImpl;\n  ctor.prototype.ensureContainerPositioning = ensureContainerPositioningImpl;\n  ctor.prototype.initialize = initializeImpl;\n  ctor.prototype.destroy = destroyImpl;\n  ctor.prototype.destroyCanvasOnly = destroyCanvasOnlyImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport {\n  requestAutoHardReset,\n  resetInitialPlaybackAutoResetState,\n  scheduleInitialPlaybackAutoReset,\n} from \"@/renderer/auto-hard-reset\";\nimport { SEEK_DIRECTION_EPSILON_MS, toMilliseconds } from \"@/shared/constants\";\n\nconst setupVideoEventListenersImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  try {\n    const onPlay = (): void => {\n      const wasPlaying = this.isPlaying;\n      this.isPlaying = true;\n      this.playbackHasBegun = true;\n      const now = this.timeSource.now();\n      this.lastDrawTime = now;\n      this.lastPlayResumeTime = now;\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n        comment.isPaused = false;\n      });\n      if (!wasPlaying) {\n        requestAutoHardReset(this, \"play-resume\");\n      }\n      scheduleInitialPlaybackAutoReset(this);\n    };\n    const onPause = (): void => {\n      this.isPlaying = false;\n      const now = this.timeSource.now();\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n        comment.isPaused = true;\n      });\n    };\n    const onSeeking = (): void => {\n      this.onSeek();\n    };\n    const onSeeked = (): void => {\n      this.onSeek();\n      requestAutoHardReset(this, \"seeked\");\n    };\n    const onRateChange = (): void => {\n      this.playbackRate = videoElement.playbackRate;\n      const now = this.timeSource.now();\n      this.comments.forEach((comment) => {\n        comment.lastUpdateTime = now;\n      });\n    };\n    const onLoadedMetadata = (): void => {\n      this.handleVideoMetadataLoaded(videoElement);\n    };\n    const onDurationChange = (): void => {\n      this.duration = Number.isFinite(videoElement.duration)\n        ? toMilliseconds(videoElement.duration)\n        : 0;\n    };\n    const onEmptied = (): void => {\n      this.handleVideoSourceChange();\n    };\n    const onWaiting = (): void => {\n      this.handleVideoStalled();\n    };\n    const onCanPlay = (): void => {\n      this.handleVideoCanPlay();\n    };\n    const onPlaying = (): void => {\n      this.handleVideoCanPlay();\n    };\n\n    videoElement.addEventListener(\"play\", onPlay);\n    videoElement.addEventListener(\"pause\", onPause);\n    videoElement.addEventListener(\"seeking\", onSeeking);\n    videoElement.addEventListener(\"seeked\", onSeeked);\n    videoElement.addEventListener(\"ratechange\", onRateChange);\n    videoElement.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n    videoElement.addEventListener(\"durationchange\", onDurationChange);\n    videoElement.addEventListener(\"emptied\", onEmptied);\n    videoElement.addEventListener(\"waiting\", onWaiting);\n    videoElement.addEventListener(\"canplay\", onCanPlay);\n    videoElement.addEventListener(\"playing\", onPlaying);\n\n    this.addCleanup(() => videoElement.removeEventListener(\"play\", onPlay));\n    this.addCleanup(() => videoElement.removeEventListener(\"pause\", onPause));\n    this.addCleanup(() => videoElement.removeEventListener(\"seeking\", onSeeking));\n    this.addCleanup(() => videoElement.removeEventListener(\"seeked\", onSeeked));\n    this.addCleanup(() => videoElement.removeEventListener(\"ratechange\", onRateChange));\n    this.addCleanup(() => videoElement.removeEventListener(\"loadedmetadata\", onLoadedMetadata));\n    this.addCleanup(() => videoElement.removeEventListener(\"durationchange\", onDurationChange));\n    this.addCleanup(() => videoElement.removeEventListener(\"emptied\", onEmptied));\n    this.addCleanup(() => videoElement.removeEventListener(\"waiting\", onWaiting));\n    this.addCleanup(() => videoElement.removeEventListener(\"canplay\", onCanPlay));\n    this.addCleanup(() => videoElement.removeEventListener(\"playing\", onPlaying));\n  } catch (error) {\n    this.log.error(\"CommentRenderer.setupVideoEventListeners\", error as Error);\n    throw error;\n  }\n};\n\nconst handleVideoMetadataLoadedImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  this.lastVideoSource = this.getCurrentVideoSource();\n  this.incrementEpoch(\"metadata-loaded\");\n  this.handleVideoSourceChange(videoElement);\n  this.resize();\n  this.calculateLaneMetrics();\n  this.hardReset();\n  this.onSeek();\n  this.emitStateSnapshot(\"metadata-loaded\");\n  resetInitialPlaybackAutoResetState(this);\n};\n\nconst handleVideoStalledImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  if (!canvas || !ctx) {\n    return;\n  }\n\n  this.isStalled = true;\n\n  const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const effectiveWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n  ctx.clearRect(0, 0, effectiveWidth, effectiveHeight);\n\n  this.comments.forEach((comment) => {\n    if (comment.isActive) {\n      comment.lastUpdateTime = this.timeSource.now();\n    }\n  });\n};\n\nconst handleVideoCanPlayImpl = function (this: CommentRenderer): void {\n  if (!this.isStalled) {\n    return;\n  }\n\n  this.isStalled = false;\n\n  if (this.videoElement) {\n    this.currentTime = toMilliseconds(this.videoElement.currentTime);\n    this.isPlaying = !this.videoElement.paused;\n  }\n\n  this.lastDrawTime = this.timeSource.now();\n};\n\nconst handleVideoSourceChangeImpl = function (\n  this: CommentRenderer,\n  videoElement?: HTMLVideoElement | null,\n): void {\n  const target = videoElement ?? this.videoElement;\n  if (!target) {\n    this.lastVideoSource = null;\n    this.isPlaying = false;\n    this.resetFinalPhaseState();\n    this.resetCommentActivity();\n    resetInitialPlaybackAutoResetState(this);\n    return;\n  }\n\n  const currentSource = this.getCurrentVideoSource();\n  const sourceChanged = currentSource !== this.lastVideoSource;\n  if (!sourceChanged) {\n    return;\n  }\n\n  this.lastVideoSource = currentSource;\n  this.incrementEpoch(\"source-change\");\n  this.syncVideoState(target);\n  this.resetFinalPhaseState();\n  this.resetCommentActivity();\n  this.emitStateSnapshot(\"source-change\");\n  resetInitialPlaybackAutoResetState(this);\n};\n\nconst syncVideoStateImpl = function (this: CommentRenderer, videoElement: HTMLVideoElement): void {\n  this.duration = Number.isFinite(videoElement.duration)\n    ? toMilliseconds(videoElement.duration)\n    : 0;\n  this.currentTime = toMilliseconds(videoElement.currentTime);\n  this.playbackRate = videoElement.playbackRate;\n  this.isPlaying = !videoElement.paused;\n  this.isStalled = false;\n  this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n  this.lastDrawTime = this.timeSource.now();\n};\n\nconst resetCommentActivityImpl = function (this: CommentRenderer): void {\n  const now = this.timeSource.now();\n  const canvas = this.canvas;\n  const context = this.ctx;\n  this.resetFinalPhaseState();\n  this.skipDrawingForCurrentFrame = false;\n  this.isStalled = false;\n  this.pendingInitialSync = false;\n  this.playbackHasBegun = this.isPlaying || this.currentTime > SEEK_DIRECTION_EPSILON_MS;\n  if (canvas && context) {\n    const effectiveDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n    const width = this.displayWidth > 0 ? this.displayWidth : canvas.width / effectiveDpr;\n    const height = this.displayHeight > 0 ? this.displayHeight : canvas.height / effectiveDpr;\n    context.clearRect(0, 0, width, height);\n  }\n  this.reservedLanes.clear();\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n  this.comments.forEach((comment) => {\n    comment.isActive = false;\n    comment.isPaused = !this.isPlaying;\n    comment.hasShown = false;\n    comment.lane = -1;\n    comment.x = comment.virtualStartX;\n    comment.speed = comment.baseSpeed;\n    comment.lastUpdateTime = now;\n    comment.clearActivation();\n  });\n  this.activeComments.clear();\n};\n\nconst setupVideoChangeDetectionImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n  container: HTMLElement,\n): void {\n  if (typeof MutationObserver === \"undefined\") {\n    this.log.debug(\n      \"MutationObserver is not available in this environment. Video change detection is disabled.\",\n    );\n    return;\n  }\n\n  const videoObserver = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      if (mutation.type === \"attributes\" && mutation.attributeName === \"src\") {\n        const targetNode = mutation.target;\n        let previous: string | null = null;\n        let current: string | null = null;\n        if (targetNode instanceof HTMLVideoElement || targetNode instanceof HTMLSourceElement) {\n          previous = typeof mutation.oldValue === \"string\" ? mutation.oldValue : null;\n          current = targetNode.getAttribute(\"src\");\n        }\n        if (previous === current) {\n          continue;\n        }\n        this.handleVideoSourceChange(videoElement);\n        return;\n      }\n      if (mutation.type === \"childList\") {\n        for (const node of mutation.addedNodes) {\n          if (node instanceof HTMLSourceElement) {\n            this.handleVideoSourceChange(videoElement);\n            return;\n          }\n        }\n        for (const node of mutation.removedNodes) {\n          if (node instanceof HTMLSourceElement) {\n            this.handleVideoSourceChange(videoElement);\n            return;\n          }\n        }\n      }\n    }\n  });\n\n  videoObserver.observe(videoElement, {\n    attributes: true,\n    attributeFilter: [\"src\"],\n    attributeOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  this.addCleanup(() => videoObserver.disconnect());\n\n  const containerObserver = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      if (mutation.type !== \"childList\") {\n        continue;\n      }\n      for (const node of mutation.addedNodes) {\n        const nextVideo = this.extractVideoElement(node);\n        if (nextVideo && nextVideo !== this.videoElement) {\n          this.initialize(nextVideo);\n          return;\n        }\n      }\n      for (const node of mutation.removedNodes) {\n        if (node === this.videoElement) {\n          this.videoElement = null;\n          this.handleVideoSourceChange(null);\n          return;\n        }\n        if (node instanceof Element) {\n          const removedVideo = node.querySelector(\"video\");\n          if (removedVideo && removedVideo === this.videoElement) {\n            this.videoElement = null;\n            this.handleVideoSourceChange(null);\n            return;\n          }\n        }\n      }\n    }\n  });\n\n  containerObserver.observe(container, { childList: true, subtree: true });\n  this.addCleanup(() => containerObserver.disconnect());\n};\n\nconst extractVideoElementImpl = function (\n  this: CommentRenderer,\n  node: Node,\n): HTMLVideoElement | null {\n  if (node instanceof HTMLVideoElement) {\n    return node;\n  }\n  if (node instanceof Element) {\n    const candidate = node.querySelector(\"video\");\n    if (candidate instanceof HTMLVideoElement) {\n      return candidate;\n    }\n  }\n  return null;\n};\n\nexport const registerLifecycleVideoMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupVideoEventListeners = setupVideoEventListenersImpl;\n  ctor.prototype.handleVideoMetadataLoaded = handleVideoMetadataLoadedImpl;\n  ctor.prototype.handleVideoStalled = handleVideoStalledImpl;\n  ctor.prototype.handleVideoCanPlay = handleVideoCanPlayImpl;\n  ctor.prototype.handleVideoSourceChange = handleVideoSourceChangeImpl;\n  ctor.prototype.syncVideoState = syncVideoStateImpl;\n  ctor.prototype.resetCommentActivity = resetCommentActivityImpl;\n  ctor.prototype.setupVideoChangeDetection = setupVideoChangeDetectionImpl;\n  ctor.prototype.extractVideoElement = extractVideoElementImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { requestAutoHardReset } from \"@/renderer/auto-hard-reset\";\nimport { toMilliseconds } from \"@/shared/constants\";\n\nconst setupVisibilityHandlingImpl = function (this: CommentRenderer): void {\n  if (\n    typeof document === \"undefined\" ||\n    typeof document.addEventListener !== \"function\" ||\n    typeof document.removeEventListener !== \"function\"\n  ) {\n    return;\n  }\n\n  const enforceVisibilityState = (): void => {\n    const state = document.visibilityState;\n    if (state !== \"visible\") {\n      this.stopAnimation();\n      return;\n    }\n    if (!this._settings.isCommentVisible) {\n      return;\n    }\n    this.handleVisibilityRestore();\n    this.startAnimation();\n  };\n\n  document.addEventListener(\"visibilitychange\", enforceVisibilityState);\n  this.addCleanup(() => document.removeEventListener(\"visibilitychange\", enforceVisibilityState));\n\n  if (document.visibilityState !== \"visible\") {\n    this.stopAnimation();\n  }\n};\n\nconst handleVisibilityRestoreImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  const ctx = this.ctx;\n  const video = this.videoElement;\n  if (!canvas || !ctx || !video) {\n    return;\n  }\n\n  this.currentTime = toMilliseconds(video.currentTime);\n  this.lastDrawTime = this.timeSource.now();\n  this.isPlaying = !video.paused;\n  this.isStalled = false;\n  this.pendingInitialSync = true;\n  this.resetFinalPhaseState();\n  this.updatePlaybackProgressState();\n  requestAutoHardReset(this, \"visibility-restore\");\n  this.draw();\n};\n\nexport const registerVisibilityMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupVisibilityHandling = setupVisibilityHandlingImpl;\n  ctor.prototype.handleVisibilityRestore = handleVisibilityRestoreImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\nimport { requestAutoHardReset } from \"@/renderer/auto-hard-reset\";\nimport { DEFAULT_LANE_COUNT, MIN_FONT_SIZE_PX, MIN_LANE_COUNT } from \"@/shared/constants\";\n\nconst resizeImpl = function (this: CommentRenderer, width?: number, height?: number): void {\n  const video = this.videoElement;\n  const canvas = this.canvas;\n  const context = this.ctx;\n  if (!video || !canvas) {\n    return;\n  }\n\n  const rect = video.getBoundingClientRect();\n  const currentDpr = this.canvasDpr > 0 ? this.canvasDpr : 1;\n  const fallbackWidth = this.displayWidth > 0 ? this.displayWidth : canvas.width / currentDpr;\n  const fallbackHeight = this.displayHeight > 0 ? this.displayHeight : canvas.height / currentDpr;\n\n  const measuredWidth = width ?? rect.width ?? fallbackWidth;\n  const measuredHeight = height ?? rect.height ?? fallbackHeight;\n\n  if (\n    !Number.isFinite(measuredWidth) ||\n    !Number.isFinite(measuredHeight) ||\n    measuredWidth <= 0 ||\n    measuredHeight <= 0\n  ) {\n    return;\n  }\n\n  const cssWidth = Math.max(1, Math.floor(measuredWidth));\n  const cssHeight = Math.max(1, Math.floor(measuredHeight));\n  const previousDisplayWidth = this.displayWidth > 0 ? this.displayWidth : cssWidth;\n  const previousDisplayHeight = this.displayHeight > 0 ? this.displayHeight : cssHeight;\n  const nextDpr = this._settings.useDprScaling ? this.resolveDevicePixelRatio() : 1;\n  const pixelWidth = Math.max(1, Math.round(cssWidth * nextDpr));\n  const pixelHeight = Math.max(1, Math.round(cssHeight * nextDpr));\n\n  const needsResize =\n    this.displayWidth !== cssWidth ||\n    this.displayHeight !== cssHeight ||\n    Math.abs(this.canvasDpr - nextDpr) > Number.EPSILON ||\n    canvas.width !== pixelWidth ||\n    canvas.height !== pixelHeight;\n\n  if (!needsResize) {\n    return;\n  }\n\n  this.displayWidth = cssWidth;\n  this.displayHeight = cssHeight;\n  this.canvasDpr = nextDpr;\n\n  canvas.width = pixelWidth;\n  canvas.height = pixelHeight;\n  canvas.style.width = `${cssWidth}px`;\n  canvas.style.height = `${cssHeight}px`;\n\n  if (context) {\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    if (this._settings.useDprScaling) {\n      context.scale(nextDpr, nextDpr);\n    }\n  }\n\n  const scaleX = previousDisplayWidth > 0 ? cssWidth / previousDisplayWidth : 1;\n  const scaleY = previousDisplayHeight > 0 ? cssHeight / previousDisplayHeight : 1;\n\n  if (scaleX !== 1 || scaleY !== 1) {\n    this.comments.forEach((comment) => {\n      if (comment.isActive) {\n        comment.x *= scaleX;\n        comment.y *= scaleY;\n        comment.width *= scaleX;\n        comment.fontSize = Math.max(\n          MIN_FONT_SIZE_PX,\n          Math.floor(Math.max(1, comment.fontSize) * scaleY),\n        );\n        comment.height = comment.fontSize;\n        comment.virtualStartX *= scaleX;\n        comment.exitThreshold *= scaleX;\n        comment.baseSpeed *= scaleX;\n        comment.speed *= scaleX;\n        comment.speedPixelsPerMs *= scaleX;\n        comment.bufferWidth *= scaleX;\n        comment.reservationWidth *= scaleX;\n      }\n    });\n  }\n\n  this.calculateLaneMetrics();\n  requestAutoHardReset(this, \"resize\");\n};\n\nconst resolveDevicePixelRatioImpl = function (this: CommentRenderer): number {\n  if (typeof window === \"undefined\") {\n    return 1;\n  }\n  const ratio = Number(window.devicePixelRatio);\n  if (!Number.isFinite(ratio) || ratio <= 0) {\n    return 1;\n  }\n  return ratio;\n};\n\nconst calculateLaneMetricsImpl = function (this: CommentRenderer): void {\n  const canvas = this.canvas;\n  if (!canvas) {\n    return;\n  }\n\n  const effectiveHeight =\n    this.displayHeight > 0 ? this.displayHeight : canvas.height / Math.max(this.canvasDpr, 1);\n  const baseHeight = Math.max(MIN_FONT_SIZE_PX, Math.floor(effectiveHeight * 0.05));\n  this.laneHeight = baseHeight * 1.2;\n  const availableLanes = Math.floor(effectiveHeight / Math.max(this.laneHeight, 1));\n  if (this._settings.useFixedLaneCount) {\n    const desired = Number.isFinite(this._settings.fixedLaneCount)\n      ? Math.floor(this._settings.fixedLaneCount)\n      : DEFAULT_LANE_COUNT;\n    const clamped = Math.max(MIN_LANE_COUNT, Math.min(availableLanes, desired));\n    this.laneCount = clamped;\n  } else {\n    this.laneCount = Math.max(MIN_LANE_COUNT, availableLanes);\n  }\n  this.topStaticLaneReservations.length = 0;\n  this.bottomStaticLaneReservations.length = 0;\n};\n\nconst setupResizeHandlingImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): void {\n  this.cleanupResizeHandling();\n\n  if (this._settings.useContainerResizeObserver && this.isResizeObserverAvailable) {\n    const target = this.resolveResizeObserverTarget(videoElement);\n    const observer = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { width, height } = entry.contentRect;\n        if (width > 0 && height > 0) {\n          this.resize(width, height);\n        } else {\n          this.resize();\n        }\n      }\n    });\n    observer.observe(target);\n    this.resizeObserver = observer;\n    this.resizeObserverTarget = target;\n  } else if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\") {\n    const onResize = (): void => {\n      this.resize();\n    };\n    window.addEventListener(\"resize\", onResize);\n    this.addCleanup(() => window.removeEventListener(\"resize\", onResize));\n  } else {\n    this.log.debug(\n      \"Resize handling is disabled because neither ResizeObserver nor window APIs are available.\",\n    );\n  }\n};\n\nconst cleanupResizeHandlingImpl = function (this: CommentRenderer): void {\n  if (this.resizeObserver && this.resizeObserverTarget) {\n    this.resizeObserver.unobserve(this.resizeObserverTarget);\n  }\n  this.resizeObserver?.disconnect();\n  this.resizeObserver = null;\n  this.resizeObserverTarget = null;\n};\n\nexport const registerResizeMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.resize = resizeImpl;\n  ctor.prototype.resolveDevicePixelRatio = resolveDevicePixelRatioImpl;\n  ctor.prototype.calculateLaneMetrics = calculateLaneMetricsImpl;\n  ctor.prototype.setupResizeHandling = setupResizeHandlingImpl;\n  ctor.prototype.cleanupResizeHandling = cleanupResizeHandlingImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nconst setupFullscreenHandlingImpl = function (this: CommentRenderer): void {\n  if (\n    typeof document === \"undefined\" ||\n    typeof document.addEventListener !== \"function\" ||\n    typeof document.removeEventListener !== \"function\"\n  ) {\n    return;\n  }\n\n  const onFullscreenChange = (): void => {\n    void this.handleFullscreenChange();\n  };\n\n  const events = [\n    \"fullscreenchange\",\n    \"webkitfullscreenchange\",\n    \"mozfullscreenchange\",\n    \"MSFullscreenChange\",\n  ];\n\n  events.forEach((eventName) => {\n    document.addEventListener(eventName, onFullscreenChange);\n    this.addCleanup(() => document.removeEventListener(eventName, onFullscreenChange));\n  });\n\n  void this.handleFullscreenChange();\n};\n\nconst resolveResizeObserverTargetImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): Element {\n  const fullscreenContainer = this.resolveFullscreenContainer(videoElement);\n  if (fullscreenContainer) {\n    return fullscreenContainer;\n  }\n  return videoElement.parentElement ?? videoElement;\n};\n\nconst handleFullscreenChangeImpl = async function (this: CommentRenderer): Promise<void> {\n  const canvas = this.canvas;\n  const video = this.videoElement;\n  if (!canvas || !video) {\n    return;\n  }\n\n  const baseContainer = this.containerElement ?? video.parentElement ?? null;\n  const fullscreenElement = this.getFullscreenElement();\n  const nextContainer = this.resolveActiveOverlayContainer(video, baseContainer, fullscreenElement);\n\n  if (!(nextContainer instanceof HTMLElement)) {\n    return;\n  }\n\n  if (canvas.parentElement !== nextContainer) {\n    this.ensureContainerPositioning(nextContainer);\n    nextContainer.appendChild(canvas);\n  } else {\n    this.ensureContainerPositioning(nextContainer);\n  }\n\n  const fullscreenContainer =\n    fullscreenElement instanceof HTMLElement && fullscreenElement.contains(video)\n      ? fullscreenElement\n      : null;\n  const isFullscreenNow = fullscreenContainer !== null;\n  if (this.fullscreenActive !== isFullscreenNow) {\n    this.fullscreenActive = isFullscreenNow;\n    this.setupResizeHandling(video);\n  }\n\n  canvas.style.position = \"absolute\";\n  canvas.style.top = \"0\";\n  canvas.style.left = \"0\";\n\n  this.resize();\n};\n\nconst resolveFullscreenContainerImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n): HTMLElement | null {\n  const fullscreenElement = this.getFullscreenElement();\n  if (!(fullscreenElement instanceof HTMLElement)) {\n    return null;\n  }\n  if (fullscreenElement === videoElement) {\n    return fullscreenElement;\n  }\n  if (fullscreenElement.contains(videoElement)) {\n    return fullscreenElement;\n  }\n  return null;\n};\n\nconst resolveActiveOverlayContainerImpl = function (\n  this: CommentRenderer,\n  videoElement: HTMLVideoElement,\n  baseContainer: HTMLElement | null,\n  fullscreenElement: Element | null,\n): HTMLElement | null {\n  if (fullscreenElement instanceof HTMLElement && fullscreenElement.contains(videoElement)) {\n    if (fullscreenElement instanceof HTMLVideoElement) {\n      if (baseContainer instanceof HTMLElement) {\n        return baseContainer;\n      }\n      return fullscreenElement;\n    }\n    return fullscreenElement;\n  }\n  return baseContainer ?? null;\n};\n\nconst getFullscreenElementImpl = function (this: CommentRenderer): Element | null {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const doc = document as Document & {\n    webkitFullscreenElement?: Element | null;\n    msFullscreenElement?: Element | null;\n    mozFullScreenElement?: Element | null;\n  };\n  return (\n    document.fullscreenElement ??\n    doc.webkitFullscreenElement ??\n    doc.mozFullScreenElement ??\n    doc.msFullscreenElement ??\n    null\n  );\n};\n\nexport const registerFullscreenMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.setupFullscreenHandling = setupFullscreenHandlingImpl;\n  ctor.prototype.resolveResizeObserverTarget = resolveResizeObserverTargetImpl;\n  ctor.prototype.handleFullscreenChange = handleFullscreenChangeImpl;\n  ctor.prototype.resolveFullscreenContainer = resolveFullscreenContainerImpl;\n  ctor.prototype.resolveActiveOverlayContainer = resolveActiveOverlayContainerImpl;\n  ctor.prototype.getFullscreenElement = getFullscreenElementImpl;\n};\n","import type { CommentRenderer } from \"@/renderer/comment-renderer\";\n\nconst addCleanupImpl = function (this: CommentRenderer, task: () => void): void {\n  this.cleanupTasks.push(task);\n};\n\nconst runCleanupTasksImpl = function (this: CommentRenderer): void {\n  while (this.cleanupTasks.length > 0) {\n    const task = this.cleanupTasks.pop();\n    try {\n      task?.();\n    } catch (error) {\n      this.log.error(\"CommentRenderer.cleanupTask\", error as Error);\n    }\n  }\n};\n\nexport const registerCleanupMethods = (ctor: typeof CommentRenderer): void => {\n  ctor.prototype.addCleanup = addCleanupImpl;\n  ctor.prototype.runCleanupTasks = runCleanupTasksImpl;\n};\n","import { cloneDefaultSettings } from \"@/config/default-settings\";\nimport type {\n  RendererSettings,\n  CommentRendererEventHooks,\n  CommentDependencies,\n  CommentPrepareOptions,\n  TimeSource,\n} from \"@/shared/types\";\nimport { Comment } from \"@/comment/comment\";\nimport { createDefaultTimeSource } from \"@/comment/time-source\";\nimport { createLogger } from \"@/shared/logger\";\nimport type { Logger } from \"@/shared/types\";\nimport { configureDebugLogging } from \"@/shared/debug\";\nimport {\n  createBrowserCanvasFactory,\n  createDefaultAnimationFrameProvider,\n  isRendererSettings,\n  normalizeSettings,\n} from \"@/shared/settings\";\nexport { createDefaultAnimationFrameProvider } from \"@/shared/settings\";\nimport type {\n  AnimationFrameProvider,\n  CommentRendererConfig,\n  CommentRendererInitializeOptions,\n  LaneReservation,\n  StaticLaneReservation,\n  VideoFrameCallbackMetadataLike,\n} from \"@/shared/types\";\nimport {\n  AUTO_HARD_RESET_DEDUP_WINDOW_MS,\n  AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS,\n  DEFAULT_LANE_COUNT,\n} from \"@/shared/constants\";\nimport { rebuildNgMatchersImpl, registerCommentCollectionMethods } from \"@/renderer/comments\";\nimport { registerFinalPhaseMethods } from \"@/renderer/final-phase\";\nimport { registerPlaybackHelpers } from \"@/renderer/playback\";\nimport { registerActivationMethods } from \"@/renderer/activation\";\nimport { registerLanePruneMethods } from \"@/renderer/lanes-prune\";\nimport { registerLaneStaticMethods } from \"@/renderer/lanes-static\";\nimport { registerLaneActivationMethods } from \"@/renderer/lanes-activation\";\nimport { registerLaneReservationMethods } from \"@/renderer/lanes-reservations\";\nimport { registerRenderMethods } from \"@/renderer/render\";\nimport { registerTimingMethods } from \"@/renderer/timing\";\nimport { registerLifecycleCoreMethods } from \"@/renderer/lifecycle-core\";\nimport { registerLifecycleVideoMethods } from \"@/renderer/lifecycle-video-events\";\nimport { registerVisibilityMethods } from \"@/renderer/visibility\";\nimport { registerResizeMethods } from \"@/renderer/resize\";\nimport { registerFullscreenMethods } from \"@/renderer/fullscreen\";\nimport { registerCleanupMethods } from \"@/renderer/cleanup\";\n\nexport type { CommentRendererConfig, CommentRendererInitializeOptions, AnimationFrameProvider };\n\nexport class CommentRenderer {\n  public _settings: RendererSettings;\n  public readonly comments: Comment[] = [];\n  public readonly activeComments = new Set<Comment>();\n  public readonly reservedLanes = new Map<number, LaneReservation[]>();\n  public readonly topStaticLaneReservations: StaticLaneReservation[] = [];\n  public readonly bottomStaticLaneReservations: StaticLaneReservation[] = [];\n  public readonly log: Logger;\n  public readonly timeSource: TimeSource;\n  public readonly animationFrameProvider: AnimationFrameProvider;\n  public readonly createCanvasElement: () => HTMLCanvasElement;\n  public readonly commentDependencies: CommentDependencies;\n  public settingsVersion = 0;\n  public normalizedNgWords: string[] = [];\n  public compiledNgRegexps: RegExp[] = [];\n  public canvas: HTMLCanvasElement | null = null;\n  public ctx: CanvasRenderingContext2D | null = null;\n  public videoElement: HTMLVideoElement | null = null;\n  public containerElement: HTMLElement | null = null;\n  public fullscreenActive = false;\n  public laneCount = DEFAULT_LANE_COUNT;\n  public laneHeight = 0;\n  public displayWidth = 0;\n  public displayHeight = 0;\n  public canvasDpr = 1;\n  public currentTime = 0;\n  public duration = 0;\n  public playbackRate = 1;\n  public isPlaying = true;\n  public isStalled = false;\n  public lastDrawTime = 0;\n  public finalPhaseActive = false;\n  public finalPhaseStartTime: number | null = null;\n  public finalPhaseScheduleDirty = false;\n  public playbackHasBegun = false;\n  public skipDrawingForCurrentFrame = false;\n  public pendingInitialSync = false;\n  public readonly finalPhaseVposOverrides = new Map<Comment, number>();\n  public frameId: ReturnType<typeof setTimeout> | null = null;\n  public videoFrameHandle: number | null = null;\n  public resizeObserver: ResizeObserver | null = null;\n  public resizeObserverTarget: Element | null = null;\n  public readonly isResizeObserverAvailable = typeof ResizeObserver !== \"undefined\";\n  public readonly cleanupTasks: Array<() => void> = [];\n  public commentSequence = 0;\n  public epochId = 0;\n  public readonly eventHooks: CommentRendererEventHooks;\n  public lastSnapshotEmitTime = 0;\n  public readonly snapshotEmitThrottleMs = 1000;\n  public lastPlayResumeTime = 0;\n  public readonly playResumeSeekIgnoreDurationMs = 500;\n  public lastVideoSource: string | null = null;\n  public lastHardResetAt = 0;\n  public readonly autoHardResetDedupWindowMs = AUTO_HARD_RESET_DEDUP_WINDOW_MS;\n  public readonly initialPlaybackAutoResetDelayMs = AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS;\n  public initialPlaybackAutoResetTimer: ReturnType<typeof setTimeout> | null = null;\n  public initialPlaybackAutoResetTriggered = false;\n\n  declare public initialize: (options: HTMLVideoElement | CommentRendererInitializeOptions) => void;\n  declare public destroy: () => void;\n  declare public destroyCanvasOnly: () => void;\n  declare public resolveContainer: (\n    explicit: HTMLElement | null | undefined,\n    video: HTMLVideoElement,\n  ) => HTMLElement;\n  declare public ensureContainerPositioning: (container: HTMLElement) => void;\n  declare public resize: (width?: number, height?: number) => void;\n  declare public resolveDevicePixelRatio: () => number;\n  declare public calculateLaneMetrics: () => void;\n  declare public setupResizeHandling: (videoElement: HTMLVideoElement) => void;\n  declare public cleanupResizeHandling: () => void;\n  declare public setupVideoEventListeners: (videoElement: HTMLVideoElement) => void;\n  declare public handleVideoMetadataLoaded: (videoElement: HTMLVideoElement) => void;\n  declare public handleVideoStalled: () => void;\n  declare public handleVideoCanPlay: () => void;\n  declare public handleVideoSourceChange: (videoElement?: HTMLVideoElement | null) => void;\n  declare public syncVideoState: (videoElement: HTMLVideoElement) => void;\n  declare public resetCommentActivity: () => void;\n  declare public setupVideoChangeDetection: (\n    video: HTMLVideoElement,\n    container: HTMLElement,\n  ) => void;\n  declare public extractVideoElement: (node: Node) => HTMLVideoElement | null;\n  declare public setupVisibilityHandling: () => void;\n  declare public handleVisibilityRestore: () => void;\n  declare public setupFullscreenHandling: () => void;\n  declare public resolveResizeObserverTarget: (videoElement: HTMLVideoElement) => Element;\n  declare public handleFullscreenChange: () => Promise<void>;\n  declare public resolveFullscreenContainer: (videoElement: HTMLVideoElement) => HTMLElement | null;\n  declare public resolveActiveOverlayContainer: (\n    videoElement: HTMLVideoElement,\n    baseContainer: HTMLElement | null,\n    fullscreenElement: Element | null,\n  ) => HTMLElement | null;\n  declare public getFullscreenElement: () => Element | null;\n  declare public addCleanup: (task: () => void) => void;\n  declare public runCleanupTasks: () => void;\n  public rebuildNgMatchers(): void {\n    rebuildNgMatchersImpl.call(this);\n  }\n  declare public isNGComment: (text: string) => boolean;\n  declare public addComments: (\n    entries: ReadonlyArray<{ text: string; vposMs: number; commands?: string[] }>,\n  ) => Comment[];\n  declare public addComment: (text: string, vposMs: number, commands?: string[]) => Comment | null;\n  declare public clearComments: () => void;\n  declare public resetState: () => void;\n  declare public hardReset: () => void;\n  declare public resetFinalPhaseState: () => void;\n  declare public incrementEpoch: (\n    reason: \"source-change\" | \"metadata-loaded\" | \"manual-reset\",\n  ) => void;\n  declare public emitStateSnapshot: (label: string) => void;\n  declare public getEffectiveCommentVpos: (comment: Comment) => number;\n  declare public getFinalPhaseDisplayDuration: (comment: Comment) => number;\n  declare public resolveFinalPhaseVpos: (comment: Comment) => number;\n  declare public recomputeFinalPhaseTimeline: () => void;\n  declare public shouldSuppressRendering: () => boolean;\n  declare public updatePlaybackProgressState: () => void;\n  declare public updateComments: (frameTimeMs?: number) => void;\n  declare public buildPrepareOptions: (visibleWidth: number) => CommentPrepareOptions;\n  declare public findAvailableLane: (comment: Comment) => number;\n  declare public findFirstValidReservationIndex: (\n    reservations: LaneReservation[],\n    cutoffTime: number,\n  ) => number;\n  declare public pruneLaneReservations: (currentTime: number) => void;\n  declare public pruneStaticLaneReservations: (currentTime: number) => void;\n  declare public findCommentIndexAtOrAfter: (targetVposMs: number) => number;\n  declare public getCommentsInTimeWindow: (centerTimeMs: number, windowMs: number) => Comment[];\n  declare public getStaticReservations: (position: \"ue\" | \"shita\") => StaticLaneReservation[];\n  declare public getStaticLaneDepth: (position: \"ue\" | \"shita\") => number;\n  declare public getStaticLaneLimit: (position: \"ue\" | \"shita\") => number;\n  declare public getGlobalLaneIndexForBottom: (localIndex: number) => number;\n  declare public resolveStaticCommentOffset: (\n    position: \"ue\" | \"shita\",\n    lane: number,\n    displayHeight: number,\n    comment: Comment,\n  ) => number;\n  declare public getStaticReservedLaneSet: () => Set<number>;\n  declare public shouldActivateCommentAtTime: (\n    comment: Comment,\n    timeMs: number,\n    preview?: string,\n  ) => boolean;\n  declare public activateComment: (\n    comment: Comment,\n    context: CanvasRenderingContext2D,\n    displayWidth: number,\n    displayHeight: number,\n    options: CommentPrepareOptions,\n    referenceTime: number,\n  ) => void;\n  declare public assignStaticLane: (\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    displayHeight: number,\n    currentTime: number,\n  ) => number;\n  declare public reserveStaticLane: (\n    position: \"ue\" | \"shita\",\n    comment: Comment,\n    lane: number,\n    releaseTime: number,\n  ) => void;\n  declare public releaseStaticLane: (position: \"ue\" | \"shita\", lane: number) => void;\n  declare public getLanePriorityOrder: (currentTime: number) => number[];\n  declare public getLaneNextAvailableTime: (lane: number, currentTime: number) => number;\n  declare public createLaneReservation: (\n    comment: Comment,\n    referenceTime: number,\n  ) => LaneReservation;\n  declare public isLaneAvailable: (\n    lane: number,\n    candidate: LaneReservation,\n    currentTime: number,\n  ) => boolean;\n  declare public storeLaneReservation: (lane: number, reservation: LaneReservation) => void;\n  declare public areReservationsConflicting: (a: LaneReservation, b: LaneReservation) => boolean;\n  declare public computeForwardGap: (\n    from: LaneReservation,\n    to: LaneReservation,\n    time: number,\n  ) => number;\n  declare public getBufferedEdges: (\n    reservation: LaneReservation,\n    time: number,\n  ) => { left: number; right: number };\n  declare public solveLeftRightEqualityTime: (\n    left: LaneReservation,\n    right: LaneReservation,\n  ) => number | null;\n  declare public draw: () => void;\n  declare public performInitialSync: (frameTimeMs?: number) => void;\n  declare public processFrame: (frameTimeMs?: number) => void;\n  declare public handleAnimationFrame: () => void;\n  declare public handleVideoFrame: (\n    now: DOMHighResTimeStamp,\n    metadata: VideoFrameCallbackMetadataLike,\n  ) => void;\n  declare public shouldUseVideoFrameCallback: () => boolean;\n  declare public scheduleNextFrame: () => void;\n  declare public cancelAnimationFrameRequest: () => void;\n  declare public cancelVideoFrameCallback: () => void;\n  declare public startAnimation: () => void;\n  declare public stopAnimation: () => void;\n  declare public onSeek: () => void;\n\n  constructor(settings: RendererSettings | null, config?: CommentRendererConfig);\n  constructor(config?: CommentRendererConfig);\n  constructor(\n    settingsOrConfig: RendererSettings | CommentRendererConfig | null = null,\n    maybeConfig: CommentRendererConfig | undefined = undefined,\n  ) {\n    let baseSettings: RendererSettings;\n    let config: CommentRendererConfig;\n\n    if (isRendererSettings(settingsOrConfig)) {\n      baseSettings = normalizeSettings({ ...(settingsOrConfig as RendererSettings) });\n      config = maybeConfig ?? {};\n    } else {\n      const configCandidate = settingsOrConfig ?? maybeConfig ?? {};\n      config =\n        typeof configCandidate === \"object\" ? (configCandidate as CommentRendererConfig) : {};\n      baseSettings = normalizeSettings(cloneDefaultSettings());\n    }\n\n    this._settings = normalizeSettings(baseSettings);\n    this.timeSource = config.timeSource ?? createDefaultTimeSource();\n    this.animationFrameProvider =\n      config.animationFrameProvider ?? createDefaultAnimationFrameProvider(this.timeSource);\n    this.createCanvasElement = config.createCanvasElement ?? createBrowserCanvasFactory();\n    this.commentDependencies = {\n      timeSource: this.timeSource,\n      settingsVersion: this.settingsVersion,\n    };\n    this.log = createLogger(config.loggerNamespace ?? \"CommentRenderer\");\n    this.eventHooks = config.eventHooks ?? {};\n\n    this.handleAnimationFrame = this.handleAnimationFrame.bind(this);\n    this.handleVideoFrame = this.handleVideoFrame.bind(this);\n\n    this.rebuildNgMatchers();\n\n    if (config.debug) {\n      configureDebugLogging(config.debug);\n    }\n  }\n\n  get settings(): RendererSettings {\n    return this._settings;\n  }\n\n  set settings(value: RendererSettings) {\n    this._settings = normalizeSettings(value);\n    this.settingsVersion += 1;\n    this.commentDependencies.settingsVersion = this.settingsVersion;\n    this.rebuildNgMatchers();\n  }\n\n  getVideoElement(): HTMLVideoElement | null {\n    return this.videoElement;\n  }\n\n  getCurrentVideoSource(): string | null {\n    const video = this.videoElement;\n    if (!video) {\n      return null;\n    }\n    if (typeof video.currentSrc === \"string\" && video.currentSrc.length > 0) {\n      return video.currentSrc;\n    }\n    const attribute = video.getAttribute(\"src\");\n    if (attribute && attribute.length > 0) {\n      return attribute;\n    }\n    const sourceElement = video.querySelector(\"source[src]\") as HTMLSourceElement | null;\n    if (sourceElement && typeof sourceElement.src === \"string\") {\n      return sourceElement.src;\n    }\n    return null;\n  }\n\n  getCommentsSnapshot(): Comment[] {\n    return [...this.comments];\n  }\n}\n\nregisterCommentCollectionMethods(CommentRenderer);\nregisterFinalPhaseMethods(CommentRenderer);\nregisterPlaybackHelpers(CommentRenderer);\nregisterActivationMethods(CommentRenderer);\nregisterLanePruneMethods(CommentRenderer);\nregisterLaneStaticMethods(CommentRenderer);\nregisterLaneActivationMethods(CommentRenderer);\nregisterLaneReservationMethods(CommentRenderer);\nregisterRenderMethods(CommentRenderer);\nregisterTimingMethods(CommentRenderer);\nregisterLifecycleCoreMethods(CommentRenderer);\nregisterLifecycleVideoMethods(CommentRenderer);\nregisterVisibilityMethods(CommentRenderer);\nregisterResizeMethods(CommentRenderer);\nregisterFullscreenMethods(CommentRenderer);\nregisterCleanupMethods(CommentRenderer);\n"],"names":["COMMENT_SIZE_SCALE","FONT_FAMILY_MAP","COLOR_COMMAND_MAP","HEX_COLOR_REGEX","COMMAND_PREFIX_STRIP_REGEX","COMMAND_SUFFIX_STRIP_REGEX","normalizeCommandToken","value","trimmed","normalizeHexColor","command","parseNumericCommandValue","withoutPx","parsed","parseLineHeightValue","numeric","clampLetterSpacing","clampLineHeight","isLayoutCommand","isSizeCommand","isFontCommand","isColorCommand","parseCommentCommands","commands","context","layout","size","font","colorOverride","opacityMultiplier","opacityOverride","isInvisible","letterSpacing","lineHeight","rawCommand","normalizedToken","normalized","lower","separatorIndex","numericValue","clampedOpacityMultiplier","resolvedColor","resolvedOpacityOverride","HEX_COLOR_PATTERN","expandHex","fragment","parseHexComponent","component","clampOpacity","resolveFillStyleWithOpacity","color","opacity","match","body","red","green","blue","alpha","combinedAlpha","createPerformanceTimeSource","createDefaultTimeSource","toMilliseconds","seconds","sanitizeVposMs","MAX_VISIBLE_DURATION_MS","MIN_VISIBLE_DURATION_MS","MAX_COMMENT_WIDTH_RATIO","COLLISION_BUFFER_RATIO","BASE_COLLISION_BUFFER_PX","ENTRY_BUFFER_PX","RESERVATION_TIME_MARGIN_MS","FINAL_PHASE_THRESHOLD_MS","FINAL_PHASE_MIN_GAP_MS","FINAL_PHASE_MAX_GAP_MS","FINAL_PHASE_ORDER_EPSILON_MS","FINAL_PHASE_MIN_WINDOW_MS","STATIC_VISIBLE_DURATION_MS","ACTIVE_WINDOW_MS","VIRTUAL_CANVAS_EXTENSION_PX","MIN_LANE_COUNT","DEFAULT_LANE_COUNT","MIN_FONT_SIZE_PX","EDGE_EPSILON","SEEK_DIRECTION_EPSILON_MS","STATIC_COMMENT_VERTICAL_PADDING_RATIO","STATIC_COMMENT_MIN_VERTICAL_PADDING_PX","STATIC_COMMENT_SIDE_MARGIN_PX","MIN_STATIC_FONT_SIZE_PX","AUTO_HARD_RESET_DEDUP_WINDOW_MS","AUTO_HARD_RESET_INITIAL_PLAYBACK_DELAY_MS","LEVEL_PRIORITY","fallbackEmitter","level","namespace","args","consoleArgs","createLogger","options","emitter","threshold","emit","logLevel","messages","commentLogger","textMeasurementCaches","getTextMeasurementCache","ctx","cache","measureTextWidth","text","cacheKey","cached","width","ensureLines","rawLines","clampFontSize","updateTextMetrics","comment","maxLineWidth","effectiveLetterSpacing","line","baseWidth","extraSpacing","totalWidth","computedLineHeightPx","additionalHeight","prepareComment","visibleWidth","canvasHeight","safeVisibleWidth","baseFontSize","scaledFontSize","isStaticTopOrBottom","maxStaticWidth","minimumFontSize","shrinkFactor","initialShrink","iteration","currentShrink","proposedSize","margin","centeredX","maxStart","clampedX","maxReservationWidth","bufferFromWidth","entryBuffer","direction","startLeft","exitLeft","trailingBoundary","trailingEdgeAtStart","widthRatio","hasFixedDuration","visibleDurationMs","clampedRatio","adjustedDuration","visibleDistance","safeVisibleDuration","pixelsPerMs","pixelsPerFrame","travelDistance","preCollisionDistance","safePixelsPerMs","reservationBase","error","logger","DEFAULT_MAX_LOGS_PER_CATEGORY","state","categoryCounters","normalizeLimit","limit","rounded","configureDebugLogging","resetDebugCounters","isDebugLoggingEnabled","shouldEmitLog","category","currentCount","debugLog","payload","formatCommentPreview","maxLength","dumpRendererState","label","snapshot","logEpochChange","previousEpochId","newEpochId","reason","cacheStats","reportCacheStats","now","total","hitRate","avgCharsPerComment","totalOutlineCalls","totalFillCalls","isOffscreenCanvasSupported","getOutlineOffsets","fontSize","outlineThickness","offsets","diagonal","createSegmentDrawer","targetCtx","measurementCtx","statsTarget","baseDrawX","baselineY","mode","offsetX","leadingSpaces","leadingSpaceCount","leadingSpaceOffset","effectiveDrawX","trimmedLine","recordDraw","cursorX","index","char","advance","generateTextureCacheKey","createTextureCanvas","hasLetterSpacing","isMultiLine","padding","textureWidth","textureHeight","offscreen","offscreenCtx","effectiveOpacity","drawX","linesToRender","lineAdvance","baselineStart","drawSegment","outlineOffsets","drawOutline","outlineAlpha","offsetY","baseline","drawFill","fillStyle","baseShadowOffset","baseShadowBlur","layer","effectiveShadowAlpha","resolvedFillStyle","drawWithFallback","interpolatedX","drawComment","currentCacheKey","cachedTexture","created","texture","resolveScrollDirection","input","getDirectionSign","Comment","vposMs","settings","dependencies","parsedCommands","playbackRate","isPaused","currentTime","deltaTime","settingsVersion","defaultColor","candidate","defaultOpacity","scaled","atTimeMs","currentTimeMs","resolved","NICO_COMPAT_SCROLL_VISIBLE_DURATION_MS","BASE_SETTINGS","DEFAULT_RENDERER_SETTINGS","cloneDefaultSettings","COMMENT_OVERLAY_VERSION","calculateStaticCommentVerticalPadding","normalizeSettings","rawDuration","normalizedDuration","createDefaultAnimationFrameProvider","timeSource","callback","handle","createBrowserCanvasFactory","isRendererSettings","addCommentsImpl","entries","addedComments","entry","preview","normalizedVposMs","a","b","vposMsDiff","addCommentImpl","clearCommentsImpl","effectiveDpr","height","resetStateImpl","rebuildNgMatchersImpl","ngWords","word","sourcePatterns","isNgCommentImpl","regexp","registerCommentCollectionMethods","ctor","hardResetImpl","canvas","effectiveWidth","effectiveHeight","resetFinalPhaseStateImpl","incrementEpochImpl","info","emitStateSnapshotImpl","getEffectiveCommentVposImpl","getFinalPhaseDisplayDurationImpl","durations","resolveFinalPhaseVposImpl","override","fallback","recomputeFinalPhaseTimelineImpl","windowStart","durationMs","windowEnd","candidates","diff","baseGap","boundedGap","gap","nextStart","durationNeeded","availableLatestStart","assigned","epsilon","spacing","registerFinalPhaseMethods","shouldSuppressRenderingImpl","updatePlaybackProgressStateImpl","registerPlaybackHelpers","updateCommentsImpl","frameTimeMs","video","referenceTime","prepareOptions","isNearEnd","activeWindowComments","debugActive","staticPosition","buildPrepareOptionsImpl","overrideDuration","maxVisibleDurationMs","minVisibleDurationMs","findAvailableLaneImpl","laneCandidates","newReservation","lane","fallbackLane","registerActivationMethods","findFirstValidReservationIndexImpl","reservations","cutoffTime","left","right","mid","reservation","pruneLaneReservationsImpl","firstValidIndex","pruneStaticLaneReservationsImpl","filterValid","topFiltered","bottomFiltered","registerLanePruneMethods","findCommentIndexAtOrAfterImpl","targetVposMs","getCommentsInTimeWindowImpl","centerTimeMs","windowMs","startTime","endTime","startIndex","result","i","getStaticReservationsImpl","position","getStaticLaneDepthImpl","getStaticLaneLimitImpl","otherPosition","otherDepth","available","getGlobalLaneIndexForBottomImpl","localIndex","resolveStaticCommentOffsetImpl","displayHeight","commentHeight","baseY","minY","maxY","adjustedY","getStaticReservedLaneSetImpl","reserved","registerLaneStaticMethods","shouldActivateCommentAtTimeImpl","timeMs","effectiveVpos","activateCommentImpl","displayWidth","elapsedMs","displacement","videoDuration","finalPhaseWindowEnd","totalTravelDistance","projectedTravelMs","remainingTime","allowedTravel","startX","laneIndex","laneHeight","laneY","verticalOffset","displayEnd","assignStaticLaneImpl","laneCount","laneIndices","_","yOffset","yStart","yEnd","earliestRelease","reserveStaticLaneImpl","releaseTime","releaseStaticLaneImpl","r","registerLaneActivationMethods","getLanePriorityOrderImpl","sorted","nextA","nextB","staticReserved","preferred","blocked","getLaneNextAvailableTimeImpl","validIndex","createLaneReservationImpl","speed","effectiveStart","baseStartTime","totalEndTime","isLaneAvailableImpl","storeLaneReservationImpl","updated","areReservationsConflictingImpl","overlapStart","overlapEnd","evaluationTimes","forwardIntersection","backwardIntersection","time","forwardGap","backwardGap","computeForwardGapImpl","from","to","fromEdges","toEdges","getBufferedEdgesImpl","elapsed","rawLeft","solveLeftRightEqualityTimeImpl","leftSign","rightSign","denominator","registerLaneReservationMethods","drawImpl","activeComments","aVpos","bVpos","performInitialSyncImpl","absoluteTime","registerRenderMethods","processFrameImpl","handleAnimationFrameImpl","pendingId","handleVideoFrameImpl","_now","metadata","mediaTime","shouldUseVideoFrameCallbackImpl","scheduleNextFrameImpl","request","cancelAnimationFrameRequestImpl","cancelVideoFrameCallbackImpl","startAnimationImpl","stopAnimationImpl","onSeekImpl","nextTime","timeDelta","isSignificantSeek","registerTimingMethods","shouldAutoHardReset","renderer","requestAutoHardReset","scheduleInitialPlaybackAutoReset","resetInitialPlaybackAutoResetState","resolveContainerImpl","explicit","ensureContainerPositioningImpl","container","initializeImpl","containerCandidate","parent","destroyImpl","destroyCanvasOnlyImpl","registerLifecycleCoreMethods","setupVideoEventListenersImpl","videoElement","onPlay","wasPlaying","onPause","onSeeking","onSeeked","onRateChange","onLoadedMetadata","onDurationChange","onEmptied","onWaiting","onCanPlay","onPlaying","handleVideoMetadataLoadedImpl","handleVideoStalledImpl","handleVideoCanPlayImpl","handleVideoSourceChangeImpl","target","currentSource","syncVideoStateImpl","resetCommentActivityImpl","setupVideoChangeDetectionImpl","videoObserver","mutations","mutation","targetNode","previous","current","node","containerObserver","nextVideo","removedVideo","extractVideoElementImpl","registerLifecycleVideoMethods","setupVisibilityHandlingImpl","enforceVisibilityState","handleVisibilityRestoreImpl","registerVisibilityMethods","resizeImpl","rect","currentDpr","fallbackWidth","fallbackHeight","measuredWidth","measuredHeight","cssWidth","cssHeight","previousDisplayWidth","previousDisplayHeight","nextDpr","pixelWidth","pixelHeight","scaleX","scaleY","resolveDevicePixelRatioImpl","ratio","calculateLaneMetricsImpl","baseHeight","availableLanes","desired","clamped","setupResizeHandlingImpl","observer","onResize","cleanupResizeHandlingImpl","registerResizeMethods","setupFullscreenHandlingImpl","onFullscreenChange","eventName","resolveResizeObserverTargetImpl","fullscreenContainer","handleFullscreenChangeImpl","baseContainer","fullscreenElement","nextContainer","isFullscreenNow","resolveFullscreenContainerImpl","resolveActiveOverlayContainerImpl","getFullscreenElementImpl","doc","registerFullscreenMethods","addCleanupImpl","task","runCleanupTasksImpl","registerCleanupMethods","CommentRenderer","settingsOrConfig","maybeConfig","baseSettings","config","configCandidate","attribute","sourceElement"],"mappings":"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"}