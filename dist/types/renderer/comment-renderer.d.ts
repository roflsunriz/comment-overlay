import type { RendererSettings, CommentRendererEventHooks, CommentDependencies, CommentPrepareOptions, TimeSource } from "@/shared/types";
import { Comment } from "@/comment/comment";
import type { Logger } from "@/shared/types";
export { createDefaultAnimationFrameProvider } from "@/shared/settings";
import type { AnimationFrameProvider, CommentRendererConfig, CommentRendererInitializeOptions, LaneReservation, StaticLaneReservation, VideoFrameCallbackMetadataLike } from "@/shared/types";
export type { CommentRendererConfig, CommentRendererInitializeOptions, AnimationFrameProvider };
export declare class CommentRenderer {
    _settings: RendererSettings;
    readonly comments: Comment[];
    readonly activeComments: Set<Comment>;
    readonly reservedLanes: Map<number, LaneReservation[]>;
    readonly topStaticLaneReservations: StaticLaneReservation[];
    readonly bottomStaticLaneReservations: StaticLaneReservation[];
    readonly log: Logger;
    readonly timeSource: TimeSource;
    readonly animationFrameProvider: AnimationFrameProvider;
    readonly createCanvasElement: () => HTMLCanvasElement;
    readonly commentDependencies: CommentDependencies;
    settingsVersion: number;
    normalizedNgWords: string[];
    compiledNgRegexps: RegExp[];
    canvas: HTMLCanvasElement | null;
    ctx: CanvasRenderingContext2D | null;
    videoElement: HTMLVideoElement | null;
    containerElement: HTMLElement | null;
    fullscreenActive: boolean;
    laneCount: number;
    laneHeight: number;
    displayWidth: number;
    displayHeight: number;
    canvasDpr: number;
    currentTime: number;
    duration: number;
    playbackRate: number;
    isPlaying: boolean;
    isStalled: boolean;
    lastDrawTime: number;
    finalPhaseActive: boolean;
    finalPhaseStartTime: number | null;
    finalPhaseScheduleDirty: boolean;
    playbackHasBegun: boolean;
    skipDrawingForCurrentFrame: boolean;
    pendingInitialSync: boolean;
    readonly finalPhaseVposOverrides: Map<Comment, number>;
    frameId: ReturnType<typeof setTimeout> | null;
    videoFrameHandle: number | null;
    resizeObserver: ResizeObserver | null;
    resizeObserverTarget: Element | null;
    readonly isResizeObserverAvailable: boolean;
    readonly cleanupTasks: Array<() => void>;
    commentSequence: number;
    epochId: number;
    readonly eventHooks: CommentRendererEventHooks;
    lastSnapshotEmitTime: number;
    readonly snapshotEmitThrottleMs = 1000;
    lastPlayResumeTime: number;
    readonly playResumeSeekIgnoreDurationMs = 500;
    lastVideoSource: string | null;
    initialize: (options: HTMLVideoElement | CommentRendererInitializeOptions) => void;
    destroy: () => void;
    destroyCanvasOnly: () => void;
    resolveContainer: (explicit: HTMLElement | null | undefined, video: HTMLVideoElement) => HTMLElement;
    ensureContainerPositioning: (container: HTMLElement) => void;
    resize: (width?: number, height?: number) => void;
    resolveDevicePixelRatio: () => number;
    calculateLaneMetrics: () => void;
    setupResizeHandling: (videoElement: HTMLVideoElement) => void;
    cleanupResizeHandling: () => void;
    setupVideoEventListeners: (videoElement: HTMLVideoElement) => void;
    handleVideoMetadataLoaded: (videoElement: HTMLVideoElement) => void;
    handleVideoStalled: () => void;
    handleVideoCanPlay: () => void;
    handleVideoSourceChange: (videoElement?: HTMLVideoElement | null) => void;
    syncVideoState: (videoElement: HTMLVideoElement) => void;
    resetCommentActivity: () => void;
    setupVideoChangeDetection: (video: HTMLVideoElement, container: HTMLElement) => void;
    extractVideoElement: (node: Node) => HTMLVideoElement | null;
    setupVisibilityHandling: () => void;
    handleVisibilityRestore: () => void;
    setupFullscreenHandling: () => void;
    resolveResizeObserverTarget: (videoElement: HTMLVideoElement) => Element;
    handleFullscreenChange: () => Promise<void>;
    resolveFullscreenContainer: (videoElement: HTMLVideoElement) => HTMLElement | null;
    resolveActiveOverlayContainer: (videoElement: HTMLVideoElement, baseContainer: HTMLElement | null, fullscreenElement: Element | null) => HTMLElement | null;
    getFullscreenElement: () => Element | null;
    addCleanup: (task: () => void) => void;
    runCleanupTasks: () => void;
    rebuildNgMatchers(): void;
    isNGComment: (text: string) => boolean;
    addComments: (entries: ReadonlyArray<{
        text: string;
        vposMs: number;
        commands?: string[];
    }>) => Comment[];
    addComment: (text: string, vposMs: number, commands?: string[]) => Comment | null;
    clearComments: () => void;
    resetState: () => void;
    hardReset: () => void;
    resetFinalPhaseState: () => void;
    incrementEpoch: (reason: "source-change" | "metadata-loaded" | "manual-reset") => void;
    emitStateSnapshot: (label: string) => void;
    getEffectiveCommentVpos: (comment: Comment) => number;
    getFinalPhaseDisplayDuration: (comment: Comment) => number;
    resolveFinalPhaseVpos: (comment: Comment) => number;
    recomputeFinalPhaseTimeline: () => void;
    shouldSuppressRendering: () => boolean;
    updatePlaybackProgressState: () => void;
    updateComments: (frameTimeMs?: number) => void;
    buildPrepareOptions: (visibleWidth: number) => CommentPrepareOptions;
    findAvailableLane: (comment: Comment) => number;
    findFirstValidReservationIndex: (reservations: LaneReservation[], cutoffTime: number) => number;
    pruneLaneReservations: (currentTime: number) => void;
    pruneStaticLaneReservations: (currentTime: number) => void;
    findCommentIndexAtOrAfter: (targetVposMs: number) => number;
    getCommentsInTimeWindow: (centerTimeMs: number, windowMs: number) => Comment[];
    getStaticReservations: (position: "ue" | "shita") => StaticLaneReservation[];
    getStaticLaneDepth: (position: "ue" | "shita") => number;
    getStaticLaneLimit: (position: "ue" | "shita") => number;
    getGlobalLaneIndexForBottom: (localIndex: number) => number;
    resolveStaticCommentOffset: (position: "ue" | "shita", lane: number, displayHeight: number, comment: Comment) => number;
    getStaticReservedLaneSet: () => Set<number>;
    shouldActivateCommentAtTime: (comment: Comment, timeMs: number, preview?: string) => boolean;
    activateComment: (comment: Comment, context: CanvasRenderingContext2D, displayWidth: number, displayHeight: number, options: CommentPrepareOptions, referenceTime: number) => void;
    assignStaticLane: (position: "ue" | "shita", comment: Comment, displayHeight: number, currentTime: number) => number;
    reserveStaticLane: (position: "ue" | "shita", comment: Comment, lane: number, releaseTime: number) => void;
    releaseStaticLane: (position: "ue" | "shita", lane: number) => void;
    getLanePriorityOrder: (currentTime: number) => number[];
    getLaneNextAvailableTime: (lane: number, currentTime: number) => number;
    createLaneReservation: (comment: Comment, referenceTime: number) => LaneReservation;
    isLaneAvailable: (lane: number, candidate: LaneReservation, currentTime: number) => boolean;
    storeLaneReservation: (lane: number, reservation: LaneReservation) => void;
    areReservationsConflicting: (a: LaneReservation, b: LaneReservation) => boolean;
    computeForwardGap: (from: LaneReservation, to: LaneReservation, time: number) => number;
    getBufferedEdges: (reservation: LaneReservation, time: number) => {
        left: number;
        right: number;
    };
    solveLeftRightEqualityTime: (left: LaneReservation, right: LaneReservation) => number | null;
    draw: () => void;
    performInitialSync: (frameTimeMs?: number) => void;
    processFrame: (frameTimeMs?: number) => void;
    handleAnimationFrame: () => void;
    handleVideoFrame: (now: DOMHighResTimeStamp, metadata: VideoFrameCallbackMetadataLike) => void;
    shouldUseVideoFrameCallback: () => boolean;
    scheduleNextFrame: () => void;
    cancelAnimationFrameRequest: () => void;
    cancelVideoFrameCallback: () => void;
    startAnimation: () => void;
    stopAnimation: () => void;
    onSeek: () => void;
    constructor(settings: RendererSettings | null, config?: CommentRendererConfig);
    constructor(config?: CommentRendererConfig);
    get settings(): RendererSettings;
    set settings(value: RendererSettings);
    getVideoElement(): HTMLVideoElement | null;
    getCurrentVideoSource(): string | null;
    getCommentsSnapshot(): Comment[];
}
//# sourceMappingURL=comment-renderer.d.ts.map