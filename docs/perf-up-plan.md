# パフォーマンス改善 実行計画書

`improve-performance.md` の分析に基づき、実装の難易度とリグレッションリスクが低いものから順に並べた実行計画。各項目の進捗をチェックリスト形式で管理する。

## 凡例

- [x] ✅ 完了
- [ ] ⏳ 未着手
- [-] 🔄 進行中

## Step 1: 低リスク・高効果な最適化 (基本改善)

最初に適用すべき、安全かつ効果の高い項目群。

- [x] **状態変更のバッチング**
  - **内容:** `settings` 更新時にバージョン番号をインクリメントし、フレームループ内での `syncWithSettings` の呼び出しを、設定が本当に変更されたフレームのみに限定する。
  - **理由:** 毎フレーム全コメントを走査して設定を同期する無駄をなくす。リグレッションリスクが極めて低く、実装も容易。
  - **対応状況:** `settingsVersion` を導入し `Comment.syncWithSettings` を差分同期化済み。

- [x] **文字幅計測 (`ctx.measureText`) のキャッシュ**
  - **内容:** `font` スタイルとテキスト内容をキーとして `ctx.measureText()` の結果を `Map` にキャッシュし、同じ計算を繰り返さないようにする。
  - **理由:** `prepare` 処理中のCPU負荷を大幅に削減。特にAA（アスキーアート）など同じ文字が多用されるコメントで効果絶大。
  - **対応状況:** `WeakMap` ベースのテキスト幅キャッシュを導入済み。

- [x] **NG判定の事前計算 & 正規表現の事前コンパイル**
  - **内容:** `settings` 更新時にNGワード用の正規表現を `RegExp` オブジェクトとして事前にコンパイルしておく。フレームループ中の `new RegExp()` 呼び出しをなくす。
  - **理由:** `isNGComment` が呼ばれる際のオーバーヘッドを解消。`addComment` 時や描画ループ中の動的なNG判定が高速化される。
  - **対応状況:** NGワードを小文字正規化し、正規表現をビルドして再利用する仕組みを追加済み。

- [x] **不可視タブでのアニメーション停止**
  - **内容:** `document.visibilityState` を監視し、タブが非表示になったら `stopAnimation()` を呼び出し、表示されたら再開する。
  - **理由:** バックグラウンドでの不要な描画処理を完全に停止させ、CPU・バッテリー消費を抑える。
  - **対応状況:** `visibilitychange` ハンドリングを追加し、非表示時はアニメーションを停止するよう実装済み。

- [x] **`Array.prototype.sort` の呼び出し回数削減**
  - **内容:** 大量のコメントを一度に追加するための `addComments(comments)` のようなバルクAPIを導入し、`sort` 処理を一度で済ませる。
  - **理由:** コメント初期投入時のパフォーマンスを改善する。
  - **対応状況:** `addComments` APIを追加し、ソートを一括で実行するよう改善済み。

## Step 2: 中リスク・高効果な最適化 (コアロジック改善)

次に、アプリケーションのコアロジックに手を入れる改善項目。

- [x] **時間インデックス導入によるコメント走査範囲の限定**
  - **内容:** `updateComments` 内で、全コメント配列を走査する代わりに、現在の再生時間 `currentTime` を中心としたアクティブな時間窓 `ACTIVE_WINDOW_MS` 内のコメントのみを処理対象とする。対象範囲の特定には二分探索を用いる。
  - **理由:** コメント数が増えてもフレームあたりの処理量が一定に保たれ、スケール性能が劇的に向上する。
  - **対応状況:** ✅ 完了。二分探索による範囲特定を実装し、`updateComments`と`onSeek`で適用済み。

- [x] **アクティブコメント配列の分離管理**
  - **内容:** `draw` ループ内で毎回 `comments.filter(c => c.isActive)` するのをやめ、`activeComments` という `Set` または配列を別途保持し、コメントのアクティブ状態が変化するタイミングで追加・削除を行う。
  - **理由:** 描画対象コメントのリストアップが `O(N)` から `O(1)` になり、描画ループのオーバーヘッドを削減する。
  - **対応状況:** ✅ 完了。`activeComments: Set<Comment>`を導入し、アクティブ状態変更時に追加・削除を実装済み。

- [x] **レーン予約リストの最適化**
  - **内容:** `reservedLanes` の予約リストを時刻でソート済み状態に保ち、期限切れの予約を二分探索で効率的に特定し、一括で削除する。
  - **理由:** レーン確保処理 `findAvailableLane` 内での不要な走査を減らし、コメントが密集するシーンでのパフォーマンスを改善する。
  - **対応状況:** ✅ 完了。`totalEndTime`でソート、二分探索による期限切れ予約の効率的削除、`isLaneAvailable`と`getLaneNextAvailableTime`も最適化済み。

## Step 3: 高難度または高リスクな最適化 (応用改善)

十分なテスト期間を確保できる場合に挑戦する高度な項目。

- [x] **オフスクリーンでのテクスチャ化**
  - **内容:** AAや職人コメントなど、頻繁に描画される複雑なコメントを `OffscreenCanvas` を使ってビットマップ画像に変換（テクスチャ化）し、`draw` 処理では `drawImage` で高速に描画する。
  - **理由:** 複雑なテキスト描画（特に `strokeText`）のコストを大幅に削減できる。
  - **対応状況:** ✅ 完了。OffscreenCanvasでテクスチャ生成、キャッシュキーによる再利用、フォールバック実装済み。

- [x] **strokeText削減によるCanvas API呼び出し最適化**
  - **内容:** フォントサイズに応じて`strokeText`の使用を制御。小フォント（<30px）では`shadowBlur`で擬似アウトラインを実現し、高負荷な`strokeText`呼び出しをスキップする。`strokeTextThreshold`設定で閾値を調整可能。
  - **理由:** プロファイル結果から、ボトルネックは計算ではなく描画（`strokeText`の大量呼び出し）であることが判明。89%のstrokeText削減を達成。
  - **対応状況:** ✅ 完了。`RendererSettings.strokeTextThreshold: 30`、小フォント時は`shadowBlur`に置き換え、大フォントは従来通り`strokeText`を使用。

- [-] **レイアウト計算のWeb Worker化**
  - **内容:** `prepare` 処理など、CPU負荷の高い計算（文字幅計測を除くロジック）をWeb Workerにオフロードし、メインスレッドのブロッキングを防ぐ。
  - **理由:** 描画処理と計算処理を並列化し、フレームレートの安定化に貢献する。
  - **対応状況:** 🚫 **中止**。プロファイル結果から、ボトルネックは計算（レイアウト）ではなく描画（Canvas API）であることが判明。Worker化による通信コストが計算コストを上回る可能性が高いため、描画最適化（strokeText削減）を優先。

- [ ] **`clearRect` の範囲最小化**
  - **内容:** 毎フレーム全画面をクリアするのではなく、動いているコメントの領域だけを計算し、その「ダーティ領域」のみをクリア・再描画する。
  - **理由:** GPUへの転送量とフィルレートを削減できるが、ダーティ領域の計算が複雑でリグレッションリスクも高い。
  - **対応状況:** ⏳ 未着手。
